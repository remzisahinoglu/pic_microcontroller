CCS PCH C Compiler, Version 4.106, 14749               06-May-11 21:09

               Filename: D:\ram\parellel robot\elektronik\kumandadan xyz kontrol\test\step motor kontrol 877\xyz_kontrol_18f4620.lst

               ROM used: 19990 bytes (31%)
                         Largest free fragment is 45546
               RAM used: 164 (4%) at main() level
                         241 (6%) worst case
               Stack:    7 locations

*
00000:  GOTO   4458
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                    xyz_kontrol_18F4620.C                             //// 
.................... ////                                                                       //// 
.................... ////  Bu program 3-dof delata robotu, x,y,z eksenleri doðrultusunda        //// 
.................... ////  kullanýcý tarafýndan 10 micron ile 10 cm hassasiyetle kumandadan     //// 
.................... ////  kontrol edilmesini saðlar.                                           //// 
.................... ////                                                                       //// 
.................... ////  Sisteme enerji verildiðinde lcd ekranda ilk olarak 3sn boyunca       //// 
.................... ////  giriþ ekraný görüntülenir. Ardýndan "Position" ekranýnda robotun     //// 
.................... ////  o anki pozisonu görüntülenir. lcd butonuna ardarda basýlarak         //// 
.................... ////  "Angle", "Step Count" ve diðer ekranlar görüntülenebilir.            //// 
.................... ////                                                                       //// 
.................... ////  Robotun ilk kurulumdan sonra kalibrasyonundan ayarý yapýlabilmesi    //// 
.................... ////  için "Kalibre" butonu bir kez kontrol edilir. Ardýndan eksen         //// 
.................... ////  butonlarý için tarama kýsýr döngüye girer. Bu esnada eksen           //// 
.................... ////  butonlarýndan girilen koordinat bilgisinin açý deðerleri robotun     //// 
.................... ////  sýfýr posizyonuna göre hesaplanýr. Bu deðerlere göre step motorun    //// 
.................... ////  hareketi için adým deðerleri hesaplanýr. Adým deðerleri baz alýnarak //// 
.................... ////  üç motorunda ayný zamanda çalýþmaya baþlayýp sonlanmasý için adýmlar //// 
.................... ////  arasý zaman deðiþkenleri hesaplanýp motor adým bilgisi ile motor     //// 
.................... ////  sürücü microdenetleyicilerine (PIC16F628A, xyz_kontrol_16F628A.C)    //// 
.................... ////  gönderilir.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Motor sürücü microdenetleyicileri tarafýndan alýnan bu deðerler      //// 
.................... ////  pozitif ise motoru o deðer kadar ve hesaplanan gecikme süreleri      //// 
.................... ////  ile motora hareket verir. Deðer negatif ise ayný þekilde ters        ////   
.................... ////  yönde hereket verir. Eðer kumandadan girilen koordinat bilgisi       //// 
.................... ////  robotun çalýþma uzayý dýþýnda ise lcd ekranda hata mesajý görütü-    //// 
.................... ////  lenir ve kullanýcýdan çalýþma uzayý içinde bir nokta girilmesi       //// 
.................... ////  beklenir.                                                            //// 
.................... ////                                                                       //// 
.................... ////  Robot geometry:                                                      //// 
.................... ////     e = 109.12;     // end effector                                   //// 
.................... ////     f = 346.41;     // base                                           //// 
.................... ////     re = 323.59;    // rod                                            //// 
.................... ////     rf = 133.09;    // arm                                            //// 
.................... ////                                                                       //// 
.................... ////  Kullanýlan kontrolor 18F46K20 (32Kb, 4MHz), 16F628A(2Kb, 4MHz)       //// 
.................... ////  LCD ekran HD44780 tabalý 4x16 HY-1604A06 alphanumeric numeric        //// 
.................... ////                                                                       //// 
.................... ////  LCD ekran pinleri: PORTB                                             //// 
.................... ////     Vss 1: GND                  Data baðlantýlarý                     //// 
.................... ////     Vdd 2: +5V                                                        //// 
.................... ////     Vee 3: 10k POT                                                    //// 
.................... ////     RS  4: RB1                                                        //// 
.................... ////     RW  5: RB2                                                        //// 
.................... ////     E   6: RB0                                                        //// 
.................... ////     D0-D3 7-10: No connection                                         //// 
.................... ////     D4 11: RB4                                                        //// 
.................... ////     D5 12: RB5                                                        //// 
.................... ////     D6 13: RB6                                                        //// 
.................... ////     D7 14: RB7                                                        //// 
.................... ////                                                                       //// 
.................... ////  XYZ eksen butonlarý: PORTD                                           //// 
.................... ////     +X: RD0                                                           //// 
.................... ////     -X: RD1                                                           //// 
.................... ////     +Y: RD2                                                           //// 
.................... ////     -Y: RD3                                                           //// 
.................... ////     +Z: RD4                                                           //// 
.................... ////     -Z: RD5                                                           //// 
.................... ////                                                                       //// 
.................... ////  Diðer butonlar: PORTD                                                //// 
.................... ////     LCD         : RD6                                                 //// 
.................... ////     Hassasiyet  : RD7                                                 //// 
.................... ////        : RC2                                                          //// 
.................... ////        : RC3                                                          //// 
.................... ////        : RC4                                                          //// 
.................... ////        : RC5                                                          //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////  YAZAN: Remzi ÞAHÝNOÐLU                                               //// 
.................... ////  TARÝH: 05.05.2011                                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //******************** yapýlacak iþlemler 
.................... // motorlar adým iþlemlerini tamamladýktan sonra geri bildirim yapýlmalý 
.................... // tx ucundan pc ye veri gönderilmeli 
.................... // 3 pic için a deðiþkenini eproma yüklenmeli - eproma veri yazma iþlemi 10ms gecikme ile oldugundan devre yapýldýktan sonra denemeli 
....................  
.................... #if defined(__PCH__) 
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
.................... #list 
....................  
.................... #include <MATH.h>  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
008F0:  MOVFF  AA,E0
008F4:  MOVFF  A9,DF
008F8:  MOVFF  A8,DE
008FC:  MOVFF  A7,DD
00900:  CLRF   xE4
00902:  CLRF   xE3
00904:  CLRF   xE2
00906:  CLRF   xE1
00908:  RCALL  087A
0090A:  BC    090E
0090C:  BNZ   0918
....................       return(0.0); 
0090E:  CLRF   00
00910:  CLRF   01
00912:  CLRF   02
00914:  CLRF   03
00916:  BRA    09F8
....................  
....................    y=x; 
00918:  MOVFF  AA,AE
0091C:  MOVFF  A9,AD
00920:  MOVFF  A8,AC
00924:  MOVFF  A7,AB
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
00928:  CLRF   xB4
0092A:  MOVLW  AB
0092C:  MOVWF  xB3
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
0092E:  MOVFF  B3,FE9
00932:  MOVFF  B4,FEA
00936:  MOVF   FEF,W
00938:  CLRF   xB8
0093A:  MOVWF  xB7
0093C:  MOVLW  7F
0093E:  ADDWF  xB7,F
00940:  MOVLW  00
00942:  ADDWFC xB8,F
00944:  BCF    FD8.0
00946:  RRCF   xB8,W
00948:  RRCF   xB7,W
0094A:  MOVFF  B4,FEA
0094E:  MOVFF  B3,FE9
00952:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
00954:  MOVFF  AE,B2
00958:  MOVFF  AD,B1
0095C:  MOVFF  AC,B0
00960:  MOVFF  AB,AF
....................       y+=(x/y); 
00964:  MOVFF  AA,E0
00968:  MOVFF  A9,DF
0096C:  MOVFF  A8,DE
00970:  MOVFF  A7,DD
00974:  MOVFF  AE,E4
00978:  MOVFF  AD,E3
0097C:  MOVFF  AC,E2
00980:  MOVFF  AB,E1
00984:  RCALL  0720
00986:  BCF    FD8.1
00988:  MOVFF  AE,E4
0098C:  MOVFF  AD,E3
00990:  MOVFF  AC,E2
00994:  MOVFF  AB,E1
00998:  MOVFF  03,E8
0099C:  MOVFF  02,E7
009A0:  MOVFF  01,E6
009A4:  MOVFF  00,E5
009A8:  RCALL  04B6
009AA:  MOVFF  03,AE
009AE:  MOVFF  02,AD
009B2:  MOVFF  01,AC
009B6:  MOVFF  00,AB
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
009BA:  MOVFF  B3,FE9
009BE:  MOVFF  B4,FEA
009C2:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
009C4:  MOVFF  B2,E0
009C8:  MOVFF  B1,DF
009CC:  MOVFF  B0,DE
009D0:  MOVFF  AF,DD
009D4:  MOVFF  AE,E4
009D8:  MOVFF  AD,E3
009DC:  MOVFF  AC,E2
009E0:  MOVFF  AB,E1
009E4:  RCALL  087A
009E6:  BNZ   0954
....................  
....................    return(res); 
009E8:  MOVFF  AF,00
009EC:  MOVFF  B0,01
009F0:  MOVFF  B1,02
009F4:  MOVFF  B2,03
.................... } 
009F8:  RETLW  00
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
*
00FAE:  CLRF   xBE
00FB0:  CLRF   xBD
00FB2:  CLRF   xBC
00FB4:  MOVLW  7F
00FB6:  MOVWF  xBB
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
00FB8:  MOVLW  7E
00FBA:  MOVWF  xC5
00FBC:  MOVLW  80
00FBE:  MOVWF  xC6
00FC0:  CLRF   xC7
00FC2:  CLRF   xC8
00FC4:  MOVLW  7A
00FC6:  MOVWF  xC9
00FC8:  MOVLW  2A
00FCA:  MOVWF  xCA
00FCC:  MOVLW  AA
00FCE:  MOVWF  xCB
00FD0:  MOVLW  AB
00FD2:  MOVWF  xCC
00FD4:  MOVLW  75
00FD6:  MOVWF  xCD
00FD8:  MOVLW  B6
00FDA:  MOVWF  xCE
00FDC:  MOVLW  0B
00FDE:  MOVWF  xCF
00FE0:  MOVLW  61
00FE2:  MOVWF  xD0
00FE4:  MOVLW  6F
00FE6:  MOVWF  xD1
00FE8:  MOVLW  50
00FEA:  MOVWF  xD2
00FEC:  MOVLW  0D
00FEE:  MOVWF  xD3
00FF0:  MOVLW  01
00FF2:  MOVWF  xD4
00FF4:  MOVLW  69
00FF6:  MOVWF  xD5
00FF8:  MOVLW  93
00FFA:  MOVWF  xD6
00FFC:  MOVLW  F2
00FFE:  MOVWF  xD7
01000:  MOVLW  7E
01002:  MOVWF  xD8
01004:  MOVLW  62
01006:  MOVWF  xD9
01008:  MOVLW  0F
0100A:  MOVWF  xDA
0100C:  MOVLW  76
0100E:  MOVWF  xDB
01010:  MOVLW  AE
01012:  MOVWF  xDC
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
01014:  MOVFF  B2,E0
01018:  MOVFF  B1,DF
0101C:  MOVFF  B0,DE
01020:  MOVFF  AF,DD
01024:  CLRF   xE4
01026:  CLRF   xE3
01028:  CLRF   xE2
0102A:  CLRF   xE1
0102C:  RCALL  087A
0102E:  BNC   1036
01030:  MOVF   xB0,W
01032:  XORLW  80
01034:  MOVWF  xB0
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
01036:  MOVFF  B2,E0
0103A:  MOVFF  B1,DF
0103E:  MOVFF  B0,DE
01042:  MOVFF  AF,DD
01046:  MOVLW  DB
01048:  MOVWF  xE4
0104A:  MOVLW  0F
0104C:  MOVWF  xE3
0104E:  MOVLW  49
01050:  MOVWF  xE2
01052:  MOVLW  7F
01054:  MOVWF  xE1
01056:  CALL   0720
0105A:  MOVFF  03,E0
0105E:  MOVFF  02,DF
01062:  MOVFF  01,DE
01066:  MOVFF  00,DD
0106A:  BRA    0F3C
0106C:  MOVFF  01,BF
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
01070:  MOVFF  B2,E0
01074:  MOVFF  B1,DF
01078:  MOVFF  B0,DE
0107C:  MOVFF  AF,DD
01080:  MOVLW  DB
01082:  MOVWF  xE4
01084:  MOVLW  0F
01086:  MOVWF  xE3
01088:  MOVLW  49
0108A:  MOVWF  xE2
0108C:  MOVLW  7F
0108E:  MOVWF  xE1
01090:  CALL   0720
01094:  MOVFF  00,DD
01098:  MOVFF  01,DE
0109C:  MOVFF  02,DF
010A0:  MOVFF  03,E0
010A4:  CLRF   xE2
010A6:  MOVFF  BF,E1
010AA:  BRA    0F76
010AC:  BSF    FD8.1
010AE:  MOVFF  E0,E4
010B2:  MOVFF  DF,E3
010B6:  MOVFF  DE,E2
010BA:  MOVFF  DD,E1
010BE:  MOVFF  03,E8
010C2:  MOVFF  02,E7
010C6:  MOVFF  01,E6
010CA:  MOVFF  00,E5
010CE:  CALL   04B6
010D2:  MOVFF  03,C4
010D6:  MOVFF  02,C3
010DA:  MOVFF  01,C2
010DE:  MOVFF  00,C1
....................    quad = quad % 4;                    // quadrant (0 to 3) 
010E2:  MOVLW  03
010E4:  ANDWF  xBF,F
....................  
....................    if (quad == 0 || quad == 2) 
010E6:  MOVF   xBF,F
010E8:  BZ    10F0
010EA:  MOVF   xBF,W
010EC:  SUBLW  02
010EE:  BNZ   1126
....................       t = frac * PI_DIV_BY_TWO; 
010F0:  MOVFF  C4,E4
010F4:  MOVFF  C3,E3
010F8:  MOVFF  C2,E2
010FC:  MOVFF  C1,E1
01100:  MOVLW  DB
01102:  MOVWF  xE8
01104:  MOVLW  0F
01106:  MOVWF  xE7
01108:  MOVLW  49
0110A:  MOVWF  xE6
0110C:  MOVLW  7F
0110E:  MOVWF  xE5
01110:  CALL   03C4
01114:  MOVFF  03,BA
01118:  MOVFF  02,B9
0111C:  MOVFF  01,B8
01120:  MOVFF  00,B7
....................    else if (quad == 1) 
01124:  BRA    11F4
01126:  DECFSZ xBF,W
01128:  BRA    1190
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0112A:  BSF    FD8.1
0112C:  CLRF   xE4
0112E:  CLRF   xE3
01130:  CLRF   xE2
01132:  MOVLW  7F
01134:  MOVWF  xE1
01136:  MOVFF  C4,E8
0113A:  MOVFF  C3,E7
0113E:  MOVFF  C2,E6
01142:  MOVFF  C1,E5
01146:  CALL   04B6
0114A:  MOVFF  00,DD
0114E:  MOVFF  01,DE
01152:  MOVFF  02,DF
01156:  MOVFF  03,E0
0115A:  MOVFF  03,E4
0115E:  MOVFF  02,E3
01162:  MOVFF  01,E2
01166:  MOVFF  00,E1
0116A:  MOVLW  DB
0116C:  MOVWF  xE8
0116E:  MOVLW  0F
01170:  MOVWF  xE7
01172:  MOVLW  49
01174:  MOVWF  xE6
01176:  MOVLW  7F
01178:  MOVWF  xE5
0117A:  CALL   03C4
0117E:  MOVFF  03,BA
01182:  MOVFF  02,B9
01186:  MOVFF  01,B8
0118A:  MOVFF  00,B7
....................    else // should be 3 
0118E:  BRA    11F4
....................       t = (frac-1) * PI_DIV_BY_TWO; 
01190:  BSF    FD8.1
01192:  MOVFF  C4,E4
01196:  MOVFF  C3,E3
0119A:  MOVFF  C2,E2
0119E:  MOVFF  C1,E1
011A2:  CLRF   xE8
011A4:  CLRF   xE7
011A6:  CLRF   xE6
011A8:  MOVLW  7F
011AA:  MOVWF  xE5
011AC:  CALL   04B6
011B0:  MOVFF  00,DD
011B4:  MOVFF  01,DE
011B8:  MOVFF  02,DF
011BC:  MOVFF  03,E0
011C0:  MOVFF  03,E4
011C4:  MOVFF  02,E3
011C8:  MOVFF  01,E2
011CC:  MOVFF  00,E1
011D0:  MOVLW  DB
011D2:  MOVWF  xE8
011D4:  MOVLW  0F
011D6:  MOVWF  xE7
011D8:  MOVLW  49
011DA:  MOVWF  xE6
011DC:  MOVLW  7F
011DE:  MOVWF  xE5
011E0:  CALL   03C4
011E4:  MOVFF  03,BA
011E8:  MOVFF  02,B9
011EC:  MOVFF  01,B8
011F0:  MOVFF  00,B7
....................  
....................    y = 1.0; 
011F4:  CLRF   xB6
011F6:  CLRF   xB5
011F8:  CLRF   xB4
011FA:  MOVLW  7F
011FC:  MOVWF  xB3
....................    t = t * t; 
011FE:  MOVFF  BA,E4
01202:  MOVFF  B9,E3
01206:  MOVFF  B8,E2
0120A:  MOVFF  B7,E1
0120E:  MOVFF  BA,E8
01212:  MOVFF  B9,E7
01216:  MOVFF  B8,E6
0121A:  MOVFF  B7,E5
0121E:  CALL   03C4
01222:  MOVFF  03,BA
01226:  MOVFF  02,B9
0122A:  MOVFF  01,B8
0122E:  MOVFF  00,B7
....................    for (i = 0; i <= 5; i++) 
01232:  CLRF   xC0
01234:  MOVF   xC0,W
01236:  SUBLW  05
01238:  BNC   12FE
....................    { 
....................       t2 = t2 * t; 
0123A:  MOVFF  BE,E4
0123E:  MOVFF  BD,E3
01242:  MOVFF  BC,E2
01246:  MOVFF  BB,E1
0124A:  MOVFF  BA,E8
0124E:  MOVFF  B9,E7
01252:  MOVFF  B8,E6
01256:  MOVFF  B7,E5
0125A:  CALL   03C4
0125E:  MOVFF  03,BE
01262:  MOVFF  02,BD
01266:  MOVFF  01,BC
0126A:  MOVFF  00,BB
....................       y = y + p[i] * t2; 
0126E:  MOVF   xC0,W
01270:  MULLW  04
01272:  MOVF   FF3,W
01274:  CLRF   03
01276:  ADDLW  C5
01278:  MOVWF  FE9
0127A:  MOVLW  00
0127C:  ADDWFC 03,W
0127E:  MOVWF  FEA
01280:  MOVFF  FEF,DD
01284:  MOVFF  FEC,DE
01288:  MOVFF  FEC,DF
0128C:  MOVFF  FEC,E0
01290:  MOVFF  E0,E4
01294:  MOVFF  DF,E3
01298:  MOVFF  DE,E2
0129C:  MOVFF  DD,E1
012A0:  MOVFF  BE,E8
012A4:  MOVFF  BD,E7
012A8:  MOVFF  BC,E6
012AC:  MOVFF  BB,E5
012B0:  CALL   03C4
012B4:  MOVFF  FEA,DE
012B8:  MOVFF  FE9,DD
012BC:  BCF    FD8.1
012BE:  MOVFF  B6,E4
012C2:  MOVFF  B5,E3
012C6:  MOVFF  B4,E2
012CA:  MOVFF  B3,E1
012CE:  MOVFF  03,E8
012D2:  MOVFF  02,E7
012D6:  MOVFF  01,E6
012DA:  MOVFF  00,E5
012DE:  CALL   04B6
012E2:  MOVFF  DE,FEA
012E6:  MOVFF  DD,FE9
012EA:  MOVFF  03,B6
012EE:  MOVFF  02,B5
012F2:  MOVFF  01,B4
012F6:  MOVFF  00,B3
....................    } 
012FA:  INCF   xC0,F
012FC:  BRA    1234
....................  
....................    if (quad == 2 || quad == 1) 
012FE:  MOVF   xBF,W
01300:  SUBLW  02
01302:  BZ    1308
01304:  DECFSZ xBF,W
01306:  BRA    130E
....................       y = -y;  // correct sign 
01308:  MOVF   xB4,W
0130A:  XORLW  80
0130C:  MOVWF  xB4
....................  
....................    return (y); 
0130E:  MOVFF  B3,00
01312:  MOVFF  B4,01
01316:  MOVFF  B5,02
0131A:  MOVFF  B6,03
.................... } 
0131E:  RETLW  00
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
01320:  BSF    FD8.1
01322:  MOVFF  AA,E4
01326:  MOVFF  A9,E3
0132A:  MOVFF  A8,E2
0132E:  MOVFF  A7,E1
01332:  MOVLW  DB
01334:  MOVWF  xE8
01336:  MOVLW  0F
01338:  MOVWF  xE7
0133A:  MOVLW  49
0133C:  MOVWF  xE6
0133E:  MOVLW  7F
01340:  MOVWF  xE5
01342:  CALL   04B6
01346:  MOVFF  00,AB
0134A:  MOVFF  01,AC
0134E:  MOVFF  02,AD
01352:  MOVFF  03,AE
01356:  MOVFF  03,B2
0135A:  MOVFF  02,B1
0135E:  MOVFF  01,B0
01362:  MOVFF  00,AF
01366:  RCALL  0FAE
.................... } 
01368:  RETLW  00
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
*
009FA:  BCF    xB7.0
....................    flag = 0; 
009FC:  BCF    xB7.1
....................    y = x; 
009FE:  MOVFF  AA,AE
00A02:  MOVFF  A9,AD
00A06:  MOVFF  A8,AC
00A0A:  MOVFF  A7,AB
....................  
....................    if (x < 0) 
00A0E:  MOVFF  AA,E0
00A12:  MOVFF  A9,DF
00A16:  MOVFF  A8,DE
00A1A:  MOVFF  A7,DD
00A1E:  CLRF   xE4
00A20:  CLRF   xE3
00A22:  CLRF   xE2
00A24:  CLRF   xE1
00A26:  RCALL  087A
00A28:  BNC   0A32
....................    { 
....................       s = 1; 
00A2A:  BSF    xB7.0
....................       y = -y; 
00A2C:  MOVF   xAC,W
00A2E:  XORLW  80
00A30:  MOVWF  xAC
....................    } 
....................  
....................    if (y > 1.0) 
00A32:  CLRF   xE0
00A34:  CLRF   xDF
00A36:  CLRF   xDE
00A38:  MOVLW  7F
00A3A:  MOVWF  xDD
00A3C:  MOVFF  AE,E4
00A40:  MOVFF  AD,E3
00A44:  MOVFF  AC,E2
00A48:  MOVFF  AB,E1
00A4C:  RCALL  087A
00A4E:  BNC   0A7E
....................    { 
....................       y = 1.0/y; 
00A50:  CLRF   xE0
00A52:  CLRF   xDF
00A54:  CLRF   xDE
00A56:  MOVLW  7F
00A58:  MOVWF  xDD
00A5A:  MOVFF  AE,E4
00A5E:  MOVFF  AD,E3
00A62:  MOVFF  AC,E2
00A66:  MOVFF  AB,E1
00A6A:  RCALL  0720
00A6C:  MOVFF  03,AE
00A70:  MOVFF  02,AD
00A74:  MOVFF  01,AC
00A78:  MOVFF  00,AB
....................       flag = 1; 
00A7C:  BSF    xB7.1
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
00A7E:  MOVLW  0A
00A80:  MOVWF  xE4
00A82:  MOVLW  89
00A84:  MOVWF  xE3
00A86:  MOVLW  34
00A88:  MOVWF  xE2
00A8A:  MOVLW  7C
00A8C:  MOVWF  xE1
00A8E:  MOVFF  AE,E8
00A92:  MOVFF  AD,E7
00A96:  MOVFF  AC,E6
00A9A:  MOVFF  AB,E5
00A9E:  RCALL  03C4
00AA0:  MOVFF  00,B8
00AA4:  MOVFF  01,B9
00AA8:  MOVFF  02,BA
00AAC:  MOVFF  03,BB
00AB0:  MOVFF  03,E4
00AB4:  MOVFF  02,E3
00AB8:  MOVFF  01,E2
00ABC:  MOVFF  00,E1
00AC0:  MOVFF  AE,E8
00AC4:  MOVFF  AD,E7
00AC8:  MOVFF  AC,E6
00ACC:  MOVFF  AB,E5
00AD0:  RCALL  03C4
00AD2:  MOVFF  00,B8
00AD6:  MOVFF  01,B9
00ADA:  MOVFF  02,BA
00ADE:  MOVFF  03,BB
00AE2:  BCF    FD8.1
00AE4:  MOVFF  03,E4
00AE8:  MOVFF  02,E3
00AEC:  MOVFF  01,E2
00AF0:  MOVFF  00,E1
00AF4:  MOVLW  7C
00AF6:  MOVWF  xE8
00AF8:  MOVLW  79
00AFA:  MOVWF  xE7
00AFC:  MOVLW  35
00AFE:  MOVWF  xE6
00B00:  MOVLW  81
00B02:  MOVWF  xE5
00B04:  RCALL  04B6
00B06:  MOVFF  03,B2
00B0A:  MOVFF  02,B1
00B0E:  MOVFF  01,B0
00B12:  MOVFF  00,AF
....................    res = res*y*y + pat[2]; 
00B16:  MOVFF  B2,E4
00B1A:  MOVFF  B1,E3
00B1E:  MOVFF  B0,E2
00B22:  MOVFF  AF,E1
00B26:  MOVFF  AE,E8
00B2A:  MOVFF  AD,E7
00B2E:  MOVFF  AC,E6
00B32:  MOVFF  AB,E5
00B36:  RCALL  03C4
00B38:  MOVFF  00,B8
00B3C:  MOVFF  01,B9
00B40:  MOVFF  02,BA
00B44:  MOVFF  03,BB
00B48:  MOVFF  03,E4
00B4C:  MOVFF  02,E3
00B50:  MOVFF  01,E2
00B54:  MOVFF  00,E1
00B58:  MOVFF  AE,E8
00B5C:  MOVFF  AD,E7
00B60:  MOVFF  AC,E6
00B64:  MOVFF  AB,E5
00B68:  RCALL  03C4
00B6A:  MOVFF  00,B8
00B6E:  MOVFF  01,B9
00B72:  MOVFF  02,BA
00B76:  MOVFF  03,BB
00B7A:  BCF    FD8.1
00B7C:  MOVFF  03,E4
00B80:  MOVFF  02,E3
00B84:  MOVFF  01,E2
00B88:  MOVFF  00,E1
00B8C:  MOVLW  3F
00B8E:  MOVWF  xE8
00B90:  MOVLW  02
00B92:  MOVWF  xE7
00B94:  MOVLW  33
00B96:  MOVWF  xE6
00B98:  MOVLW  83
00B9A:  MOVWF  xE5
00B9C:  RCALL  04B6
00B9E:  MOVFF  03,B2
00BA2:  MOVFF  02,B1
00BA6:  MOVFF  01,B0
00BAA:  MOVFF  00,AF
....................    res = res*y*y + pat[3]; 
00BAE:  MOVFF  B2,E4
00BB2:  MOVFF  B1,E3
00BB6:  MOVFF  B0,E2
00BBA:  MOVFF  AF,E1
00BBE:  MOVFF  AE,E8
00BC2:  MOVFF  AD,E7
00BC6:  MOVFF  AC,E6
00BCA:  MOVFF  AB,E5
00BCE:  CALL   03C4
00BD2:  MOVFF  00,B8
00BD6:  MOVFF  01,B9
00BDA:  MOVFF  02,BA
00BDE:  MOVFF  03,BB
00BE2:  MOVFF  03,E4
00BE6:  MOVFF  02,E3
00BEA:  MOVFF  01,E2
00BEE:  MOVFF  00,E1
00BF2:  MOVFF  AE,E8
00BF6:  MOVFF  AD,E7
00BFA:  MOVFF  AC,E6
00BFE:  MOVFF  AB,E5
00C02:  CALL   03C4
00C06:  MOVFF  00,B8
00C0A:  MOVFF  01,B9
00C0E:  MOVFF  02,BA
00C12:  MOVFF  03,BB
00C16:  BCF    FD8.1
00C18:  MOVFF  03,E4
00C1C:  MOVFF  02,E3
00C20:  MOVFF  01,E2
00C24:  MOVFF  00,E1
00C28:  MOVLW  33
00C2A:  MOVWF  xE8
00C2C:  MOVLW  8C
00C2E:  MOVWF  xE7
00C30:  MOVLW  1E
00C32:  MOVWF  xE6
00C34:  MOVLW  83
00C36:  MOVWF  xE5
00C38:  RCALL  04B6
00C3A:  MOVFF  03,B2
00C3E:  MOVFF  02,B1
00C42:  MOVFF  01,B0
00C46:  MOVFF  00,AF
....................  
....................    r = qat[0]*y*y + qat[1]; 
00C4A:  CLRF   xE4
00C4C:  CLRF   xE3
00C4E:  CLRF   xE2
00C50:  MOVLW  7F
00C52:  MOVWF  xE1
00C54:  MOVFF  AE,E8
00C58:  MOVFF  AD,E7
00C5C:  MOVFF  AC,E6
00C60:  MOVFF  AB,E5
00C64:  CALL   03C4
00C68:  MOVFF  00,B8
00C6C:  MOVFF  01,B9
00C70:  MOVFF  02,BA
00C74:  MOVFF  03,BB
00C78:  MOVFF  03,E4
00C7C:  MOVFF  02,E3
00C80:  MOVFF  01,E2
00C84:  MOVFF  00,E1
00C88:  MOVFF  AE,E8
00C8C:  MOVFF  AD,E7
00C90:  MOVFF  AC,E6
00C94:  MOVFF  AB,E5
00C98:  CALL   03C4
00C9C:  MOVFF  00,B8
00CA0:  MOVFF  01,B9
00CA4:  MOVFF  02,BA
00CA8:  MOVFF  03,BB
00CAC:  BCF    FD8.1
00CAE:  MOVFF  03,E4
00CB2:  MOVFF  02,E3
00CB6:  MOVFF  01,E2
00CBA:  MOVFF  00,E1
00CBE:  MOVLW  1B
00CC0:  MOVWF  xE8
00CC2:  MOVLW  E4
00CC4:  MOVWF  xE7
00CC6:  MOVLW  35
00CC8:  MOVWF  xE6
00CCA:  MOVLW  82
00CCC:  MOVWF  xE5
00CCE:  CALL   04B6
00CD2:  MOVFF  03,B6
00CD6:  MOVFF  02,B5
00CDA:  MOVFF  01,B4
00CDE:  MOVFF  00,B3
....................    r = r*y*y + qat[2]; 
00CE2:  MOVFF  B6,E4
00CE6:  MOVFF  B5,E3
00CEA:  MOVFF  B4,E2
00CEE:  MOVFF  B3,E1
00CF2:  MOVFF  AE,E8
00CF6:  MOVFF  AD,E7
00CFA:  MOVFF  AC,E6
00CFE:  MOVFF  AB,E5
00D02:  CALL   03C4
00D06:  MOVFF  00,B8
00D0A:  MOVFF  01,B9
00D0E:  MOVFF  02,BA
00D12:  MOVFF  03,BB
00D16:  MOVFF  03,E4
00D1A:  MOVFF  02,E3
00D1E:  MOVFF  01,E2
00D22:  MOVFF  00,E1
00D26:  MOVFF  AE,E8
00D2A:  MOVFF  AD,E7
00D2E:  MOVFF  AC,E6
00D32:  MOVFF  AB,E5
00D36:  CALL   03C4
00D3A:  MOVFF  00,B8
00D3E:  MOVFF  01,B9
00D42:  MOVFF  02,BA
00D46:  MOVFF  03,BB
00D4A:  BCF    FD8.1
00D4C:  MOVFF  03,E4
00D50:  MOVFF  02,E3
00D54:  MOVFF  01,E2
00D58:  MOVFF  00,E1
00D5C:  MOVLW  A4
00D5E:  MOVWF  xE8
00D60:  MOVLW  DB
00D62:  MOVWF  xE7
00D64:  MOVLW  67
00D66:  MOVWF  xE6
00D68:  MOVLW  83
00D6A:  MOVWF  xE5
00D6C:  CALL   04B6
00D70:  MOVFF  03,B6
00D74:  MOVFF  02,B5
00D78:  MOVFF  01,B4
00D7C:  MOVFF  00,B3
....................    r = r*y*y + qat[3]; 
00D80:  MOVFF  B6,E4
00D84:  MOVFF  B5,E3
00D88:  MOVFF  B4,E2
00D8C:  MOVFF  B3,E1
00D90:  MOVFF  AE,E8
00D94:  MOVFF  AD,E7
00D98:  MOVFF  AC,E6
00D9C:  MOVFF  AB,E5
00DA0:  CALL   03C4
00DA4:  MOVFF  00,B8
00DA8:  MOVFF  01,B9
00DAC:  MOVFF  02,BA
00DB0:  MOVFF  03,BB
00DB4:  MOVFF  03,E4
00DB8:  MOVFF  02,E3
00DBC:  MOVFF  01,E2
00DC0:  MOVFF  00,E1
00DC4:  MOVFF  AE,E8
00DC8:  MOVFF  AD,E7
00DCC:  MOVFF  AC,E6
00DD0:  MOVFF  AB,E5
00DD4:  CALL   03C4
00DD8:  MOVFF  00,B8
00DDC:  MOVFF  01,B9
00DE0:  MOVFF  02,BA
00DE4:  MOVFF  03,BB
00DE8:  BCF    FD8.1
00DEA:  MOVFF  03,E4
00DEE:  MOVFF  02,E3
00DF2:  MOVFF  01,E2
00DF6:  MOVFF  00,E1
00DFA:  MOVLW  33
00DFC:  MOVWF  xE8
00DFE:  MOVLW  8C
00E00:  MOVWF  xE7
00E02:  MOVLW  1E
00E04:  MOVWF  xE6
00E06:  MOVLW  83
00E08:  MOVWF  xE5
00E0A:  CALL   04B6
00E0E:  MOVFF  03,B6
00E12:  MOVFF  02,B5
00E16:  MOVFF  01,B4
00E1A:  MOVFF  00,B3
....................  
....................    res = y*res/r; 
00E1E:  MOVFF  AE,E4
00E22:  MOVFF  AD,E3
00E26:  MOVFF  AC,E2
00E2A:  MOVFF  AB,E1
00E2E:  MOVFF  B2,E8
00E32:  MOVFF  B1,E7
00E36:  MOVFF  B0,E6
00E3A:  MOVFF  AF,E5
00E3E:  CALL   03C4
00E42:  MOVFF  00,B8
00E46:  MOVFF  01,B9
00E4A:  MOVFF  02,BA
00E4E:  MOVFF  03,BB
00E52:  MOVFF  03,E0
00E56:  MOVFF  02,DF
00E5A:  MOVFF  01,DE
00E5E:  MOVFF  00,DD
00E62:  MOVFF  B6,E4
00E66:  MOVFF  B5,E3
00E6A:  MOVFF  B4,E2
00E6E:  MOVFF  B3,E1
00E72:  RCALL  0720
00E74:  MOVFF  03,B2
00E78:  MOVFF  02,B1
00E7C:  MOVFF  01,B0
00E80:  MOVFF  00,AF
....................  
....................  
....................    if (flag)                              // for |x| > 1 
00E84:  BTFSS  xB7.1
00E86:  BRA    0EBE
....................       res = PI_DIV_BY_TWO - res; 
00E88:  BSF    FD8.1
00E8A:  MOVLW  DB
00E8C:  MOVWF  xE4
00E8E:  MOVLW  0F
00E90:  MOVWF  xE3
00E92:  MOVLW  49
00E94:  MOVWF  xE2
00E96:  MOVLW  7F
00E98:  MOVWF  xE1
00E9A:  MOVFF  B2,E8
00E9E:  MOVFF  B1,E7
00EA2:  MOVFF  B0,E6
00EA6:  MOVFF  AF,E5
00EAA:  CALL   04B6
00EAE:  MOVFF  03,B2
00EB2:  MOVFF  02,B1
00EB6:  MOVFF  01,B0
00EBA:  MOVFF  00,AF
....................    if (s) 
00EBE:  BTFSS  xB7.0
00EC0:  BRA    0EC8
....................       res = -res; 
00EC2:  MOVF   xB0,W
00EC4:  XORLW  80
00EC6:  MOVWF  xB0
....................  
....................    return(res); 
00EC8:  MOVFF  AF,00
00ECC:  MOVFF  B0,01
00ED0:  MOVFF  B1,02
00ED4:  MOVFF  B2,03
.................... } 
00ED8:  RETLW  00
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #use delay(clock=4000000) 
*
0016E:  CLRF   FEA
00170:  MOVLW  B1
00172:  MOVWF  FE9
00174:  MOVF   FEF,W
00176:  BZ    0194
00178:  MOVLW  01
0017A:  MOVWF  01
0017C:  CLRF   00
0017E:  DECFSZ 00,F
00180:  BRA    017E
00182:  DECFSZ 01,F
00184:  BRA    017C
00186:  MOVLW  4A
00188:  MOVWF  00
0018A:  DECFSZ 00,F
0018C:  BRA    018A
0018E:  BRA    0190
00190:  DECFSZ FEF,F
00192:  BRA    0178
00194:  RETLW  00
.................... #fuses XT, NOWDT, NOPROTECT, NOLVP, NOBROWNOUT, NOPUT, NOWRT, NODEBUG, NOCPD 
.................... #use rs232 (baud=9600, xmit=PIN_C6, rcv=PIN_c7, parity=N, stop=1) 
.................... #include <stdlib.h>                    // bu sýralama dogru rs232 den altta olmalý 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <input.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1() { 
....................    char digit; 
....................  
....................    digit = getc(); 
....................  
....................    putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1(); 
....................    lo = gethex1(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           putc(c); 
....................           putc(' '); 
....................           putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
.................... #if !defined(__PCD__) 
.................... signed int8 get_int() { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   get_string(s, 5); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... signed int16 get_int() { 
....................   char s[5]; 
....................   signed int16 i; 
....................  
....................   get_string(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... signed int16 get_long() { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   get_string(s, 7); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... signed int32 get_long() { 
....................   char s[7]; 
....................   signed int32 l; 
....................  
....................   get_string(s, 10); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... float get_float() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
.................... #define use_portb_lcd TRUE             // lcd bilgisi için port byi kullanýyoruz 
.................... #include <LCD416.c>                    // lcd için gerekecek fonksiyonlarýn bulunduðu dosya lcd416.c 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD420.C                               //// 
.................... ////            Driver for common 4x20 LCD modules                      //// 
.................... ////                                                                    //// 
.................... ////  lcd_init()   Must be called before any other function.            //// 
.................... ////                                                                    //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.      //// 
.................... ////                     The following have special meaning:            //// 
.................... ////                      \f  Clear display                             //// 
.................... ////                      \n  Go to start of second line                //// 
.................... ////                      \b  Move back one position                    //// 
.................... ////                                                                    //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)     //// 
.................... ////                                                                    //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD          //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                        free licence                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     B0  enable 
.................... //     B1  rs 
.................... //     B2  rw 
.................... //     B4  D4 
.................... //     B5  D5 
.................... //     B6  D6 
.................... //     B7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC B3 is not used. 
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
.................... #locate lcd = getenv("SFR:PORTB")                        // This puts the entire structure 
....................                                      // on to port B  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x28 | (lcd_type << 2), 0x0C, 1, 6}; 
....................                              // 0x28 = 5x8 dot matrix 
....................                              // 0x0C = display kapalý ve imlec alt çizgi gözükmez ve yanýp sönmez 
....................                              // 1 lcd yi temizle 
....................                              // 6 imleci saða kaydýr 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
.................... BYTE lcdline; 
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................  
....................       set_tris_b(LCD_READ); 
*
001AE:  MOVLW  F0
001B0:  MOVWF  F93
....................       lcd.rw = 1; 
001B2:  BSF    F81.2
....................       delay_cycles(1); 
001B4:  NOP   
....................       lcd.enable = 1; 
001B6:  BSF    F81.0
....................       delay_cycles(1); 
001B8:  NOP   
....................       high = lcd.data; 
001BA:  SWAPF  F81,W
001BC:  ANDLW  0F
001BE:  MOVWF  xB7
....................       lcd.enable = 0; 
001C0:  BCF    F81.0
....................       delay_cycles(1); 
001C2:  NOP   
....................       lcd.enable = 1; 
001C4:  BSF    F81.0
....................       delay_us(1); 
001C6:  NOP   
....................       low = lcd.data; 
001C8:  SWAPF  F81,W
001CA:  ANDLW  0F
001CC:  MOVWF  xB6
....................       lcd.enable = 0; 
001CE:  BCF    F81.0
....................       set_tris_b(LCD_WRITE); 
001D0:  MOVLW  00
001D2:  MOVWF  F93
....................       return( (high<<4) | low); 
001D4:  SWAPF  xB7,W
001D6:  MOVWF  00
001D8:  MOVLW  F0
001DA:  ANDWF  00,F
001DC:  MOVF   00,W
001DE:  IORWF  xB6,W
001E0:  MOVWF  01
.................... } 
001E2:  GOTO   01EA (RETURN)
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
00196:  SWAPF  xB7,W
00198:  ANDLW  F0
0019A:  MOVWF  00
0019C:  MOVLW  0F
0019E:  ANDWF  F81,W
001A0:  IORWF  00,W
001A2:  MOVWF  F81
....................       delay_cycles(1); 
001A4:  NOP   
....................       lcd.enable = 1; 
001A6:  BSF    F81.0
....................       delay_us(2); 
001A8:  BRA    01AA
....................       lcd.enable = 0; 
001AA:  BCF    F81.0
.................... } 
001AC:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
*
001E6:  BCF    F81.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
001E8:  BRA    01AE
001EA:  MOVFF  01,B6
001EE:  BTFSC  01.7
001F0:  BRA    01E8
....................       lcd.rs = address; 
001F2:  BTFSS  xB4.0
001F4:  BCF    F81.1
001F6:  BTFSC  xB4.0
001F8:  BSF    F81.1
....................       delay_cycles(1); 
001FA:  NOP   
....................       lcd.rw = 0; 
001FC:  BCF    F81.2
....................       delay_cycles(1); 
001FE:  NOP   
....................       lcd.enable = 0; 
00200:  BCF    F81.0
....................       lcd_send_nibble(n >> 4); 
00202:  SWAPF  xB5,W
00204:  MOVWF  xB6
00206:  MOVLW  0F
00208:  ANDWF  xB6,F
0020A:  MOVFF  B6,B7
0020E:  RCALL  0196
....................       lcd_send_nibble(n & 0xf); 
00210:  MOVF   xB5,W
00212:  ANDLW  0F
00214:  MOVWF  xB6
00216:  MOVWF  xB7
00218:  RCALL  0196
.................... } 
0021A:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................  
....................     set_tris_b(LCD_WRITE); 
0021C:  MOVLW  00
0021E:  MOVWF  F93
....................     lcd.rs = 0; 
00220:  BCF    F81.1
....................     lcd.rw = 0; 
00222:  BCF    F81.2
....................     lcd.enable = 0; 
00224:  BCF    F81.0
....................     delay_ms(15); 
00226:  MOVLW  0F
00228:  MOVWF  xB1
0022A:  RCALL  016E
....................     for(i=1;i<=3;++i) { 
0022C:  MOVLW  01
0022E:  MOVWF  xA3
00230:  MOVF   xA3,W
00232:  SUBLW  03
00234:  BNC   0246
....................        lcd_send_nibble(3); 
00236:  MOVLW  03
00238:  MOVWF  xB7
0023A:  RCALL  0196
....................        delay_ms(5); 
0023C:  MOVLW  05
0023E:  MOVWF  xB1
00240:  RCALL  016E
....................     } 
00242:  INCF   xA3,F
00244:  BRA    0230
....................     lcd_send_nibble(2); 
00246:  MOVLW  02
00248:  MOVWF  xB7
0024A:  RCALL  0196
....................     for(i=0;i<=3;++i) 
0024C:  CLRF   xA3
0024E:  MOVF   xA3,W
00250:  SUBLW  03
00252:  BNC   0266
....................        lcd_send_byte(0, LCD_INIT_STRING[i]); 
00254:  CLRF   03
00256:  MOVF   xA3,W
00258:  RCALL  0004
0025A:  MOVWF  xA4
0025C:  CLRF   xB4
0025E:  MOVWF  xB5
00260:  RCALL  01E6
00262:  INCF   xA3,F
00264:  BRA    024E
.................... } 
00266:  GOTO   4554 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    switch(y) { 
0026A:  MOVLW  01
0026C:  SUBWF  xB2,W
0026E:  ADDLW  FC
00270:  BC    0290
00272:  ADDLW  04
00274:  GOTO   02A0
....................      case 1 : address=0x80;break;   // 1. satýr ilk adresi 
00278:  MOVLW  80
0027A:  MOVWF  xB3
0027C:  BRA    0290
....................      case 2 : address=0xc0;break;   // 2. satýr ilk adresi 
0027E:  MOVLW  C0
00280:  MOVWF  xB3
00282:  BRA    0290
....................      case 3 : address=0x90;break;   // 3. satýr ilk adresi 0x94 yerine 0x90 olmalý 
00284:  MOVLW  90
00286:  MOVWF  xB3
00288:  BRA    0290
....................      case 4 : address=0xd0;break;   // 4. satýr ilk adresi 0xd4 yerine 0xd0 olmalý 
0028A:  MOVLW  D0
0028C:  MOVWF  xB3
0028E:  BRA    0290
....................    } 
....................    address+=x-1; 
00290:  MOVLW  01
00292:  SUBWF  xB1,W
00294:  ADDWF  xB3,F
....................    lcd_send_byte(0,address); 
00296:  CLRF   xB4
00298:  MOVFF  B3,B5
0029C:  RCALL  01E6
.................... } 
0029E:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
*
002C2:  MOVF   xB0,W
002C4:  XORLW  0C
002C6:  BZ    02D2
002C8:  XORLW  06
002CA:  BZ    02E6
002CC:  XORLW  02
002CE:  BZ    02F4
002D0:  BRA    02FE
....................      case '\f'   : lcd_send_byte(0,1); 
002D2:  CLRF   xB4
002D4:  MOVLW  01
002D6:  MOVWF  xB5
002D8:  RCALL  01E6
....................                    lcdline=1; 
002DA:  MOVLW  01
002DC:  MOVWF  0A
....................                    delay_ms(2); 
002DE:  MOVLW  02
002E0:  MOVWF  xB1
002E2:  RCALL  016E
....................                                            break; 
002E4:  BRA    030A
....................      case '\n'   : lcd_gotoxy(1,++lcdline);        break; 
002E6:  INCF   0A,F
002E8:  MOVLW  01
002EA:  MOVWF  xB1
002EC:  MOVFF  0A,B2
002F0:  RCALL  026A
002F2:  BRA    030A
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
002F4:  CLRF   xB4
002F6:  MOVLW  10
002F8:  MOVWF  xB5
002FA:  RCALL  01E6
002FC:  BRA    030A
....................      default     : lcd_send_byte(1,c);     break; 
002FE:  MOVLW  01
00300:  MOVWF  xB4
00302:  MOVFF  B0,B5
00306:  RCALL  01E6
00308:  BRA    030A
....................    } 
.................... } 
0030A:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#device PIC18F4620 
....................  
.................... int degisim=1, degisim_motor=0, lcd_ekran=1, i=1; 
.................... // motor adým ve zaman deðiþkenler 
.................... signed long long mA_step=0, mB_step=0, mC_step=0, mA_step_old=0, mB_step_old=0, mC_step_old=0; 
.................... signed long long ma=0, mb=0, mc=0; 
.................... long long ta=0,tb=0,tc=0; 
.................... // inverse kinematic deðiþkenleri 
.................... float e,f,re,rf,x0,y0,z0,x02,x03,y1,y01,y02,y03,z02,z03,theta1,theta2,theta3,a,b,d,yj,zj; 
.................... float hassasiyet=1,tahvil_orani=0; 
....................  
.................... //********** write eeprom - float ********************************************// 
.................... void ee_write_float(unsigned int addr , float *floatptr) 
.................... { 
.................... unsigned char edata; 
.................... unsigned char I; 
....................     for(I=0;I<4;I++){ 
*
0032C:  CLRF   xA7
0032E:  MOVF   xA7,W
00330:  SUBLW  03
00332:  BNC   0380
....................       edata = *((unsigned char *)floatptr+I); 
00334:  MOVF   xA7,W
00336:  ADDWF  xA4,W
00338:  MOVWF  01
0033A:  MOVLW  00
0033C:  ADDWFC xA5,W
0033E:  MOVFF  01,FE9
00342:  MOVWF  FEA
00344:  MOVFF  FEF,A6
....................       write_eeprom(addr+I,edata); 
00348:  MOVF   xA7,W
0034A:  ADDWF  xA3,W
0034C:  MOVWF  xA8
0034E:  CLRF   FAA
00350:  MOVFF  A8,FA9
00354:  MOVFF  A6,FA8
00358:  BCF    FA6.6
0035A:  BCF    FA6.7
0035C:  BSF    FA6.2
0035E:  MOVF   FF2,W
00360:  MOVWF  00
00362:  BCF    FF2.7
00364:  MOVLB  F
00366:  MOVLW  55
00368:  MOVWF  FA7
0036A:  MOVLW  AA
0036C:  MOVWF  FA7
0036E:  BSF    FA6.1
00370:  BTFSC  FA6.1
00372:  BRA    0370
00374:  BCF    FA6.2
00376:  MOVF   00,W
00378:  IORWF  FF2,F
....................    } 
0037A:  MOVLB  0
0037C:  INCF   xA7,F
0037E:  BRA    032E
.................... } 
00380:  RETLW  00
.................... //********** read eeprom - float *********************************************// 
.................... void ee_read_float(unsigned int addr , float *floatptr) 
.................... { 
.................... unsigned char edata; 
.................... unsigned char I; 
....................    for(I=0;I<4;I++){ 
00382:  CLRF   xA7
00384:  MOVF   xA7,W
00386:  SUBLW  03
00388:  BNC   03C2
....................       edata=read_eeprom(I+addr);    
0038A:  MOVF   xA3,W
0038C:  ADDWF  xA7,W
0038E:  MOVWF  xA8
00390:  MOVFF  FF2,A9
00394:  BCF    FF2.7
00396:  CLRF   FAA
00398:  MOVFF  A8,FA9
0039C:  BCF    FA6.6
0039E:  BCF    FA6.7
003A0:  BSF    FA6.0
003A2:  MOVF   FA8,W
003A4:  BTFSC  xA9.7
003A6:  BSF    FF2.7
003A8:  MOVWF  xA6
....................         *((unsigned char *)floatptr+I) = edata; 
003AA:  MOVF   xA7,W
003AC:  ADDWF  xA4,W
003AE:  MOVWF  01
003B0:  MOVLW  00
003B2:  ADDWFC xA5,W
003B4:  MOVFF  01,FE9
003B8:  MOVWF  FEA
003BA:  MOVFF  A6,FEF
....................    } 
003BE:  INCF   xA7,F
003C0:  BRA    0384
.................... } 
003C2:  RETLW  00
.................... //********** çalýþma uzayý dýþýnda bir nokta girildiðinde ********************// 
.................... void no_point() 
.................... { 
....................    lcd_send_byte(0,0x01);     // lcd ekraný temzile 
*
00EDA:  CLRF   xB4
00EDC:  MOVLW  01
00EDE:  MOVWF  xB5
00EE0:  CALL   01E6
....................    lcd_gotoxy(1,1); 
00EE4:  MOVLW  01
00EE6:  MOVWF  xB1
00EE8:  MOVWF  xB2
00EEA:  CALL   026A
....................    printf(lcd_putc, "hata: calisma"); 
00EEE:  MOVLW  18
00EF0:  MOVWF  FF6
00EF2:  MOVLW  00
00EF4:  MOVWF  FF7
00EF6:  CALL   030C
....................    lcd_gotoxy(1,2); 
00EFA:  MOVLW  01
00EFC:  MOVWF  xB1
00EFE:  MOVLW  02
00F00:  MOVWF  xB2
00F02:  CALL   026A
....................    printf(lcd_putc, "uzayi icinde bir"); 
00F06:  MOVLW  26
00F08:  MOVWF  FF6
00F0A:  MOVLW  00
00F0C:  MOVWF  FF7
00F0E:  CALL   030C
....................    lcd_gotoxy(1,3); 
00F12:  MOVLW  01
00F14:  MOVWF  xB1
00F16:  MOVLW  03
00F18:  MOVWF  xB2
00F1A:  CALL   026A
....................    printf(lcd_putc, "nokta giriniz"); 
00F1E:  MOVLW  38
00F20:  MOVWF  FF6
00F22:  MOVLW  00
00F24:  MOVWF  FF7
00F26:  CALL   030C
....................    delay_ms(2000); 
00F2A:  MOVLW  08
00F2C:  MOVWF  xA3
00F2E:  MOVLW  FA
00F30:  MOVWF  xB1
00F32:  CALL   016E
00F36:  DECFSZ xA3,F
00F38:  BRA    0F2E
.................... } 
00F3A:  RETLW  00
.................... //******* kollarýn açý deðerlerini hesaplama: theta1, theta2, theta3 *********// 
.................... void hesapla_aci() 
.................... { 
....................    //********** theta 1 ******************************************************// 
....................    y1 = -0.5 * 0.57735 * f;                  // f/2 * tg 30 
*
0136A:  MOVLW  36
0136C:  MOVWF  xE4
0136E:  MOVLW  CD
01370:  MOVWF  xE3
01372:  MOVLW  93
01374:  MOVWF  xE2
01376:  MOVLW  7D
01378:  MOVWF  xE1
0137A:  MOVFF  46,E8
0137E:  MOVFF  45,E7
01382:  MOVFF  44,E6
01386:  MOVFF  43,E5
0138A:  CALL   03C4
0138E:  MOVFF  03,66
01392:  MOVFF  02,65
01396:  MOVFF  01,64
0139A:  MOVFF  00,63
....................    y01 = y0 -0.5 * 0.57735 * e;              // shift center to edge 
0139E:  MOVLW  36
013A0:  MOVWF  xE4
013A2:  MOVLW  CD
013A4:  MOVWF  xE3
013A6:  MOVLW  13
013A8:  MOVWF  xE2
013AA:  MOVLW  7D
013AC:  MOVWF  xE1
013AE:  MOVFF  42,E8
013B2:  MOVFF  41,E7
013B6:  MOVFF  40,E6
013BA:  MOVFF  3F,E5
013BE:  CALL   03C4
013C2:  BSF    FD8.1
013C4:  MOVFF  56,E4
013C8:  MOVFF  55,E3
013CC:  MOVFF  54,E2
013D0:  MOVFF  53,E1
013D4:  MOVFF  03,E8
013D8:  MOVFF  02,E7
013DC:  MOVFF  01,E6
013E0:  MOVFF  00,E5
013E4:  CALL   04B6
013E8:  MOVFF  03,6A
013EC:  MOVFF  02,69
013F0:  MOVFF  01,68
013F4:  MOVFF  00,67
....................  
....................    // z = a + b*y 
....................    a = (x0*x0 + y01*y01 + z0*z0 +rf*rf - re*re - y1*y1)/(2*z0); 
013F8:  MOVFF  52,E4
013FC:  MOVFF  51,E3
01400:  MOVFF  50,E2
01404:  MOVFF  4F,E1
01408:  MOVFF  52,E8
0140C:  MOVFF  51,E7
01410:  MOVFF  50,E6
01414:  MOVFF  4F,E5
01418:  CALL   03C4
0141C:  MOVFF  00,A3
01420:  MOVFF  01,A4
01424:  MOVFF  02,A5
01428:  MOVFF  03,A6
0142C:  MOVFF  6A,E4
01430:  MOVFF  69,E3
01434:  MOVFF  68,E2
01438:  MOVFF  67,E1
0143C:  MOVFF  6A,E8
01440:  MOVFF  69,E7
01444:  MOVFF  68,E6
01448:  MOVFF  67,E5
0144C:  CALL   03C4
01450:  BCF    FD8.1
01452:  MOVFF  A6,E4
01456:  MOVFF  A5,E3
0145A:  MOVFF  A4,E2
0145E:  MOVFF  A3,E1
01462:  MOVFF  03,E8
01466:  MOVFF  02,E7
0146A:  MOVFF  01,E6
0146E:  MOVFF  00,E5
01472:  CALL   04B6
01476:  MOVFF  00,A3
0147A:  MOVFF  01,A4
0147E:  MOVFF  02,A5
01482:  MOVFF  03,A6
01486:  MOVFF  5A,E4
0148A:  MOVFF  59,E3
0148E:  MOVFF  58,E2
01492:  MOVFF  57,E1
01496:  MOVFF  5A,E8
0149A:  MOVFF  59,E7
0149E:  MOVFF  58,E6
014A2:  MOVFF  57,E5
014A6:  CALL   03C4
014AA:  BCF    FD8.1
014AC:  MOVFF  A6,E4
014B0:  MOVFF  A5,E3
014B4:  MOVFF  A4,E2
014B8:  MOVFF  A3,E1
014BC:  MOVFF  03,E8
014C0:  MOVFF  02,E7
014C4:  MOVFF  01,E6
014C8:  MOVFF  00,E5
014CC:  CALL   04B6
014D0:  MOVFF  00,A3
014D4:  MOVFF  01,A4
014D8:  MOVFF  02,A5
014DC:  MOVFF  03,A6
014E0:  MOVFF  4E,E4
014E4:  MOVFF  4D,E3
014E8:  MOVFF  4C,E2
014EC:  MOVFF  4B,E1
014F0:  MOVFF  4E,E8
014F4:  MOVFF  4D,E7
014F8:  MOVFF  4C,E6
014FC:  MOVFF  4B,E5
01500:  CALL   03C4
01504:  BCF    FD8.1
01506:  MOVFF  A6,E4
0150A:  MOVFF  A5,E3
0150E:  MOVFF  A4,E2
01512:  MOVFF  A3,E1
01516:  MOVFF  03,E8
0151A:  MOVFF  02,E7
0151E:  MOVFF  01,E6
01522:  MOVFF  00,E5
01526:  CALL   04B6
0152A:  MOVFF  00,A3
0152E:  MOVFF  01,A4
01532:  MOVFF  02,A5
01536:  MOVFF  03,A6
0153A:  MOVFF  4A,E4
0153E:  MOVFF  49,E3
01542:  MOVFF  48,E2
01546:  MOVFF  47,E1
0154A:  MOVFF  4A,E8
0154E:  MOVFF  49,E7
01552:  MOVFF  48,E6
01556:  MOVFF  47,E5
0155A:  CALL   03C4
0155E:  BSF    FD8.1
01560:  MOVFF  A6,E4
01564:  MOVFF  A5,E3
01568:  MOVFF  A4,E2
0156C:  MOVFF  A3,E1
01570:  MOVFF  03,E8
01574:  MOVFF  02,E7
01578:  MOVFF  01,E6
0157C:  MOVFF  00,E5
01580:  CALL   04B6
01584:  MOVFF  00,A3
01588:  MOVFF  01,A4
0158C:  MOVFF  02,A5
01590:  MOVFF  03,A6
01594:  MOVFF  66,E4
01598:  MOVFF  65,E3
0159C:  MOVFF  64,E2
015A0:  MOVFF  63,E1
015A4:  MOVFF  66,E8
015A8:  MOVFF  65,E7
015AC:  MOVFF  64,E6
015B0:  MOVFF  63,E5
015B4:  CALL   03C4
015B8:  BSF    FD8.1
015BA:  MOVFF  A6,E4
015BE:  MOVFF  A5,E3
015C2:  MOVFF  A4,E2
015C6:  MOVFF  A3,E1
015CA:  MOVFF  03,E8
015CE:  MOVFF  02,E7
015D2:  MOVFF  01,E6
015D6:  MOVFF  00,E5
015DA:  CALL   04B6
015DE:  MOVFF  00,A3
015E2:  MOVFF  01,A4
015E6:  MOVFF  02,A5
015EA:  MOVFF  03,A6
015EE:  CLRF   xE4
015F0:  CLRF   xE3
015F2:  CLRF   xE2
015F4:  MOVLW  80
015F6:  MOVWF  xE1
015F8:  MOVFF  5A,E8
015FC:  MOVFF  59,E7
01600:  MOVFF  58,E6
01604:  MOVFF  57,E5
01608:  CALL   03C4
0160C:  MOVFF  A6,E0
01610:  MOVFF  A5,DF
01614:  MOVFF  A4,DE
01618:  MOVFF  A3,DD
0161C:  MOVFF  03,E4
01620:  MOVFF  02,E3
01624:  MOVFF  01,E2
01628:  MOVFF  00,E1
0162C:  CALL   0720
01630:  MOVFF  03,8A
01634:  MOVFF  02,89
01638:  MOVFF  01,88
0163C:  MOVFF  00,87
....................    b = (y1-y01)/z0; 
01640:  BSF    FD8.1
01642:  MOVFF  66,E4
01646:  MOVFF  65,E3
0164A:  MOVFF  64,E2
0164E:  MOVFF  63,E1
01652:  MOVFF  6A,E8
01656:  MOVFF  69,E7
0165A:  MOVFF  68,E6
0165E:  MOVFF  67,E5
01662:  CALL   04B6
01666:  MOVFF  00,A3
0166A:  MOVFF  01,A4
0166E:  MOVFF  02,A5
01672:  MOVFF  03,A6
01676:  MOVFF  03,E0
0167A:  MOVFF  02,DF
0167E:  MOVFF  01,DE
01682:  MOVFF  00,DD
01686:  MOVFF  5A,E4
0168A:  MOVFF  59,E3
0168E:  MOVFF  58,E2
01692:  MOVFF  57,E1
01696:  CALL   0720
0169A:  MOVFF  03,8E
0169E:  MOVFF  02,8D
016A2:  MOVFF  01,8C
016A6:  MOVFF  00,8B
....................  
....................    // discriminant 
....................    d = -(a+b*y1)*(a+b*y1)+rf*(b*b*rf+rf); 
016AA:  MOVFF  8E,E4
016AE:  MOVFF  8D,E3
016B2:  MOVFF  8C,E2
016B6:  MOVFF  8B,E1
016BA:  MOVFF  66,E8
016BE:  MOVFF  65,E7
016C2:  MOVFF  64,E6
016C6:  MOVFF  63,E5
016CA:  CALL   03C4
016CE:  BCF    FD8.1
016D0:  MOVFF  8A,E4
016D4:  MOVFF  89,E3
016D8:  MOVFF  88,E2
016DC:  MOVFF  87,E1
016E0:  MOVFF  03,E8
016E4:  MOVFF  02,E7
016E8:  MOVFF  01,E6
016EC:  MOVFF  00,E5
016F0:  CALL   04B6
016F4:  MOVFF  00,A3
016F8:  MOVF   01,W
016FA:  XORLW  80
016FC:  MOVWF  xA4
016FE:  MOVFF  02,A5
01702:  MOVFF  03,A6
01706:  MOVFF  8E,E4
0170A:  MOVFF  8D,E3
0170E:  MOVFF  8C,E2
01712:  MOVFF  8B,E1
01716:  MOVFF  66,E8
0171A:  MOVFF  65,E7
0171E:  MOVFF  64,E6
01722:  MOVFF  63,E5
01726:  CALL   03C4
0172A:  BCF    FD8.1
0172C:  MOVFF  8A,E4
01730:  MOVFF  89,E3
01734:  MOVFF  88,E2
01738:  MOVFF  87,E1
0173C:  MOVFF  03,E8
01740:  MOVFF  02,E7
01744:  MOVFF  01,E6
01748:  MOVFF  00,E5
0174C:  CALL   04B6
01750:  MOVFF  A6,E4
01754:  MOVFF  A5,E3
01758:  MOVFF  A4,E2
0175C:  MOVFF  A3,E1
01760:  MOVFF  03,E8
01764:  MOVFF  02,E7
01768:  MOVFF  01,E6
0176C:  MOVFF  00,E5
01770:  CALL   03C4
01774:  MOVFF  00,A3
01778:  MOVFF  01,A4
0177C:  MOVFF  02,A5
01780:  MOVFF  03,A6
01784:  MOVFF  8E,E4
01788:  MOVFF  8D,E3
0178C:  MOVFF  8C,E2
01790:  MOVFF  8B,E1
01794:  MOVFF  8E,E8
01798:  MOVFF  8D,E7
0179C:  MOVFF  8C,E6
017A0:  MOVFF  8B,E5
017A4:  CALL   03C4
017A8:  MOVFF  00,A7
017AC:  MOVFF  01,A8
017B0:  MOVFF  02,A9
017B4:  MOVFF  03,AA
017B8:  MOVFF  03,E4
017BC:  MOVFF  02,E3
017C0:  MOVFF  01,E2
017C4:  MOVFF  00,E1
017C8:  MOVFF  4E,E8
017CC:  MOVFF  4D,E7
017D0:  MOVFF  4C,E6
017D4:  MOVFF  4B,E5
017D8:  CALL   03C4
017DC:  MOVFF  00,A7
017E0:  MOVFF  01,A8
017E4:  MOVFF  02,A9
017E8:  MOVFF  03,AA
017EC:  BCF    FD8.1
017EE:  MOVFF  03,E4
017F2:  MOVFF  02,E3
017F6:  MOVFF  01,E2
017FA:  MOVFF  00,E1
017FE:  MOVFF  4E,E8
01802:  MOVFF  4D,E7
01806:  MOVFF  4C,E6
0180A:  MOVFF  4B,E5
0180E:  CALL   04B6
01812:  MOVFF  4E,E4
01816:  MOVFF  4D,E3
0181A:  MOVFF  4C,E2
0181E:  MOVFF  4B,E1
01822:  MOVFF  03,E8
01826:  MOVFF  02,E7
0182A:  MOVFF  01,E6
0182E:  MOVFF  00,E5
01832:  CALL   03C4
01836:  BCF    FD8.1
01838:  MOVFF  A6,E4
0183C:  MOVFF  A5,E3
01840:  MOVFF  A4,E2
01844:  MOVFF  A3,E1
01848:  MOVFF  03,E8
0184C:  MOVFF  02,E7
01850:  MOVFF  01,E6
01854:  MOVFF  00,E5
01858:  CALL   04B6
0185C:  MOVFF  03,92
01860:  MOVFF  02,91
01864:  MOVFF  01,90
01868:  MOVFF  00,8F
....................    if (d > 0) 
0186C:  CLRF   xE0
0186E:  CLRF   xDF
01870:  CLRF   xDE
01872:  CLRF   xDD
01874:  MOVFF  92,E4
01878:  MOVFF  91,E3
0187C:  MOVFF  90,E2
01880:  MOVFF  8F,E1
01884:  CALL   087A
01888:  BTFSS  FD8.0
0188A:  BRA    1B9A
....................    { 
....................       yj = (y1 - a*b - sqrt(d))/(b*b + 1);  // choosing outer point 
0188C:  MOVFF  8A,E4
01890:  MOVFF  89,E3
01894:  MOVFF  88,E2
01898:  MOVFF  87,E1
0189C:  MOVFF  8E,E8
018A0:  MOVFF  8D,E7
018A4:  MOVFF  8C,E6
018A8:  MOVFF  8B,E5
018AC:  CALL   03C4
018B0:  BSF    FD8.1
018B2:  MOVFF  66,E4
018B6:  MOVFF  65,E3
018BA:  MOVFF  64,E2
018BE:  MOVFF  63,E1
018C2:  MOVFF  03,E8
018C6:  MOVFF  02,E7
018CA:  MOVFF  01,E6
018CE:  MOVFF  00,E5
018D2:  CALL   04B6
018D6:  MOVFF  00,A3
018DA:  MOVFF  01,A4
018DE:  MOVFF  02,A5
018E2:  MOVFF  03,A6
018E6:  MOVFF  92,AA
018EA:  MOVFF  91,A9
018EE:  MOVFF  90,A8
018F2:  MOVFF  8F,A7
018F6:  CALL   08F0
018FA:  MOVFF  FEA,A8
018FE:  MOVFF  FE9,A7
01902:  BSF    FD8.1
01904:  MOVFF  A6,E4
01908:  MOVFF  A5,E3
0190C:  MOVFF  A4,E2
01910:  MOVFF  A3,E1
01914:  MOVFF  03,E8
01918:  MOVFF  02,E7
0191C:  MOVFF  01,E6
01920:  MOVFF  00,E5
01924:  CALL   04B6
01928:  MOVFF  A8,FEA
0192C:  MOVFF  A7,FE9
01930:  MOVFF  00,A3
01934:  MOVFF  01,A4
01938:  MOVFF  02,A5
0193C:  MOVFF  03,A6
01940:  MOVFF  8E,E4
01944:  MOVFF  8D,E3
01948:  MOVFF  8C,E2
0194C:  MOVFF  8B,E1
01950:  MOVFF  8E,E8
01954:  MOVFF  8D,E7
01958:  MOVFF  8C,E6
0195C:  MOVFF  8B,E5
01960:  CALL   03C4
01964:  MOVFF  00,A9
01968:  MOVFF  01,AA
0196C:  MOVFF  02,AB
01970:  MOVFF  03,AC
01974:  MOVFF  FEA,AE
01978:  MOVFF  FE9,AD
0197C:  BCF    FD8.1
0197E:  MOVFF  03,E4
01982:  MOVFF  02,E3
01986:  MOVFF  01,E2
0198A:  MOVFF  00,E1
0198E:  CLRF   xE8
01990:  CLRF   xE7
01992:  CLRF   xE6
01994:  MOVLW  7F
01996:  MOVWF  xE5
01998:  CALL   04B6
0199C:  MOVFF  AE,FEA
019A0:  MOVFF  AD,FE9
019A4:  MOVFF  A6,E0
019A8:  MOVFF  A5,DF
019AC:  MOVFF  A4,DE
019B0:  MOVFF  A3,DD
019B4:  MOVFF  03,E4
019B8:  MOVFF  02,E3
019BC:  MOVFF  01,E2
019C0:  MOVFF  00,E1
019C4:  CALL   0720
019C8:  MOVFF  03,96
019CC:  MOVFF  02,95
019D0:  MOVFF  01,94
019D4:  MOVFF  00,93
....................       zj = a + b*yj; 
019D8:  MOVFF  8E,E4
019DC:  MOVFF  8D,E3
019E0:  MOVFF  8C,E2
019E4:  MOVFF  8B,E1
019E8:  MOVFF  96,E8
019EC:  MOVFF  95,E7
019F0:  MOVFF  94,E6
019F4:  MOVFF  93,E5
019F8:  CALL   03C4
019FC:  BCF    FD8.1
019FE:  MOVFF  8A,E4
01A02:  MOVFF  89,E3
01A06:  MOVFF  88,E2
01A0A:  MOVFF  87,E1
01A0E:  MOVFF  03,E8
01A12:  MOVFF  02,E7
01A16:  MOVFF  01,E6
01A1A:  MOVFF  00,E5
01A1E:  CALL   04B6
01A22:  MOVFF  03,9A
01A26:  MOVFF  02,99
01A2A:  MOVFF  01,98
01A2E:  MOVFF  00,97
....................       theta1 = 180.0*atan(-zj/(y1 - yj))/pi + ((yj>y1)?180.0:0.0);   // yj, y1 den küçükse 180; degilse 0 deðerini çýkarýr 
01A32:  MOVFF  97,A3
01A36:  MOVF   x98,W
01A38:  XORLW  80
01A3A:  MOVWF  xA4
01A3C:  MOVFF  99,A5
01A40:  MOVFF  9A,A6
01A44:  BSF    FD8.1
01A46:  MOVFF  66,E4
01A4A:  MOVFF  65,E3
01A4E:  MOVFF  64,E2
01A52:  MOVFF  63,E1
01A56:  MOVFF  96,E8
01A5A:  MOVFF  95,E7
01A5E:  MOVFF  94,E6
01A62:  MOVFF  93,E5
01A66:  CALL   04B6
01A6A:  MOVFF  A6,E0
01A6E:  MOVFF  A5,DF
01A72:  MOVFF  A4,DE
01A76:  MOVFF  A3,DD
01A7A:  MOVFF  03,E4
01A7E:  MOVFF  02,E3
01A82:  MOVFF  01,E2
01A86:  MOVFF  00,E1
01A8A:  CALL   0720
01A8E:  MOVFF  00,A3
01A92:  MOVFF  01,A4
01A96:  MOVFF  02,A5
01A9A:  MOVFF  03,A6
01A9E:  MOVFF  03,AA
01AA2:  MOVFF  02,A9
01AA6:  MOVFF  01,A8
01AAA:  MOVFF  00,A7
01AAE:  CALL   09FA
01AB2:  CLRF   xE4
01AB4:  CLRF   xE3
01AB6:  MOVLW  34
01AB8:  MOVWF  xE2
01ABA:  MOVLW  86
01ABC:  MOVWF  xE1
01ABE:  MOVFF  03,E8
01AC2:  MOVFF  02,E7
01AC6:  MOVFF  01,E6
01ACA:  MOVFF  00,E5
01ACE:  CALL   03C4
01AD2:  MOVFF  00,A3
01AD6:  MOVFF  01,A4
01ADA:  MOVFF  02,A5
01ADE:  MOVFF  03,A6
01AE2:  MOVFF  03,E0
01AE6:  MOVFF  02,DF
01AEA:  MOVFF  01,DE
01AEE:  MOVFF  00,DD
01AF2:  MOVLW  DB
01AF4:  MOVWF  xE4
01AF6:  MOVLW  0F
01AF8:  MOVWF  xE3
01AFA:  MOVLW  49
01AFC:  MOVWF  xE2
01AFE:  MOVLW  80
01B00:  MOVWF  xE1
01B02:  CALL   0720
01B06:  MOVFF  00,A3
01B0A:  MOVFF  01,A4
01B0E:  MOVFF  02,A5
01B12:  MOVFF  03,A6
01B16:  MOVFF  66,E0
01B1A:  MOVFF  65,DF
01B1E:  MOVFF  64,DE
01B22:  MOVFF  63,DD
01B26:  MOVFF  96,E4
01B2A:  MOVFF  95,E3
01B2E:  MOVFF  94,E2
01B32:  MOVFF  93,E1
01B36:  CALL   087A
01B3A:  BNC   1B4A
01B3C:  MOVLW  86
01B3E:  MOVWF  00
01B40:  MOVLW  34
01B42:  MOVWF  01
01B44:  CLRF   02
01B46:  CLRF   03
01B48:  BRA    1B52
01B4A:  CLRF   00
01B4C:  CLRF   01
01B4E:  CLRF   02
01B50:  CLRF   03
01B52:  MOVFF  FEA,A8
01B56:  MOVFF  FE9,A7
01B5A:  BCF    FD8.1
01B5C:  MOVFF  A6,E4
01B60:  MOVFF  A5,E3
01B64:  MOVFF  A4,E2
01B68:  MOVFF  A3,E1
01B6C:  MOVFF  03,E8
01B70:  MOVFF  02,E7
01B74:  MOVFF  01,E6
01B78:  MOVFF  00,E5
01B7C:  CALL   04B6
01B80:  MOVFF  A8,FEA
01B84:  MOVFF  A7,FE9
01B88:  MOVFF  03,7E
01B8C:  MOVFF  02,7D
01B90:  MOVFF  01,7C
01B94:  MOVFF  00,7B
....................    } 
....................    else{no_point();} 
01B98:  BRA    1B9E
01B9A:  CALL   0EDA
....................  
....................    //********** theta 2 ******************************************************// 
....................    x02 = x0*cos(120*pi/180) + y0*sin(120*pi/180); 
01B9E:  MOVLW  92
01BA0:  MOVWF  xB2
01BA2:  MOVLW  0A
01BA4:  MOVWF  xB1
01BA6:  MOVLW  06
01BA8:  MOVWF  xB0
01BAA:  MOVLW  80
01BAC:  MOVWF  xAF
01BAE:  CALL   0FAE
01BB2:  MOVFF  52,E4
01BB6:  MOVFF  51,E3
01BBA:  MOVFF  50,E2
01BBE:  MOVFF  4F,E1
01BC2:  MOVFF  03,E8
01BC6:  MOVFF  02,E7
01BCA:  MOVFF  01,E6
01BCE:  MOVFF  00,E5
01BD2:  CALL   03C4
01BD6:  MOVFF  00,A3
01BDA:  MOVFF  01,A4
01BDE:  MOVFF  02,A5
01BE2:  MOVFF  03,A6
01BE6:  MOVLW  92
01BE8:  MOVWF  xAA
01BEA:  MOVLW  0A
01BEC:  MOVWF  xA9
01BEE:  MOVLW  06
01BF0:  MOVWF  xA8
01BF2:  MOVLW  80
01BF4:  MOVWF  xA7
01BF6:  CALL   1320
01BFA:  MOVFF  56,E4
01BFE:  MOVFF  55,E3
01C02:  MOVFF  54,E2
01C06:  MOVFF  53,E1
01C0A:  MOVFF  03,E8
01C0E:  MOVFF  02,E7
01C12:  MOVFF  01,E6
01C16:  MOVFF  00,E5
01C1A:  CALL   03C4
01C1E:  MOVFF  FEA,A8
01C22:  MOVFF  FE9,A7
01C26:  BCF    FD8.1
01C28:  MOVFF  A6,E4
01C2C:  MOVFF  A5,E3
01C30:  MOVFF  A4,E2
01C34:  MOVFF  A3,E1
01C38:  MOVFF  03,E8
01C3C:  MOVFF  02,E7
01C40:  MOVFF  01,E6
01C44:  MOVFF  00,E5
01C48:  CALL   04B6
01C4C:  MOVFF  A8,FEA
01C50:  MOVFF  A7,FE9
01C54:  MOVFF  03,5E
01C58:  MOVFF  02,5D
01C5C:  MOVFF  01,5C
01C60:  MOVFF  00,5B
....................    y02 = y0*cos(120*pi/180) - x0*sin(120*pi/180); 
01C64:  MOVLW  92
01C66:  MOVWF  xB2
01C68:  MOVLW  0A
01C6A:  MOVWF  xB1
01C6C:  MOVLW  06
01C6E:  MOVWF  xB0
01C70:  MOVLW  80
01C72:  MOVWF  xAF
01C74:  CALL   0FAE
01C78:  MOVFF  56,E4
01C7C:  MOVFF  55,E3
01C80:  MOVFF  54,E2
01C84:  MOVFF  53,E1
01C88:  MOVFF  03,E8
01C8C:  MOVFF  02,E7
01C90:  MOVFF  01,E6
01C94:  MOVFF  00,E5
01C98:  CALL   03C4
01C9C:  MOVFF  00,A3
01CA0:  MOVFF  01,A4
01CA4:  MOVFF  02,A5
01CA8:  MOVFF  03,A6
01CAC:  MOVLW  92
01CAE:  MOVWF  xAA
01CB0:  MOVLW  0A
01CB2:  MOVWF  xA9
01CB4:  MOVLW  06
01CB6:  MOVWF  xA8
01CB8:  MOVLW  80
01CBA:  MOVWF  xA7
01CBC:  CALL   1320
01CC0:  MOVFF  52,E4
01CC4:  MOVFF  51,E3
01CC8:  MOVFF  50,E2
01CCC:  MOVFF  4F,E1
01CD0:  MOVFF  03,E8
01CD4:  MOVFF  02,E7
01CD8:  MOVFF  01,E6
01CDC:  MOVFF  00,E5
01CE0:  CALL   03C4
01CE4:  MOVFF  FEA,A8
01CE8:  MOVFF  FE9,A7
01CEC:  BSF    FD8.1
01CEE:  MOVFF  A6,E4
01CF2:  MOVFF  A5,E3
01CF6:  MOVFF  A4,E2
01CFA:  MOVFF  A3,E1
01CFE:  MOVFF  03,E8
01D02:  MOVFF  02,E7
01D06:  MOVFF  01,E6
01D0A:  MOVFF  00,E5
01D0E:  CALL   04B6
01D12:  MOVFF  A8,FEA
01D16:  MOVFF  A7,FE9
01D1A:  MOVFF  03,6E
01D1E:  MOVFF  02,6D
01D22:  MOVFF  01,6C
01D26:  MOVFF  00,6B
....................    z02 = z0; 
01D2A:  MOVFF  5A,76
01D2E:  MOVFF  59,75
01D32:  MOVFF  58,74
01D36:  MOVFF  57,73
....................  
....................    //y1 = cos(120)*(-0.5 * 0.57735 * f); 
....................    y1 = -0.5 * 0.57735 * f;     // f/2 * tg 30 
01D3A:  MOVLW  36
01D3C:  MOVWF  xE4
01D3E:  MOVLW  CD
01D40:  MOVWF  xE3
01D42:  MOVLW  93
01D44:  MOVWF  xE2
01D46:  MOVLW  7D
01D48:  MOVWF  xE1
01D4A:  MOVFF  46,E8
01D4E:  MOVFF  45,E7
01D52:  MOVFF  44,E6
01D56:  MOVFF  43,E5
01D5A:  CALL   03C4
01D5E:  MOVFF  03,66
01D62:  MOVFF  02,65
01D66:  MOVFF  01,64
01D6A:  MOVFF  00,63
....................    y02 = y02 -0.5 * 0.57735 * e;    // shift center to edge 
01D6E:  MOVLW  36
01D70:  MOVWF  xE4
01D72:  MOVLW  CD
01D74:  MOVWF  xE3
01D76:  MOVLW  13
01D78:  MOVWF  xE2
01D7A:  MOVLW  7D
01D7C:  MOVWF  xE1
01D7E:  MOVFF  42,E8
01D82:  MOVFF  41,E7
01D86:  MOVFF  40,E6
01D8A:  MOVFF  3F,E5
01D8E:  CALL   03C4
01D92:  BSF    FD8.1
01D94:  MOVFF  6E,E4
01D98:  MOVFF  6D,E3
01D9C:  MOVFF  6C,E2
01DA0:  MOVFF  6B,E1
01DA4:  MOVFF  03,E8
01DA8:  MOVFF  02,E7
01DAC:  MOVFF  01,E6
01DB0:  MOVFF  00,E5
01DB4:  CALL   04B6
01DB8:  MOVFF  03,6E
01DBC:  MOVFF  02,6D
01DC0:  MOVFF  01,6C
01DC4:  MOVFF  00,6B
....................     
....................    // z = a + b*y 
....................    a = (x02*x02 + y02*y02 + z02*z02 +rf*rf - re*re - y1*y1)/(2*z02); 
01DC8:  MOVFF  5E,E4
01DCC:  MOVFF  5D,E3
01DD0:  MOVFF  5C,E2
01DD4:  MOVFF  5B,E1
01DD8:  MOVFF  5E,E8
01DDC:  MOVFF  5D,E7
01DE0:  MOVFF  5C,E6
01DE4:  MOVFF  5B,E5
01DE8:  CALL   03C4
01DEC:  MOVFF  00,A3
01DF0:  MOVFF  01,A4
01DF4:  MOVFF  02,A5
01DF8:  MOVFF  03,A6
01DFC:  MOVFF  6E,E4
01E00:  MOVFF  6D,E3
01E04:  MOVFF  6C,E2
01E08:  MOVFF  6B,E1
01E0C:  MOVFF  6E,E8
01E10:  MOVFF  6D,E7
01E14:  MOVFF  6C,E6
01E18:  MOVFF  6B,E5
01E1C:  CALL   03C4
01E20:  BCF    FD8.1
01E22:  MOVFF  A6,E4
01E26:  MOVFF  A5,E3
01E2A:  MOVFF  A4,E2
01E2E:  MOVFF  A3,E1
01E32:  MOVFF  03,E8
01E36:  MOVFF  02,E7
01E3A:  MOVFF  01,E6
01E3E:  MOVFF  00,E5
01E42:  CALL   04B6
01E46:  MOVFF  00,A3
01E4A:  MOVFF  01,A4
01E4E:  MOVFF  02,A5
01E52:  MOVFF  03,A6
01E56:  MOVFF  76,E4
01E5A:  MOVFF  75,E3
01E5E:  MOVFF  74,E2
01E62:  MOVFF  73,E1
01E66:  MOVFF  76,E8
01E6A:  MOVFF  75,E7
01E6E:  MOVFF  74,E6
01E72:  MOVFF  73,E5
01E76:  CALL   03C4
01E7A:  BCF    FD8.1
01E7C:  MOVFF  A6,E4
01E80:  MOVFF  A5,E3
01E84:  MOVFF  A4,E2
01E88:  MOVFF  A3,E1
01E8C:  MOVFF  03,E8
01E90:  MOVFF  02,E7
01E94:  MOVFF  01,E6
01E98:  MOVFF  00,E5
01E9C:  CALL   04B6
01EA0:  MOVFF  00,A3
01EA4:  MOVFF  01,A4
01EA8:  MOVFF  02,A5
01EAC:  MOVFF  03,A6
01EB0:  MOVFF  4E,E4
01EB4:  MOVFF  4D,E3
01EB8:  MOVFF  4C,E2
01EBC:  MOVFF  4B,E1
01EC0:  MOVFF  4E,E8
01EC4:  MOVFF  4D,E7
01EC8:  MOVFF  4C,E6
01ECC:  MOVFF  4B,E5
01ED0:  CALL   03C4
01ED4:  BCF    FD8.1
01ED6:  MOVFF  A6,E4
01EDA:  MOVFF  A5,E3
01EDE:  MOVFF  A4,E2
01EE2:  MOVFF  A3,E1
01EE6:  MOVFF  03,E8
01EEA:  MOVFF  02,E7
01EEE:  MOVFF  01,E6
01EF2:  MOVFF  00,E5
01EF6:  CALL   04B6
01EFA:  MOVFF  00,A3
01EFE:  MOVFF  01,A4
01F02:  MOVFF  02,A5
01F06:  MOVFF  03,A6
01F0A:  MOVFF  4A,E4
01F0E:  MOVFF  49,E3
01F12:  MOVFF  48,E2
01F16:  MOVFF  47,E1
01F1A:  MOVFF  4A,E8
01F1E:  MOVFF  49,E7
01F22:  MOVFF  48,E6
01F26:  MOVFF  47,E5
01F2A:  CALL   03C4
01F2E:  BSF    FD8.1
01F30:  MOVFF  A6,E4
01F34:  MOVFF  A5,E3
01F38:  MOVFF  A4,E2
01F3C:  MOVFF  A3,E1
01F40:  MOVFF  03,E8
01F44:  MOVFF  02,E7
01F48:  MOVFF  01,E6
01F4C:  MOVFF  00,E5
01F50:  CALL   04B6
01F54:  MOVFF  00,A3
01F58:  MOVFF  01,A4
01F5C:  MOVFF  02,A5
01F60:  MOVFF  03,A6
01F64:  MOVFF  66,E4
01F68:  MOVFF  65,E3
01F6C:  MOVFF  64,E2
01F70:  MOVFF  63,E1
01F74:  MOVFF  66,E8
01F78:  MOVFF  65,E7
01F7C:  MOVFF  64,E6
01F80:  MOVFF  63,E5
01F84:  CALL   03C4
01F88:  BSF    FD8.1
01F8A:  MOVFF  A6,E4
01F8E:  MOVFF  A5,E3
01F92:  MOVFF  A4,E2
01F96:  MOVFF  A3,E1
01F9A:  MOVFF  03,E8
01F9E:  MOVFF  02,E7
01FA2:  MOVFF  01,E6
01FA6:  MOVFF  00,E5
01FAA:  CALL   04B6
01FAE:  MOVFF  00,A3
01FB2:  MOVFF  01,A4
01FB6:  MOVFF  02,A5
01FBA:  MOVFF  03,A6
01FBE:  CLRF   xE4
01FC0:  CLRF   xE3
01FC2:  CLRF   xE2
01FC4:  MOVLW  80
01FC6:  MOVWF  xE1
01FC8:  MOVFF  76,E8
01FCC:  MOVFF  75,E7
01FD0:  MOVFF  74,E6
01FD4:  MOVFF  73,E5
01FD8:  CALL   03C4
01FDC:  MOVFF  A6,E0
01FE0:  MOVFF  A5,DF
01FE4:  MOVFF  A4,DE
01FE8:  MOVFF  A3,DD
01FEC:  MOVFF  03,E4
01FF0:  MOVFF  02,E3
01FF4:  MOVFF  01,E2
01FF8:  MOVFF  00,E1
01FFC:  CALL   0720
02000:  MOVFF  03,8A
02004:  MOVFF  02,89
02008:  MOVFF  01,88
0200C:  MOVFF  00,87
....................    b = (y1-y02)/z02; 
02010:  BSF    FD8.1
02012:  MOVFF  66,E4
02016:  MOVFF  65,E3
0201A:  MOVFF  64,E2
0201E:  MOVFF  63,E1
02022:  MOVFF  6E,E8
02026:  MOVFF  6D,E7
0202A:  MOVFF  6C,E6
0202E:  MOVFF  6B,E5
02032:  CALL   04B6
02036:  MOVFF  00,A3
0203A:  MOVFF  01,A4
0203E:  MOVFF  02,A5
02042:  MOVFF  03,A6
02046:  MOVFF  03,E0
0204A:  MOVFF  02,DF
0204E:  MOVFF  01,DE
02052:  MOVFF  00,DD
02056:  MOVFF  76,E4
0205A:  MOVFF  75,E3
0205E:  MOVFF  74,E2
02062:  MOVFF  73,E1
02066:  CALL   0720
0206A:  MOVFF  03,8E
0206E:  MOVFF  02,8D
02072:  MOVFF  01,8C
02076:  MOVFF  00,8B
....................     
....................    // discriminant 
....................    d = -(a+b*y1)*(a+b*y1)+rf*(b*b*rf+rf); 
0207A:  MOVFF  8E,E4
0207E:  MOVFF  8D,E3
02082:  MOVFF  8C,E2
02086:  MOVFF  8B,E1
0208A:  MOVFF  66,E8
0208E:  MOVFF  65,E7
02092:  MOVFF  64,E6
02096:  MOVFF  63,E5
0209A:  CALL   03C4
0209E:  BCF    FD8.1
020A0:  MOVFF  8A,E4
020A4:  MOVFF  89,E3
020A8:  MOVFF  88,E2
020AC:  MOVFF  87,E1
020B0:  MOVFF  03,E8
020B4:  MOVFF  02,E7
020B8:  MOVFF  01,E6
020BC:  MOVFF  00,E5
020C0:  CALL   04B6
020C4:  MOVFF  00,A3
020C8:  MOVF   01,W
020CA:  XORLW  80
020CC:  MOVWF  xA4
020CE:  MOVFF  02,A5
020D2:  MOVFF  03,A6
020D6:  MOVFF  8E,E4
020DA:  MOVFF  8D,E3
020DE:  MOVFF  8C,E2
020E2:  MOVFF  8B,E1
020E6:  MOVFF  66,E8
020EA:  MOVFF  65,E7
020EE:  MOVFF  64,E6
020F2:  MOVFF  63,E5
020F6:  CALL   03C4
020FA:  BCF    FD8.1
020FC:  MOVFF  8A,E4
02100:  MOVFF  89,E3
02104:  MOVFF  88,E2
02108:  MOVFF  87,E1
0210C:  MOVFF  03,E8
02110:  MOVFF  02,E7
02114:  MOVFF  01,E6
02118:  MOVFF  00,E5
0211C:  CALL   04B6
02120:  MOVFF  A6,E4
02124:  MOVFF  A5,E3
02128:  MOVFF  A4,E2
0212C:  MOVFF  A3,E1
02130:  MOVFF  03,E8
02134:  MOVFF  02,E7
02138:  MOVFF  01,E6
0213C:  MOVFF  00,E5
02140:  CALL   03C4
02144:  MOVFF  00,A3
02148:  MOVFF  01,A4
0214C:  MOVFF  02,A5
02150:  MOVFF  03,A6
02154:  MOVFF  8E,E4
02158:  MOVFF  8D,E3
0215C:  MOVFF  8C,E2
02160:  MOVFF  8B,E1
02164:  MOVFF  8E,E8
02168:  MOVFF  8D,E7
0216C:  MOVFF  8C,E6
02170:  MOVFF  8B,E5
02174:  CALL   03C4
02178:  MOVFF  00,A7
0217C:  MOVFF  01,A8
02180:  MOVFF  02,A9
02184:  MOVFF  03,AA
02188:  MOVFF  03,E4
0218C:  MOVFF  02,E3
02190:  MOVFF  01,E2
02194:  MOVFF  00,E1
02198:  MOVFF  4E,E8
0219C:  MOVFF  4D,E7
021A0:  MOVFF  4C,E6
021A4:  MOVFF  4B,E5
021A8:  CALL   03C4
021AC:  MOVFF  00,A7
021B0:  MOVFF  01,A8
021B4:  MOVFF  02,A9
021B8:  MOVFF  03,AA
021BC:  BCF    FD8.1
021BE:  MOVFF  03,E4
021C2:  MOVFF  02,E3
021C6:  MOVFF  01,E2
021CA:  MOVFF  00,E1
021CE:  MOVFF  4E,E8
021D2:  MOVFF  4D,E7
021D6:  MOVFF  4C,E6
021DA:  MOVFF  4B,E5
021DE:  CALL   04B6
021E2:  MOVFF  4E,E4
021E6:  MOVFF  4D,E3
021EA:  MOVFF  4C,E2
021EE:  MOVFF  4B,E1
021F2:  MOVFF  03,E8
021F6:  MOVFF  02,E7
021FA:  MOVFF  01,E6
021FE:  MOVFF  00,E5
02202:  CALL   03C4
02206:  BCF    FD8.1
02208:  MOVFF  A6,E4
0220C:  MOVFF  A5,E3
02210:  MOVFF  A4,E2
02214:  MOVFF  A3,E1
02218:  MOVFF  03,E8
0221C:  MOVFF  02,E7
02220:  MOVFF  01,E6
02224:  MOVFF  00,E5
02228:  CALL   04B6
0222C:  MOVFF  03,92
02230:  MOVFF  02,91
02234:  MOVFF  01,90
02238:  MOVFF  00,8F
....................    if (d > 0) 
0223C:  CLRF   xE0
0223E:  CLRF   xDF
02240:  CLRF   xDE
02242:  CLRF   xDD
02244:  MOVFF  92,E4
02248:  MOVFF  91,E3
0224C:  MOVFF  90,E2
02250:  MOVFF  8F,E1
02254:  CALL   087A
02258:  BTFSS  FD8.0
0225A:  BRA    256A
....................    { 
....................        yj = (y1 - a*b - sqrt(d))/(b*b + 1);  // choosing outer point 
0225C:  MOVFF  8A,E4
02260:  MOVFF  89,E3
02264:  MOVFF  88,E2
02268:  MOVFF  87,E1
0226C:  MOVFF  8E,E8
02270:  MOVFF  8D,E7
02274:  MOVFF  8C,E6
02278:  MOVFF  8B,E5
0227C:  CALL   03C4
02280:  BSF    FD8.1
02282:  MOVFF  66,E4
02286:  MOVFF  65,E3
0228A:  MOVFF  64,E2
0228E:  MOVFF  63,E1
02292:  MOVFF  03,E8
02296:  MOVFF  02,E7
0229A:  MOVFF  01,E6
0229E:  MOVFF  00,E5
022A2:  CALL   04B6
022A6:  MOVFF  00,A3
022AA:  MOVFF  01,A4
022AE:  MOVFF  02,A5
022B2:  MOVFF  03,A6
022B6:  MOVFF  92,AA
022BA:  MOVFF  91,A9
022BE:  MOVFF  90,A8
022C2:  MOVFF  8F,A7
022C6:  CALL   08F0
022CA:  MOVFF  FEA,A8
022CE:  MOVFF  FE9,A7
022D2:  BSF    FD8.1
022D4:  MOVFF  A6,E4
022D8:  MOVFF  A5,E3
022DC:  MOVFF  A4,E2
022E0:  MOVFF  A3,E1
022E4:  MOVFF  03,E8
022E8:  MOVFF  02,E7
022EC:  MOVFF  01,E6
022F0:  MOVFF  00,E5
022F4:  CALL   04B6
022F8:  MOVFF  A8,FEA
022FC:  MOVFF  A7,FE9
02300:  MOVFF  00,A3
02304:  MOVFF  01,A4
02308:  MOVFF  02,A5
0230C:  MOVFF  03,A6
02310:  MOVFF  8E,E4
02314:  MOVFF  8D,E3
02318:  MOVFF  8C,E2
0231C:  MOVFF  8B,E1
02320:  MOVFF  8E,E8
02324:  MOVFF  8D,E7
02328:  MOVFF  8C,E6
0232C:  MOVFF  8B,E5
02330:  CALL   03C4
02334:  MOVFF  00,A9
02338:  MOVFF  01,AA
0233C:  MOVFF  02,AB
02340:  MOVFF  03,AC
02344:  MOVFF  FEA,AE
02348:  MOVFF  FE9,AD
0234C:  BCF    FD8.1
0234E:  MOVFF  03,E4
02352:  MOVFF  02,E3
02356:  MOVFF  01,E2
0235A:  MOVFF  00,E1
0235E:  CLRF   xE8
02360:  CLRF   xE7
02362:  CLRF   xE6
02364:  MOVLW  7F
02366:  MOVWF  xE5
02368:  CALL   04B6
0236C:  MOVFF  AE,FEA
02370:  MOVFF  AD,FE9
02374:  MOVFF  A6,E0
02378:  MOVFF  A5,DF
0237C:  MOVFF  A4,DE
02380:  MOVFF  A3,DD
02384:  MOVFF  03,E4
02388:  MOVFF  02,E3
0238C:  MOVFF  01,E2
02390:  MOVFF  00,E1
02394:  CALL   0720
02398:  MOVFF  03,96
0239C:  MOVFF  02,95
023A0:  MOVFF  01,94
023A4:  MOVFF  00,93
....................        zj = a + b*yj; 
023A8:  MOVFF  8E,E4
023AC:  MOVFF  8D,E3
023B0:  MOVFF  8C,E2
023B4:  MOVFF  8B,E1
023B8:  MOVFF  96,E8
023BC:  MOVFF  95,E7
023C0:  MOVFF  94,E6
023C4:  MOVFF  93,E5
023C8:  CALL   03C4
023CC:  BCF    FD8.1
023CE:  MOVFF  8A,E4
023D2:  MOVFF  89,E3
023D6:  MOVFF  88,E2
023DA:  MOVFF  87,E1
023DE:  MOVFF  03,E8
023E2:  MOVFF  02,E7
023E6:  MOVFF  01,E6
023EA:  MOVFF  00,E5
023EE:  CALL   04B6
023F2:  MOVFF  03,9A
023F6:  MOVFF  02,99
023FA:  MOVFF  01,98
023FE:  MOVFF  00,97
....................        theta2 = 180.0*atan(-zj/(y1 - yj))/pi + ((yj>y1)?180.0:0.0);    //yj, y1 den küçükse 180; degilse 0 deðerini çýkarýr 
02402:  MOVFF  97,A3
02406:  MOVF   x98,W
02408:  XORLW  80
0240A:  MOVWF  xA4
0240C:  MOVFF  99,A5
02410:  MOVFF  9A,A6
02414:  BSF    FD8.1
02416:  MOVFF  66,E4
0241A:  MOVFF  65,E3
0241E:  MOVFF  64,E2
02422:  MOVFF  63,E1
02426:  MOVFF  96,E8
0242A:  MOVFF  95,E7
0242E:  MOVFF  94,E6
02432:  MOVFF  93,E5
02436:  CALL   04B6
0243A:  MOVFF  A6,E0
0243E:  MOVFF  A5,DF
02442:  MOVFF  A4,DE
02446:  MOVFF  A3,DD
0244A:  MOVFF  03,E4
0244E:  MOVFF  02,E3
02452:  MOVFF  01,E2
02456:  MOVFF  00,E1
0245A:  CALL   0720
0245E:  MOVFF  00,A3
02462:  MOVFF  01,A4
02466:  MOVFF  02,A5
0246A:  MOVFF  03,A6
0246E:  MOVFF  03,AA
02472:  MOVFF  02,A9
02476:  MOVFF  01,A8
0247A:  MOVFF  00,A7
0247E:  CALL   09FA
02482:  CLRF   xE4
02484:  CLRF   xE3
02486:  MOVLW  34
02488:  MOVWF  xE2
0248A:  MOVLW  86
0248C:  MOVWF  xE1
0248E:  MOVFF  03,E8
02492:  MOVFF  02,E7
02496:  MOVFF  01,E6
0249A:  MOVFF  00,E5
0249E:  CALL   03C4
024A2:  MOVFF  00,A3
024A6:  MOVFF  01,A4
024AA:  MOVFF  02,A5
024AE:  MOVFF  03,A6
024B2:  MOVFF  03,E0
024B6:  MOVFF  02,DF
024BA:  MOVFF  01,DE
024BE:  MOVFF  00,DD
024C2:  MOVLW  DB
024C4:  MOVWF  xE4
024C6:  MOVLW  0F
024C8:  MOVWF  xE3
024CA:  MOVLW  49
024CC:  MOVWF  xE2
024CE:  MOVLW  80
024D0:  MOVWF  xE1
024D2:  CALL   0720
024D6:  MOVFF  00,A3
024DA:  MOVFF  01,A4
024DE:  MOVFF  02,A5
024E2:  MOVFF  03,A6
024E6:  MOVFF  66,E0
024EA:  MOVFF  65,DF
024EE:  MOVFF  64,DE
024F2:  MOVFF  63,DD
024F6:  MOVFF  96,E4
024FA:  MOVFF  95,E3
024FE:  MOVFF  94,E2
02502:  MOVFF  93,E1
02506:  CALL   087A
0250A:  BNC   251A
0250C:  MOVLW  86
0250E:  MOVWF  00
02510:  MOVLW  34
02512:  MOVWF  01
02514:  CLRF   02
02516:  CLRF   03
02518:  BRA    2522
0251A:  CLRF   00
0251C:  CLRF   01
0251E:  CLRF   02
02520:  CLRF   03
02522:  MOVFF  FEA,A8
02526:  MOVFF  FE9,A7
0252A:  BCF    FD8.1
0252C:  MOVFF  A6,E4
02530:  MOVFF  A5,E3
02534:  MOVFF  A4,E2
02538:  MOVFF  A3,E1
0253C:  MOVFF  03,E8
02540:  MOVFF  02,E7
02544:  MOVFF  01,E6
02548:  MOVFF  00,E5
0254C:  CALL   04B6
02550:  MOVFF  A8,FEA
02554:  MOVFF  A7,FE9
02558:  MOVFF  03,82
0255C:  MOVFF  02,81
02560:  MOVFF  01,80
02564:  MOVFF  00,7F
....................    } 
....................    else{no_point();} 
02568:  BRA    256E
0256A:  CALL   0EDA
....................                   
....................    //********** theta 3 ******************************************************// 
....................     
....................    x03 = x0*cos(120*pi/180) - y0*sin(120*pi/180); 
0256E:  MOVLW  92
02570:  MOVWF  xB2
02572:  MOVLW  0A
02574:  MOVWF  xB1
02576:  MOVLW  06
02578:  MOVWF  xB0
0257A:  MOVLW  80
0257C:  MOVWF  xAF
0257E:  CALL   0FAE
02582:  MOVFF  52,E4
02586:  MOVFF  51,E3
0258A:  MOVFF  50,E2
0258E:  MOVFF  4F,E1
02592:  MOVFF  03,E8
02596:  MOVFF  02,E7
0259A:  MOVFF  01,E6
0259E:  MOVFF  00,E5
025A2:  CALL   03C4
025A6:  MOVFF  00,A3
025AA:  MOVFF  01,A4
025AE:  MOVFF  02,A5
025B2:  MOVFF  03,A6
025B6:  MOVLW  92
025B8:  MOVWF  xAA
025BA:  MOVLW  0A
025BC:  MOVWF  xA9
025BE:  MOVLW  06
025C0:  MOVWF  xA8
025C2:  MOVLW  80
025C4:  MOVWF  xA7
025C6:  CALL   1320
025CA:  MOVFF  56,E4
025CE:  MOVFF  55,E3
025D2:  MOVFF  54,E2
025D6:  MOVFF  53,E1
025DA:  MOVFF  03,E8
025DE:  MOVFF  02,E7
025E2:  MOVFF  01,E6
025E6:  MOVFF  00,E5
025EA:  CALL   03C4
025EE:  MOVFF  FEA,A8
025F2:  MOVFF  FE9,A7
025F6:  BSF    FD8.1
025F8:  MOVFF  A6,E4
025FC:  MOVFF  A5,E3
02600:  MOVFF  A4,E2
02604:  MOVFF  A3,E1
02608:  MOVFF  03,E8
0260C:  MOVFF  02,E7
02610:  MOVFF  01,E6
02614:  MOVFF  00,E5
02618:  CALL   04B6
0261C:  MOVFF  A8,FEA
02620:  MOVFF  A7,FE9
02624:  MOVFF  03,62
02628:  MOVFF  02,61
0262C:  MOVFF  01,60
02630:  MOVFF  00,5F
....................    y03 = y0*cos(120*pi/180) + x0*sin(120*pi/180); 
02634:  MOVLW  92
02636:  MOVWF  xB2
02638:  MOVLW  0A
0263A:  MOVWF  xB1
0263C:  MOVLW  06
0263E:  MOVWF  xB0
02640:  MOVLW  80
02642:  MOVWF  xAF
02644:  CALL   0FAE
02648:  MOVFF  56,E4
0264C:  MOVFF  55,E3
02650:  MOVFF  54,E2
02654:  MOVFF  53,E1
02658:  MOVFF  03,E8
0265C:  MOVFF  02,E7
02660:  MOVFF  01,E6
02664:  MOVFF  00,E5
02668:  CALL   03C4
0266C:  MOVFF  00,A3
02670:  MOVFF  01,A4
02674:  MOVFF  02,A5
02678:  MOVFF  03,A6
0267C:  MOVLW  92
0267E:  MOVWF  xAA
02680:  MOVLW  0A
02682:  MOVWF  xA9
02684:  MOVLW  06
02686:  MOVWF  xA8
02688:  MOVLW  80
0268A:  MOVWF  xA7
0268C:  CALL   1320
02690:  MOVFF  52,E4
02694:  MOVFF  51,E3
02698:  MOVFF  50,E2
0269C:  MOVFF  4F,E1
026A0:  MOVFF  03,E8
026A4:  MOVFF  02,E7
026A8:  MOVFF  01,E6
026AC:  MOVFF  00,E5
026B0:  CALL   03C4
026B4:  MOVFF  FEA,A8
026B8:  MOVFF  FE9,A7
026BC:  BCF    FD8.1
026BE:  MOVFF  A6,E4
026C2:  MOVFF  A5,E3
026C6:  MOVFF  A4,E2
026CA:  MOVFF  A3,E1
026CE:  MOVFF  03,E8
026D2:  MOVFF  02,E7
026D6:  MOVFF  01,E6
026DA:  MOVFF  00,E5
026DE:  CALL   04B6
026E2:  MOVFF  A8,FEA
026E6:  MOVFF  A7,FE9
026EA:  MOVFF  03,72
026EE:  MOVFF  02,71
026F2:  MOVFF  01,70
026F6:  MOVFF  00,6F
....................    z03 = z0; 
026FA:  MOVFF  5A,7A
026FE:  MOVFF  59,79
02702:  MOVFF  58,78
02706:  MOVFF  57,77
....................     
....................    y1 = -0.5 * 0.57735 * f;     // f/2 * tg 30 
0270A:  MOVLW  36
0270C:  MOVWF  xE4
0270E:  MOVLW  CD
02710:  MOVWF  xE3
02712:  MOVLW  93
02714:  MOVWF  xE2
02716:  MOVLW  7D
02718:  MOVWF  xE1
0271A:  MOVFF  46,E8
0271E:  MOVFF  45,E7
02722:  MOVFF  44,E6
02726:  MOVFF  43,E5
0272A:  CALL   03C4
0272E:  MOVFF  03,66
02732:  MOVFF  02,65
02736:  MOVFF  01,64
0273A:  MOVFF  00,63
....................    y03 = y03 -0.5 * 0.57735 * e;    // shift center to edge 
0273E:  MOVLW  36
02740:  MOVWF  xE4
02742:  MOVLW  CD
02744:  MOVWF  xE3
02746:  MOVLW  13
02748:  MOVWF  xE2
0274A:  MOVLW  7D
0274C:  MOVWF  xE1
0274E:  MOVFF  42,E8
02752:  MOVFF  41,E7
02756:  MOVFF  40,E6
0275A:  MOVFF  3F,E5
0275E:  CALL   03C4
02762:  BSF    FD8.1
02764:  MOVFF  72,E4
02768:  MOVFF  71,E3
0276C:  MOVFF  70,E2
02770:  MOVFF  6F,E1
02774:  MOVFF  03,E8
02778:  MOVFF  02,E7
0277C:  MOVFF  01,E6
02780:  MOVFF  00,E5
02784:  CALL   04B6
02788:  MOVFF  03,72
0278C:  MOVFF  02,71
02790:  MOVFF  01,70
02794:  MOVFF  00,6F
....................     
....................    // z = a + b*y 
....................    a = (x03*x03 + y03*y03 + z03*z03 +rf*rf - re*re - y1*y1)/(2*z03); 
02798:  MOVFF  62,E4
0279C:  MOVFF  61,E3
027A0:  MOVFF  60,E2
027A4:  MOVFF  5F,E1
027A8:  MOVFF  62,E8
027AC:  MOVFF  61,E7
027B0:  MOVFF  60,E6
027B4:  MOVFF  5F,E5
027B8:  CALL   03C4
027BC:  MOVFF  00,A3
027C0:  MOVFF  01,A4
027C4:  MOVFF  02,A5
027C8:  MOVFF  03,A6
027CC:  MOVFF  72,E4
027D0:  MOVFF  71,E3
027D4:  MOVFF  70,E2
027D8:  MOVFF  6F,E1
027DC:  MOVFF  72,E8
027E0:  MOVFF  71,E7
027E4:  MOVFF  70,E6
027E8:  MOVFF  6F,E5
027EC:  CALL   03C4
027F0:  BCF    FD8.1
027F2:  MOVFF  A6,E4
027F6:  MOVFF  A5,E3
027FA:  MOVFF  A4,E2
027FE:  MOVFF  A3,E1
02802:  MOVFF  03,E8
02806:  MOVFF  02,E7
0280A:  MOVFF  01,E6
0280E:  MOVFF  00,E5
02812:  CALL   04B6
02816:  MOVFF  00,A3
0281A:  MOVFF  01,A4
0281E:  MOVFF  02,A5
02822:  MOVFF  03,A6
02826:  MOVFF  7A,E4
0282A:  MOVFF  79,E3
0282E:  MOVFF  78,E2
02832:  MOVFF  77,E1
02836:  MOVFF  7A,E8
0283A:  MOVFF  79,E7
0283E:  MOVFF  78,E6
02842:  MOVFF  77,E5
02846:  CALL   03C4
0284A:  BCF    FD8.1
0284C:  MOVFF  A6,E4
02850:  MOVFF  A5,E3
02854:  MOVFF  A4,E2
02858:  MOVFF  A3,E1
0285C:  MOVFF  03,E8
02860:  MOVFF  02,E7
02864:  MOVFF  01,E6
02868:  MOVFF  00,E5
0286C:  CALL   04B6
02870:  MOVFF  00,A3
02874:  MOVFF  01,A4
02878:  MOVFF  02,A5
0287C:  MOVFF  03,A6
02880:  MOVFF  4E,E4
02884:  MOVFF  4D,E3
02888:  MOVFF  4C,E2
0288C:  MOVFF  4B,E1
02890:  MOVFF  4E,E8
02894:  MOVFF  4D,E7
02898:  MOVFF  4C,E6
0289C:  MOVFF  4B,E5
028A0:  CALL   03C4
028A4:  BCF    FD8.1
028A6:  MOVFF  A6,E4
028AA:  MOVFF  A5,E3
028AE:  MOVFF  A4,E2
028B2:  MOVFF  A3,E1
028B6:  MOVFF  03,E8
028BA:  MOVFF  02,E7
028BE:  MOVFF  01,E6
028C2:  MOVFF  00,E5
028C6:  CALL   04B6
028CA:  MOVFF  00,A3
028CE:  MOVFF  01,A4
028D2:  MOVFF  02,A5
028D6:  MOVFF  03,A6
028DA:  MOVFF  4A,E4
028DE:  MOVFF  49,E3
028E2:  MOVFF  48,E2
028E6:  MOVFF  47,E1
028EA:  MOVFF  4A,E8
028EE:  MOVFF  49,E7
028F2:  MOVFF  48,E6
028F6:  MOVFF  47,E5
028FA:  CALL   03C4
028FE:  BSF    FD8.1
02900:  MOVFF  A6,E4
02904:  MOVFF  A5,E3
02908:  MOVFF  A4,E2
0290C:  MOVFF  A3,E1
02910:  MOVFF  03,E8
02914:  MOVFF  02,E7
02918:  MOVFF  01,E6
0291C:  MOVFF  00,E5
02920:  CALL   04B6
02924:  MOVFF  00,A3
02928:  MOVFF  01,A4
0292C:  MOVFF  02,A5
02930:  MOVFF  03,A6
02934:  MOVFF  66,E4
02938:  MOVFF  65,E3
0293C:  MOVFF  64,E2
02940:  MOVFF  63,E1
02944:  MOVFF  66,E8
02948:  MOVFF  65,E7
0294C:  MOVFF  64,E6
02950:  MOVFF  63,E5
02954:  CALL   03C4
02958:  BSF    FD8.1
0295A:  MOVFF  A6,E4
0295E:  MOVFF  A5,E3
02962:  MOVFF  A4,E2
02966:  MOVFF  A3,E1
0296A:  MOVFF  03,E8
0296E:  MOVFF  02,E7
02972:  MOVFF  01,E6
02976:  MOVFF  00,E5
0297A:  CALL   04B6
0297E:  MOVFF  00,A3
02982:  MOVFF  01,A4
02986:  MOVFF  02,A5
0298A:  MOVFF  03,A6
0298E:  CLRF   xE4
02990:  CLRF   xE3
02992:  CLRF   xE2
02994:  MOVLW  80
02996:  MOVWF  xE1
02998:  MOVFF  7A,E8
0299C:  MOVFF  79,E7
029A0:  MOVFF  78,E6
029A4:  MOVFF  77,E5
029A8:  CALL   03C4
029AC:  MOVFF  A6,E0
029B0:  MOVFF  A5,DF
029B4:  MOVFF  A4,DE
029B8:  MOVFF  A3,DD
029BC:  MOVFF  03,E4
029C0:  MOVFF  02,E3
029C4:  MOVFF  01,E2
029C8:  MOVFF  00,E1
029CC:  CALL   0720
029D0:  MOVFF  03,8A
029D4:  MOVFF  02,89
029D8:  MOVFF  01,88
029DC:  MOVFF  00,87
....................    b = (y1-y03)/z03; 
029E0:  BSF    FD8.1
029E2:  MOVFF  66,E4
029E6:  MOVFF  65,E3
029EA:  MOVFF  64,E2
029EE:  MOVFF  63,E1
029F2:  MOVFF  72,E8
029F6:  MOVFF  71,E7
029FA:  MOVFF  70,E6
029FE:  MOVFF  6F,E5
02A02:  CALL   04B6
02A06:  MOVFF  00,A3
02A0A:  MOVFF  01,A4
02A0E:  MOVFF  02,A5
02A12:  MOVFF  03,A6
02A16:  MOVFF  03,E0
02A1A:  MOVFF  02,DF
02A1E:  MOVFF  01,DE
02A22:  MOVFF  00,DD
02A26:  MOVFF  7A,E4
02A2A:  MOVFF  79,E3
02A2E:  MOVFF  78,E2
02A32:  MOVFF  77,E1
02A36:  CALL   0720
02A3A:  MOVFF  03,8E
02A3E:  MOVFF  02,8D
02A42:  MOVFF  01,8C
02A46:  MOVFF  00,8B
....................     
....................    // discriminant 
....................    d = -(a+b*y1)*(a+b*y1)+rf*(b*b*rf+rf); 
02A4A:  MOVFF  8E,E4
02A4E:  MOVFF  8D,E3
02A52:  MOVFF  8C,E2
02A56:  MOVFF  8B,E1
02A5A:  MOVFF  66,E8
02A5E:  MOVFF  65,E7
02A62:  MOVFF  64,E6
02A66:  MOVFF  63,E5
02A6A:  CALL   03C4
02A6E:  BCF    FD8.1
02A70:  MOVFF  8A,E4
02A74:  MOVFF  89,E3
02A78:  MOVFF  88,E2
02A7C:  MOVFF  87,E1
02A80:  MOVFF  03,E8
02A84:  MOVFF  02,E7
02A88:  MOVFF  01,E6
02A8C:  MOVFF  00,E5
02A90:  CALL   04B6
02A94:  MOVFF  00,A3
02A98:  MOVF   01,W
02A9A:  XORLW  80
02A9C:  MOVWF  xA4
02A9E:  MOVFF  02,A5
02AA2:  MOVFF  03,A6
02AA6:  MOVFF  8E,E4
02AAA:  MOVFF  8D,E3
02AAE:  MOVFF  8C,E2
02AB2:  MOVFF  8B,E1
02AB6:  MOVFF  66,E8
02ABA:  MOVFF  65,E7
02ABE:  MOVFF  64,E6
02AC2:  MOVFF  63,E5
02AC6:  CALL   03C4
02ACA:  BCF    FD8.1
02ACC:  MOVFF  8A,E4
02AD0:  MOVFF  89,E3
02AD4:  MOVFF  88,E2
02AD8:  MOVFF  87,E1
02ADC:  MOVFF  03,E8
02AE0:  MOVFF  02,E7
02AE4:  MOVFF  01,E6
02AE8:  MOVFF  00,E5
02AEC:  CALL   04B6
02AF0:  MOVFF  A6,E4
02AF4:  MOVFF  A5,E3
02AF8:  MOVFF  A4,E2
02AFC:  MOVFF  A3,E1
02B00:  MOVFF  03,E8
02B04:  MOVFF  02,E7
02B08:  MOVFF  01,E6
02B0C:  MOVFF  00,E5
02B10:  CALL   03C4
02B14:  MOVFF  00,A3
02B18:  MOVFF  01,A4
02B1C:  MOVFF  02,A5
02B20:  MOVFF  03,A6
02B24:  MOVFF  8E,E4
02B28:  MOVFF  8D,E3
02B2C:  MOVFF  8C,E2
02B30:  MOVFF  8B,E1
02B34:  MOVFF  8E,E8
02B38:  MOVFF  8D,E7
02B3C:  MOVFF  8C,E6
02B40:  MOVFF  8B,E5
02B44:  CALL   03C4
02B48:  MOVFF  00,A7
02B4C:  MOVFF  01,A8
02B50:  MOVFF  02,A9
02B54:  MOVFF  03,AA
02B58:  MOVFF  03,E4
02B5C:  MOVFF  02,E3
02B60:  MOVFF  01,E2
02B64:  MOVFF  00,E1
02B68:  MOVFF  4E,E8
02B6C:  MOVFF  4D,E7
02B70:  MOVFF  4C,E6
02B74:  MOVFF  4B,E5
02B78:  CALL   03C4
02B7C:  MOVFF  00,A7
02B80:  MOVFF  01,A8
02B84:  MOVFF  02,A9
02B88:  MOVFF  03,AA
02B8C:  BCF    FD8.1
02B8E:  MOVFF  03,E4
02B92:  MOVFF  02,E3
02B96:  MOVFF  01,E2
02B9A:  MOVFF  00,E1
02B9E:  MOVFF  4E,E8
02BA2:  MOVFF  4D,E7
02BA6:  MOVFF  4C,E6
02BAA:  MOVFF  4B,E5
02BAE:  CALL   04B6
02BB2:  MOVFF  4E,E4
02BB6:  MOVFF  4D,E3
02BBA:  MOVFF  4C,E2
02BBE:  MOVFF  4B,E1
02BC2:  MOVFF  03,E8
02BC6:  MOVFF  02,E7
02BCA:  MOVFF  01,E6
02BCE:  MOVFF  00,E5
02BD2:  CALL   03C4
02BD6:  BCF    FD8.1
02BD8:  MOVFF  A6,E4
02BDC:  MOVFF  A5,E3
02BE0:  MOVFF  A4,E2
02BE4:  MOVFF  A3,E1
02BE8:  MOVFF  03,E8
02BEC:  MOVFF  02,E7
02BF0:  MOVFF  01,E6
02BF4:  MOVFF  00,E5
02BF8:  CALL   04B6
02BFC:  MOVFF  03,92
02C00:  MOVFF  02,91
02C04:  MOVFF  01,90
02C08:  MOVFF  00,8F
....................    if (d > 0) 
02C0C:  CLRF   xE0
02C0E:  CLRF   xDF
02C10:  CLRF   xDE
02C12:  CLRF   xDD
02C14:  MOVFF  92,E4
02C18:  MOVFF  91,E3
02C1C:  MOVFF  90,E2
02C20:  MOVFF  8F,E1
02C24:  CALL   087A
02C28:  BTFSS  FD8.0
02C2A:  BRA    2F3A
....................    { 
....................        yj = (y1 - a*b - sqrt(d))/(b*b + 1);  // choosing outer point 
02C2C:  MOVFF  8A,E4
02C30:  MOVFF  89,E3
02C34:  MOVFF  88,E2
02C38:  MOVFF  87,E1
02C3C:  MOVFF  8E,E8
02C40:  MOVFF  8D,E7
02C44:  MOVFF  8C,E6
02C48:  MOVFF  8B,E5
02C4C:  CALL   03C4
02C50:  BSF    FD8.1
02C52:  MOVFF  66,E4
02C56:  MOVFF  65,E3
02C5A:  MOVFF  64,E2
02C5E:  MOVFF  63,E1
02C62:  MOVFF  03,E8
02C66:  MOVFF  02,E7
02C6A:  MOVFF  01,E6
02C6E:  MOVFF  00,E5
02C72:  CALL   04B6
02C76:  MOVFF  00,A3
02C7A:  MOVFF  01,A4
02C7E:  MOVFF  02,A5
02C82:  MOVFF  03,A6
02C86:  MOVFF  92,AA
02C8A:  MOVFF  91,A9
02C8E:  MOVFF  90,A8
02C92:  MOVFF  8F,A7
02C96:  CALL   08F0
02C9A:  MOVFF  FEA,A8
02C9E:  MOVFF  FE9,A7
02CA2:  BSF    FD8.1
02CA4:  MOVFF  A6,E4
02CA8:  MOVFF  A5,E3
02CAC:  MOVFF  A4,E2
02CB0:  MOVFF  A3,E1
02CB4:  MOVFF  03,E8
02CB8:  MOVFF  02,E7
02CBC:  MOVFF  01,E6
02CC0:  MOVFF  00,E5
02CC4:  CALL   04B6
02CC8:  MOVFF  A8,FEA
02CCC:  MOVFF  A7,FE9
02CD0:  MOVFF  00,A3
02CD4:  MOVFF  01,A4
02CD8:  MOVFF  02,A5
02CDC:  MOVFF  03,A6
02CE0:  MOVFF  8E,E4
02CE4:  MOVFF  8D,E3
02CE8:  MOVFF  8C,E2
02CEC:  MOVFF  8B,E1
02CF0:  MOVFF  8E,E8
02CF4:  MOVFF  8D,E7
02CF8:  MOVFF  8C,E6
02CFC:  MOVFF  8B,E5
02D00:  CALL   03C4
02D04:  MOVFF  00,A9
02D08:  MOVFF  01,AA
02D0C:  MOVFF  02,AB
02D10:  MOVFF  03,AC
02D14:  MOVFF  FEA,AE
02D18:  MOVFF  FE9,AD
02D1C:  BCF    FD8.1
02D1E:  MOVFF  03,E4
02D22:  MOVFF  02,E3
02D26:  MOVFF  01,E2
02D2A:  MOVFF  00,E1
02D2E:  CLRF   xE8
02D30:  CLRF   xE7
02D32:  CLRF   xE6
02D34:  MOVLW  7F
02D36:  MOVWF  xE5
02D38:  CALL   04B6
02D3C:  MOVFF  AE,FEA
02D40:  MOVFF  AD,FE9
02D44:  MOVFF  A6,E0
02D48:  MOVFF  A5,DF
02D4C:  MOVFF  A4,DE
02D50:  MOVFF  A3,DD
02D54:  MOVFF  03,E4
02D58:  MOVFF  02,E3
02D5C:  MOVFF  01,E2
02D60:  MOVFF  00,E1
02D64:  CALL   0720
02D68:  MOVFF  03,96
02D6C:  MOVFF  02,95
02D70:  MOVFF  01,94
02D74:  MOVFF  00,93
....................        zj = a + b*yj; 
02D78:  MOVFF  8E,E4
02D7C:  MOVFF  8D,E3
02D80:  MOVFF  8C,E2
02D84:  MOVFF  8B,E1
02D88:  MOVFF  96,E8
02D8C:  MOVFF  95,E7
02D90:  MOVFF  94,E6
02D94:  MOVFF  93,E5
02D98:  CALL   03C4
02D9C:  BCF    FD8.1
02D9E:  MOVFF  8A,E4
02DA2:  MOVFF  89,E3
02DA6:  MOVFF  88,E2
02DAA:  MOVFF  87,E1
02DAE:  MOVFF  03,E8
02DB2:  MOVFF  02,E7
02DB6:  MOVFF  01,E6
02DBA:  MOVFF  00,E5
02DBE:  CALL   04B6
02DC2:  MOVFF  03,9A
02DC6:  MOVFF  02,99
02DCA:  MOVFF  01,98
02DCE:  MOVFF  00,97
....................        theta3 = 180.0*atan(-zj/(y1 - yj))/pi + ((yj>y1)?180.0:0.0);    //yj, y1 den küçükse 180; degilse 0 deðerini çýkarýr 
02DD2:  MOVFF  97,A3
02DD6:  MOVF   x98,W
02DD8:  XORLW  80
02DDA:  MOVWF  xA4
02DDC:  MOVFF  99,A5
02DE0:  MOVFF  9A,A6
02DE4:  BSF    FD8.1
02DE6:  MOVFF  66,E4
02DEA:  MOVFF  65,E3
02DEE:  MOVFF  64,E2
02DF2:  MOVFF  63,E1
02DF6:  MOVFF  96,E8
02DFA:  MOVFF  95,E7
02DFE:  MOVFF  94,E6
02E02:  MOVFF  93,E5
02E06:  CALL   04B6
02E0A:  MOVFF  A6,E0
02E0E:  MOVFF  A5,DF
02E12:  MOVFF  A4,DE
02E16:  MOVFF  A3,DD
02E1A:  MOVFF  03,E4
02E1E:  MOVFF  02,E3
02E22:  MOVFF  01,E2
02E26:  MOVFF  00,E1
02E2A:  CALL   0720
02E2E:  MOVFF  00,A3
02E32:  MOVFF  01,A4
02E36:  MOVFF  02,A5
02E3A:  MOVFF  03,A6
02E3E:  MOVFF  03,AA
02E42:  MOVFF  02,A9
02E46:  MOVFF  01,A8
02E4A:  MOVFF  00,A7
02E4E:  CALL   09FA
02E52:  CLRF   xE4
02E54:  CLRF   xE3
02E56:  MOVLW  34
02E58:  MOVWF  xE2
02E5A:  MOVLW  86
02E5C:  MOVWF  xE1
02E5E:  MOVFF  03,E8
02E62:  MOVFF  02,E7
02E66:  MOVFF  01,E6
02E6A:  MOVFF  00,E5
02E6E:  CALL   03C4
02E72:  MOVFF  00,A3
02E76:  MOVFF  01,A4
02E7A:  MOVFF  02,A5
02E7E:  MOVFF  03,A6
02E82:  MOVFF  03,E0
02E86:  MOVFF  02,DF
02E8A:  MOVFF  01,DE
02E8E:  MOVFF  00,DD
02E92:  MOVLW  DB
02E94:  MOVWF  xE4
02E96:  MOVLW  0F
02E98:  MOVWF  xE3
02E9A:  MOVLW  49
02E9C:  MOVWF  xE2
02E9E:  MOVLW  80
02EA0:  MOVWF  xE1
02EA2:  CALL   0720
02EA6:  MOVFF  00,A3
02EAA:  MOVFF  01,A4
02EAE:  MOVFF  02,A5
02EB2:  MOVFF  03,A6
02EB6:  MOVFF  66,E0
02EBA:  MOVFF  65,DF
02EBE:  MOVFF  64,DE
02EC2:  MOVFF  63,DD
02EC6:  MOVFF  96,E4
02ECA:  MOVFF  95,E3
02ECE:  MOVFF  94,E2
02ED2:  MOVFF  93,E1
02ED6:  CALL   087A
02EDA:  BNC   2EEA
02EDC:  MOVLW  86
02EDE:  MOVWF  00
02EE0:  MOVLW  34
02EE2:  MOVWF  01
02EE4:  CLRF   02
02EE6:  CLRF   03
02EE8:  BRA    2EF2
02EEA:  CLRF   00
02EEC:  CLRF   01
02EEE:  CLRF   02
02EF0:  CLRF   03
02EF2:  MOVFF  FEA,A8
02EF6:  MOVFF  FE9,A7
02EFA:  BCF    FD8.1
02EFC:  MOVFF  A6,E4
02F00:  MOVFF  A5,E3
02F04:  MOVFF  A4,E2
02F08:  MOVFF  A3,E1
02F0C:  MOVFF  03,E8
02F10:  MOVFF  02,E7
02F14:  MOVFF  01,E6
02F18:  MOVFF  00,E5
02F1C:  CALL   04B6
02F20:  MOVFF  A8,FEA
02F24:  MOVFF  A7,FE9
02F28:  MOVFF  03,86
02F2C:  MOVFF  02,85
02F30:  MOVFF  01,84
02F34:  MOVFF  00,83
....................    } 
....................    else{no_point();} 
02F38:  BRA    2F3E
02F3A:  CALL   0EDA
.................... } 
02F3E:  RETLW  00
.................... //********** Motor adým ve zaman bilgilerinin hesaplanýp eproma kaydý ********// 
.................... void motor_hareket() 
.................... { 
....................    mA_step = theta1 / tahvil_orani;         // adým deðerleri tam sayý cýkmýyor. 
*
0323A:  MOVFF  7E,E0
0323E:  MOVFF  7D,DF
03242:  MOVFF  7C,DE
03246:  MOVFF  7B,DD
0324A:  MOVFF  A2,E4
0324E:  MOVFF  A1,E3
03252:  MOVFF  A0,E2
03256:  MOVFF  9F,E1
0325A:  CALL   0720
0325E:  MOVFF  03,B3
03262:  MOVFF  02,B2
03266:  MOVFF  01,B1
0326A:  MOVFF  00,B0
0326E:  RCALL  2F40
03270:  MOVFF  03,12
03274:  MOVFF  02,11
03278:  MOVFF  01,10
0327C:  MOVFF  00,0F
....................    mB_step = theta2 / tahvil_orani;         // cýkmasý için int olarak tanýmlanmasý gerekiyor. 
03280:  MOVFF  82,E0
03284:  MOVFF  81,DF
03288:  MOVFF  80,DE
0328C:  MOVFF  7F,DD
03290:  MOVFF  A2,E4
03294:  MOVFF  A1,E3
03298:  MOVFF  A0,E2
0329C:  MOVFF  9F,E1
032A0:  CALL   0720
032A4:  MOVFF  03,B3
032A8:  MOVFF  02,B2
032AC:  MOVFF  01,B1
032B0:  MOVFF  00,B0
032B4:  RCALL  2F40
032B6:  MOVFF  03,16
032BA:  MOVFF  02,15
032BE:  MOVFF  01,14
032C2:  MOVFF  00,13
....................    mC_step = theta3 / tahvil_orani;         // eðer tanýmlanýrsa 10.85 cýkan adým deðeri 10 olarak alýnýyor 
032C6:  MOVFF  86,E0
032CA:  MOVFF  85,DF
032CE:  MOVFF  84,DE
032D2:  MOVFF  83,DD
032D6:  MOVFF  A2,E4
032DA:  MOVFF  A1,E3
032DE:  MOVFF  A0,E2
032E2:  MOVFF  9F,E1
032E6:  CALL   0720
032EA:  MOVFF  03,B3
032EE:  MOVFF  02,B2
032F2:  MOVFF  01,B1
032F6:  MOVFF  00,B0
032FA:  RCALL  2F40
032FC:  MOVFF  03,1A
03300:  MOVFF  02,19
03304:  MOVFF  01,18
03308:  MOVFF  00,17
....................                
....................    //********** motora gönderilecek adým deðerlerinin hesaplanmasý ***********// 
....................     
....................    // motor A 
....................    if(mA_step >= 0) 
0330C:  BTFSC  12.7
0330E:  BRA    3392
03310:  BRA    3312
....................    { 
....................       if(mA_step > mA_step_old)           // motor ileri 
03312:  BTFSS  1E.7
03314:  BRA    331C
03316:  BTFSS  12.7
03318:  BRA    333E
0331A:  BRA    3320
0331C:  BTFSC  12.7
0331E:  BRA    3368
03320:  MOVF   1E,W
03322:  SUBWF  12,W
03324:  BNC   3368
03326:  BNZ   333E
03328:  MOVF   1D,W
0332A:  SUBWF  11,W
0332C:  BNC   3368
0332E:  BNZ   333E
03330:  MOVF   1C,W
03332:  SUBWF  10,W
03334:  BNC   3368
03336:  BNZ   333E
03338:  MOVF   0F,W
0333A:  SUBWF  1B,W
0333C:  BC    3368
....................       { 
....................          ma = mA_step - mA_step_old;         // ma positive 
0333E:  MOVF   1B,W
03340:  SUBWF  0F,W
03342:  MOVWF  27
03344:  MOVF   1C,W
03346:  SUBWFB 10,W
03348:  MOVWF  28
0334A:  MOVF   1D,W
0334C:  SUBWFB 11,W
0334E:  MOVWF  29
03350:  MOVF   1E,W
03352:  SUBWFB 12,W
03354:  MOVWF  2A
....................          mA_step_old = mA_step; 
03356:  MOVFF  12,1E
0335A:  MOVFF  11,1D
0335E:  MOVFF  10,1C
03362:  MOVFF  0F,1B
....................       } 
....................       else                                // motor geri 
03366:  BRA    3390
....................       { 
....................          ma = mA_step - mA_step_old;         // ma negative 
03368:  MOVF   1B,W
0336A:  SUBWF  0F,W
0336C:  MOVWF  27
0336E:  MOVF   1C,W
03370:  SUBWFB 10,W
03372:  MOVWF  28
03374:  MOVF   1D,W
03376:  SUBWFB 11,W
03378:  MOVWF  29
0337A:  MOVF   1E,W
0337C:  SUBWFB 12,W
0337E:  MOVWF  2A
....................          mA_step_old = mA_step;   
03380:  MOVFF  12,1E
03384:  MOVFF  11,1D
03388:  MOVFF  10,1C
0338C:  MOVFF  0F,1B
....................       } 
....................    } 
....................    else  // mA_step < 0 
03390:  BRA    3410
....................    { 
....................       if(mA_step < mA_step_old)           // motor geri 
03392:  BTFSS  12.7
03394:  BRA    339C
03396:  BTFSS  1E.7
03398:  BRA    33BE
0339A:  BRA    33A0
0339C:  BTFSC  1E.7
0339E:  BRA    33E8
033A0:  MOVF   12,W
033A2:  SUBWF  1E,W
033A4:  BNC   33E8
033A6:  BNZ   33BE
033A8:  MOVF   11,W
033AA:  SUBWF  1D,W
033AC:  BNC   33E8
033AE:  BNZ   33BE
033B0:  MOVF   10,W
033B2:  SUBWF  1C,W
033B4:  BNC   33E8
033B6:  BNZ   33BE
033B8:  MOVF   1B,W
033BA:  SUBWF  0F,W
033BC:  BC    33E8
....................       { 
....................          ma = mA_step - mA_step_old; 
033BE:  MOVF   1B,W
033C0:  SUBWF  0F,W
033C2:  MOVWF  27
033C4:  MOVF   1C,W
033C6:  SUBWFB 10,W
033C8:  MOVWF  28
033CA:  MOVF   1D,W
033CC:  SUBWFB 11,W
033CE:  MOVWF  29
033D0:  MOVF   1E,W
033D2:  SUBWFB 12,W
033D4:  MOVWF  2A
....................          mA_step_old = mA_step;              // ma negative 
033D6:  MOVFF  12,1E
033DA:  MOVFF  11,1D
033DE:  MOVFF  10,1C
033E2:  MOVFF  0F,1B
....................       } 
....................       else                                // motor ileri 
033E6:  BRA    3410
....................       { 
....................          ma = mA_step - mA_step_old;         // ma positive 
033E8:  MOVF   1B,W
033EA:  SUBWF  0F,W
033EC:  MOVWF  27
033EE:  MOVF   1C,W
033F0:  SUBWFB 10,W
033F2:  MOVWF  28
033F4:  MOVF   1D,W
033F6:  SUBWFB 11,W
033F8:  MOVWF  29
033FA:  MOVF   1E,W
033FC:  SUBWFB 12,W
033FE:  MOVWF  2A
....................          mA_step_old = mA_step; 
03400:  MOVFF  12,1E
03404:  MOVFF  11,1D
03408:  MOVFF  10,1C
0340C:  MOVFF  0F,1B
....................       } 
....................    } 
....................     
....................    // motor B 
....................    if(mB_step >= 0) 
03410:  BTFSC  16.7
03412:  BRA    3496
03414:  BRA    3416
....................    { 
....................       if(mB_step > mB_step_old)           // motor ileri 
03416:  BTFSS  22.7
03418:  BRA    3420
0341A:  BTFSS  16.7
0341C:  BRA    3442
0341E:  BRA    3424
03420:  BTFSC  16.7
03422:  BRA    346C
03424:  MOVF   22,W
03426:  SUBWF  16,W
03428:  BNC   346C
0342A:  BNZ   3442
0342C:  MOVF   21,W
0342E:  SUBWF  15,W
03430:  BNC   346C
03432:  BNZ   3442
03434:  MOVF   20,W
03436:  SUBWF  14,W
03438:  BNC   346C
0343A:  BNZ   3442
0343C:  MOVF   13,W
0343E:  SUBWF  1F,W
03440:  BC    346C
....................       { 
....................          mb = mB_step - mB_step_old;         // mb positive 
03442:  MOVF   1F,W
03444:  SUBWF  13,W
03446:  MOVWF  2B
03448:  MOVF   20,W
0344A:  SUBWFB 14,W
0344C:  MOVWF  2C
0344E:  MOVF   21,W
03450:  SUBWFB 15,W
03452:  MOVWF  2D
03454:  MOVF   22,W
03456:  SUBWFB 16,W
03458:  MOVWF  2E
....................          mB_step_old = mB_step; 
0345A:  MOVFF  16,22
0345E:  MOVFF  15,21
03462:  MOVFF  14,20
03466:  MOVFF  13,1F
....................       } 
....................       else                                // motor geri 
0346A:  BRA    3494
....................       { 
....................          mb = mB_step - mB_step_old;         // mb negative 
0346C:  MOVF   1F,W
0346E:  SUBWF  13,W
03470:  MOVWF  2B
03472:  MOVF   20,W
03474:  SUBWFB 14,W
03476:  MOVWF  2C
03478:  MOVF   21,W
0347A:  SUBWFB 15,W
0347C:  MOVWF  2D
0347E:  MOVF   22,W
03480:  SUBWFB 16,W
03482:  MOVWF  2E
....................          mB_step_old = mB_step;   
03484:  MOVFF  16,22
03488:  MOVFF  15,21
0348C:  MOVFF  14,20
03490:  MOVFF  13,1F
....................       } 
....................    } 
....................    else  // mB_step < 0 
03494:  BRA    3514
....................    { 
....................       if(mB_step < mB_step_old)           // motor geri 
03496:  BTFSS  16.7
03498:  BRA    34A0
0349A:  BTFSS  22.7
0349C:  BRA    34C2
0349E:  BRA    34A4
034A0:  BTFSC  22.7
034A2:  BRA    34EC
034A4:  MOVF   16,W
034A6:  SUBWF  22,W
034A8:  BNC   34EC
034AA:  BNZ   34C2
034AC:  MOVF   15,W
034AE:  SUBWF  21,W
034B0:  BNC   34EC
034B2:  BNZ   34C2
034B4:  MOVF   14,W
034B6:  SUBWF  20,W
034B8:  BNC   34EC
034BA:  BNZ   34C2
034BC:  MOVF   1F,W
034BE:  SUBWF  13,W
034C0:  BC    34EC
....................       { 
....................          mb = mB_step - mB_step_old; 
034C2:  MOVF   1F,W
034C4:  SUBWF  13,W
034C6:  MOVWF  2B
034C8:  MOVF   20,W
034CA:  SUBWFB 14,W
034CC:  MOVWF  2C
034CE:  MOVF   21,W
034D0:  SUBWFB 15,W
034D2:  MOVWF  2D
034D4:  MOVF   22,W
034D6:  SUBWFB 16,W
034D8:  MOVWF  2E
....................          mB_step_old = mB_step;              // mb negative 
034DA:  MOVFF  16,22
034DE:  MOVFF  15,21
034E2:  MOVFF  14,20
034E6:  MOVFF  13,1F
....................       } 
....................       else                                // motor ileri 
034EA:  BRA    3514
....................       { 
....................          mb = mB_step - mB_step_old;         // mb positive 
034EC:  MOVF   1F,W
034EE:  SUBWF  13,W
034F0:  MOVWF  2B
034F2:  MOVF   20,W
034F4:  SUBWFB 14,W
034F6:  MOVWF  2C
034F8:  MOVF   21,W
034FA:  SUBWFB 15,W
034FC:  MOVWF  2D
034FE:  MOVF   22,W
03500:  SUBWFB 16,W
03502:  MOVWF  2E
....................          mB_step_old = mB_step; 
03504:  MOVFF  16,22
03508:  MOVFF  15,21
0350C:  MOVFF  14,20
03510:  MOVFF  13,1F
....................       } 
....................    } 
....................     
....................    // motor C 
....................    if(mC_step >= 0) 
03514:  BTFSC  1A.7
03516:  BRA    359A
03518:  BRA    351A
....................    { 
....................       if(mC_step > mC_step_old)           // motor ileri 
0351A:  BTFSS  26.7
0351C:  BRA    3524
0351E:  BTFSS  1A.7
03520:  BRA    3546
03522:  BRA    3528
03524:  BTFSC  1A.7
03526:  BRA    3570
03528:  MOVF   26,W
0352A:  SUBWF  1A,W
0352C:  BNC   3570
0352E:  BNZ   3546
03530:  MOVF   25,W
03532:  SUBWF  19,W
03534:  BNC   3570
03536:  BNZ   3546
03538:  MOVF   24,W
0353A:  SUBWF  18,W
0353C:  BNC   3570
0353E:  BNZ   3546
03540:  MOVF   17,W
03542:  SUBWF  23,W
03544:  BC    3570
....................       { 
....................          mc = mC_step - mC_step_old;         // mc positive 
03546:  MOVF   23,W
03548:  SUBWF  17,W
0354A:  MOVWF  2F
0354C:  MOVF   24,W
0354E:  SUBWFB 18,W
03550:  MOVWF  30
03552:  MOVF   25,W
03554:  SUBWFB 19,W
03556:  MOVWF  31
03558:  MOVF   26,W
0355A:  SUBWFB 1A,W
0355C:  MOVWF  32
....................          mC_step_old = mC_step; 
0355E:  MOVFF  1A,26
03562:  MOVFF  19,25
03566:  MOVFF  18,24
0356A:  MOVFF  17,23
....................       } 
....................       else                                // motor geri 
0356E:  BRA    3598
....................       { 
....................          mc = mC_step - mC_step_old;         // mc negative 
03570:  MOVF   23,W
03572:  SUBWF  17,W
03574:  MOVWF  2F
03576:  MOVF   24,W
03578:  SUBWFB 18,W
0357A:  MOVWF  30
0357C:  MOVF   25,W
0357E:  SUBWFB 19,W
03580:  MOVWF  31
03582:  MOVF   26,W
03584:  SUBWFB 1A,W
03586:  MOVWF  32
....................          mC_step_old = mC_step;   
03588:  MOVFF  1A,26
0358C:  MOVFF  19,25
03590:  MOVFF  18,24
03594:  MOVFF  17,23
....................       } 
....................    } 
....................    else  // mC_step < 0 
03598:  BRA    3618
....................    { 
....................       if(mC_step < mC_step_old)           // motor geri 
0359A:  BTFSS  1A.7
0359C:  BRA    35A4
0359E:  BTFSS  26.7
035A0:  BRA    35C6
035A2:  BRA    35A8
035A4:  BTFSC  26.7
035A6:  BRA    35F0
035A8:  MOVF   1A,W
035AA:  SUBWF  26,W
035AC:  BNC   35F0
035AE:  BNZ   35C6
035B0:  MOVF   19,W
035B2:  SUBWF  25,W
035B4:  BNC   35F0
035B6:  BNZ   35C6
035B8:  MOVF   18,W
035BA:  SUBWF  24,W
035BC:  BNC   35F0
035BE:  BNZ   35C6
035C0:  MOVF   23,W
035C2:  SUBWF  17,W
035C4:  BC    35F0
....................       { 
....................          mc = mC_step - mC_step_old; 
035C6:  MOVF   23,W
035C8:  SUBWF  17,W
035CA:  MOVWF  2F
035CC:  MOVF   24,W
035CE:  SUBWFB 18,W
035D0:  MOVWF  30
035D2:  MOVF   25,W
035D4:  SUBWFB 19,W
035D6:  MOVWF  31
035D8:  MOVF   26,W
035DA:  SUBWFB 1A,W
035DC:  MOVWF  32
....................          mC_step_old = mC_step;              // mc negative 
035DE:  MOVFF  1A,26
035E2:  MOVFF  19,25
035E6:  MOVFF  18,24
035EA:  MOVFF  17,23
....................       } 
....................       else                                // motor ileri 
035EE:  BRA    3618
....................       { 
....................          mc = mC_step - mC_step_old;         // mc positive 
035F0:  MOVF   23,W
035F2:  SUBWF  17,W
035F4:  MOVWF  2F
035F6:  MOVF   24,W
035F8:  SUBWFB 18,W
035FA:  MOVWF  30
035FC:  MOVF   25,W
035FE:  SUBWFB 19,W
03600:  MOVWF  31
03602:  MOVF   26,W
03604:  SUBWFB 1A,W
03606:  MOVWF  32
....................          mC_step_old = mC_step; 
03608:  MOVFF  1A,26
0360C:  MOVFF  19,25
03610:  MOVFF  18,24
03614:  MOVFF  17,23
....................       } 
....................    } 
....................  
....................    // en büyük adýmý bulma ve ona göre zaman deðiþkenlerini hesaplama// 
....................    if(labs(mb) > labs(mc))        // labs(): long türünden bir sayýsýnýn mutlak deðerini al 
03618:  MOVFF  2B,00
0361C:  MOVFF  2C,01
03620:  MOVFF  2D,02
03624:  MOVFF  2E,03
03628:  BTFSS  2E.7
0362A:  BRA    3646
0362C:  MOVLW  00
0362E:  BSF    FD8.0
03630:  SUBFWB 2B,W
03632:  MOVWF  00
03634:  MOVLW  00
03636:  SUBFWB 2C,W
03638:  MOVWF  01
0363A:  MOVLW  00
0363C:  SUBFWB 2D,W
0363E:  MOVWF  02
03640:  MOVLW  00
03642:  SUBFWB 2E,W
03644:  MOVWF  03
03646:  MOVFF  03,A6
0364A:  MOVFF  02,A5
0364E:  MOVFF  01,A4
03652:  MOVFF  00,A3
03656:  MOVFF  2F,00
0365A:  MOVFF  30,01
0365E:  MOVFF  31,02
03662:  MOVFF  32,03
03666:  BTFSS  32.7
03668:  BRA    3684
0366A:  MOVLW  00
0366C:  BSF    FD8.0
0366E:  SUBFWB 2F,W
03670:  MOVWF  00
03672:  MOVLW  00
03674:  SUBFWB 30,W
03676:  MOVWF  01
03678:  MOVLW  00
0367A:  SUBFWB 31,W
0367C:  MOVWF  02
0367E:  MOVLW  00
03680:  SUBFWB 32,W
03682:  MOVWF  03
03684:  BTFSS  03.7
03686:  BRA    368E
03688:  BTFSS  xA6.7
0368A:  BRA    36B8
0368C:  BRA    3692
0368E:  BTFSC  xA6.7
03690:  BRA    3AFE
03692:  MOVF   03,W
03694:  SUBWF  xA6,W
03696:  BTFSS  FD8.0
03698:  BRA    3AFE
0369A:  BNZ   36B8
0369C:  MOVF   02,W
0369E:  SUBWF  xA5,W
036A0:  BTFSS  FD8.0
036A2:  BRA    3AFE
036A4:  BNZ   36B8
036A6:  MOVF   01,W
036A8:  SUBWF  xA4,W
036AA:  BTFSS  FD8.0
036AC:  BRA    3AFE
036AE:  BNZ   36B8
036B0:  MOVF   xA3,W
036B2:  SUBWF  00,W
036B4:  BTFSC  FD8.0
036B6:  BRA    3AFE
....................    { 
....................       if(labs(mb) > labs(ma))       
036B8:  MOVFF  2B,00
036BC:  MOVFF  2C,01
036C0:  MOVFF  2D,02
036C4:  MOVFF  2E,03
036C8:  BTFSS  2E.7
036CA:  BRA    36E6
036CC:  MOVLW  00
036CE:  BSF    FD8.0
036D0:  SUBFWB 2B,W
036D2:  MOVWF  00
036D4:  MOVLW  00
036D6:  SUBFWB 2C,W
036D8:  MOVWF  01
036DA:  MOVLW  00
036DC:  SUBFWB 2D,W
036DE:  MOVWF  02
036E0:  MOVLW  00
036E2:  SUBFWB 2E,W
036E4:  MOVWF  03
036E6:  MOVFF  03,A6
036EA:  MOVFF  02,A5
036EE:  MOVFF  01,A4
036F2:  MOVFF  00,A3
036F6:  MOVFF  27,00
036FA:  MOVFF  28,01
036FE:  MOVFF  29,02
03702:  MOVFF  2A,03
03706:  BTFSS  2A.7
03708:  BRA    3724
0370A:  MOVLW  00
0370C:  BSF    FD8.0
0370E:  SUBFWB 27,W
03710:  MOVWF  00
03712:  MOVLW  00
03714:  SUBFWB 28,W
03716:  MOVWF  01
03718:  MOVLW  00
0371A:  SUBFWB 29,W
0371C:  MOVWF  02
0371E:  MOVLW  00
03720:  SUBFWB 2A,W
03722:  MOVWF  03
03724:  BTFSS  03.7
03726:  BRA    372E
03728:  BTFSS  xA6.7
0372A:  BRA    3758
0372C:  BRA    3732
0372E:  BTFSC  xA6.7
03730:  BRA    392A
03732:  MOVF   03,W
03734:  SUBWF  xA6,W
03736:  BTFSS  FD8.0
03738:  BRA    392A
0373A:  BNZ   3758
0373C:  MOVF   02,W
0373E:  SUBWF  xA5,W
03740:  BTFSS  FD8.0
03742:  BRA    392A
03744:  BNZ   3758
03746:  MOVF   01,W
03748:  SUBWF  xA4,W
0374A:  BTFSS  FD8.0
0374C:  BRA    392A
0374E:  BNZ   3758
03750:  MOVF   xA3,W
03752:  SUBWF  00,W
03754:  BTFSC  FD8.0
03756:  BRA    392A
....................       { 
....................          // b en büyük 
....................          tb = 15;                                     // tb = 15ms 
03758:  CLRF   3A
0375A:  CLRF   39
0375C:  CLRF   38
0375E:  MOVLW  0F
03760:  MOVWF  37
....................          ta = (labs(mb)/labs(ma))*tb; 
03762:  MOVFF  2B,00
03766:  MOVFF  2C,01
0376A:  MOVFF  2D,02
0376E:  MOVFF  2E,03
03772:  BTFSS  2E.7
03774:  BRA    3790
03776:  MOVLW  00
03778:  BSF    FD8.0
0377A:  SUBFWB 2B,W
0377C:  MOVWF  00
0377E:  MOVLW  00
03780:  SUBFWB 2C,W
03782:  MOVWF  01
03784:  MOVLW  00
03786:  SUBFWB 2D,W
03788:  MOVWF  02
0378A:  MOVLW  00
0378C:  SUBFWB 2E,W
0378E:  MOVWF  03
03790:  MOVFF  03,A6
03794:  MOVFF  02,A5
03798:  MOVFF  01,A4
0379C:  MOVFF  00,A3
037A0:  MOVFF  27,00
037A4:  MOVFF  28,01
037A8:  MOVFF  29,02
037AC:  MOVFF  2A,03
037B0:  BTFSS  2A.7
037B2:  BRA    37CE
037B4:  MOVLW  00
037B6:  BSF    FD8.0
037B8:  SUBFWB 27,W
037BA:  MOVWF  00
037BC:  MOVLW  00
037BE:  SUBFWB 28,W
037C0:  MOVWF  01
037C2:  MOVLW  00
037C4:  SUBFWB 29,W
037C6:  MOVWF  02
037C8:  MOVLW  00
037CA:  SUBFWB 2A,W
037CC:  MOVWF  03
037CE:  MOVFF  03,AA
037D2:  MOVFF  02,A9
037D6:  MOVFF  01,A8
037DA:  MOVFF  00,A7
037DE:  MOVFF  A6,AE
037E2:  MOVFF  A5,AD
037E6:  MOVFF  A4,AC
037EA:  MOVFF  A3,AB
037EE:  MOVFF  03,B2
037F2:  MOVFF  02,B1
037F6:  MOVFF  01,B0
037FA:  MOVFF  00,AF
037FE:  CALL   2F7E
03802:  MOVFF  03,A6
03806:  MOVFF  02,A5
0380A:  MOVFF  01,A4
0380E:  MOVFF  00,A3
03812:  MOVFF  03,AA
03816:  MOVFF  02,A9
0381A:  MOVFF  01,A8
0381E:  MOVFF  00,A7
03822:  MOVFF  3A,AE
03826:  MOVFF  39,AD
0382A:  MOVFF  38,AC
0382E:  MOVFF  37,AB
03832:  RCALL  304E
03834:  MOVFF  03,36
03838:  MOVFF  02,35
0383C:  MOVFF  01,34
03840:  MOVFF  00,33
....................          tc = (labs(mb)/labs(mc))*tb;                                             
03844:  MOVFF  2B,00
03848:  MOVFF  2C,01
0384C:  MOVFF  2D,02
03850:  MOVFF  2E,03
03854:  BTFSS  2E.7
03856:  BRA    3872
03858:  MOVLW  00
0385A:  BSF    FD8.0
0385C:  SUBFWB 2B,W
0385E:  MOVWF  00
03860:  MOVLW  00
03862:  SUBFWB 2C,W
03864:  MOVWF  01
03866:  MOVLW  00
03868:  SUBFWB 2D,W
0386A:  MOVWF  02
0386C:  MOVLW  00
0386E:  SUBFWB 2E,W
03870:  MOVWF  03
03872:  MOVFF  03,A6
03876:  MOVFF  02,A5
0387A:  MOVFF  01,A4
0387E:  MOVFF  00,A3
03882:  MOVFF  2F,00
03886:  MOVFF  30,01
0388A:  MOVFF  31,02
0388E:  MOVFF  32,03
03892:  BTFSS  32.7
03894:  BRA    38B0
03896:  MOVLW  00
03898:  BSF    FD8.0
0389A:  SUBFWB 2F,W
0389C:  MOVWF  00
0389E:  MOVLW  00
038A0:  SUBFWB 30,W
038A2:  MOVWF  01
038A4:  MOVLW  00
038A6:  SUBFWB 31,W
038A8:  MOVWF  02
038AA:  MOVLW  00
038AC:  SUBFWB 32,W
038AE:  MOVWF  03
038B0:  MOVFF  03,AA
038B4:  MOVFF  02,A9
038B8:  MOVFF  01,A8
038BC:  MOVFF  00,A7
038C0:  MOVFF  A6,AE
038C4:  MOVFF  A5,AD
038C8:  MOVFF  A4,AC
038CC:  MOVFF  A3,AB
038D0:  MOVFF  03,B2
038D4:  MOVFF  02,B1
038D8:  MOVFF  01,B0
038DC:  MOVFF  00,AF
038E0:  CALL   2F7E
038E4:  MOVFF  03,A6
038E8:  MOVFF  02,A5
038EC:  MOVFF  01,A4
038F0:  MOVFF  00,A3
038F4:  MOVFF  03,AA
038F8:  MOVFF  02,A9
038FC:  MOVFF  01,A8
03900:  MOVFF  00,A7
03904:  MOVFF  3A,AE
03908:  MOVFF  39,AD
0390C:  MOVFF  38,AC
03910:  MOVFF  37,AB
03914:  CALL   304E
03918:  MOVFF  03,3E
0391C:  MOVFF  02,3D
03920:  MOVFF  01,3C
03924:  MOVFF  00,3B
....................       } 
....................       else 
03928:  BRA    3AFC
....................       { 
....................          // a en büyük 
....................          ta = 15;                                     // ta = 15ms 
0392A:  CLRF   36
0392C:  CLRF   35
0392E:  CLRF   34
03930:  MOVLW  0F
03932:  MOVWF  33
....................          tb = (labs(ma)/labs(mb))*ta; 
03934:  MOVFF  27,00
03938:  MOVFF  28,01
0393C:  MOVFF  29,02
03940:  MOVFF  2A,03
03944:  BTFSS  2A.7
03946:  BRA    3962
03948:  MOVLW  00
0394A:  BSF    FD8.0
0394C:  SUBFWB 27,W
0394E:  MOVWF  00
03950:  MOVLW  00
03952:  SUBFWB 28,W
03954:  MOVWF  01
03956:  MOVLW  00
03958:  SUBFWB 29,W
0395A:  MOVWF  02
0395C:  MOVLW  00
0395E:  SUBFWB 2A,W
03960:  MOVWF  03
03962:  MOVFF  03,A6
03966:  MOVFF  02,A5
0396A:  MOVFF  01,A4
0396E:  MOVFF  00,A3
03972:  MOVFF  2B,00
03976:  MOVFF  2C,01
0397A:  MOVFF  2D,02
0397E:  MOVFF  2E,03
03982:  BTFSS  2E.7
03984:  BRA    39A0
03986:  MOVLW  00
03988:  BSF    FD8.0
0398A:  SUBFWB 2B,W
0398C:  MOVWF  00
0398E:  MOVLW  00
03990:  SUBFWB 2C,W
03992:  MOVWF  01
03994:  MOVLW  00
03996:  SUBFWB 2D,W
03998:  MOVWF  02
0399A:  MOVLW  00
0399C:  SUBFWB 2E,W
0399E:  MOVWF  03
039A0:  MOVFF  03,AA
039A4:  MOVFF  02,A9
039A8:  MOVFF  01,A8
039AC:  MOVFF  00,A7
039B0:  MOVFF  A6,AE
039B4:  MOVFF  A5,AD
039B8:  MOVFF  A4,AC
039BC:  MOVFF  A3,AB
039C0:  MOVFF  03,B2
039C4:  MOVFF  02,B1
039C8:  MOVFF  01,B0
039CC:  MOVFF  00,AF
039D0:  CALL   2F7E
039D4:  MOVFF  03,A6
039D8:  MOVFF  02,A5
039DC:  MOVFF  01,A4
039E0:  MOVFF  00,A3
039E4:  MOVFF  03,AA
039E8:  MOVFF  02,A9
039EC:  MOVFF  01,A8
039F0:  MOVFF  00,A7
039F4:  MOVFF  36,AE
039F8:  MOVFF  35,AD
039FC:  MOVFF  34,AC
03A00:  MOVFF  33,AB
03A04:  CALL   304E
03A08:  MOVFF  03,3A
03A0C:  MOVFF  02,39
03A10:  MOVFF  01,38
03A14:  MOVFF  00,37
....................          tc = (labs(ma)/labs(mc))*ta; 
03A18:  MOVFF  27,00
03A1C:  MOVFF  28,01
03A20:  MOVFF  29,02
03A24:  MOVFF  2A,03
03A28:  BTFSS  2A.7
03A2A:  BRA    3A46
03A2C:  MOVLW  00
03A2E:  BSF    FD8.0
03A30:  SUBFWB 27,W
03A32:  MOVWF  00
03A34:  MOVLW  00
03A36:  SUBFWB 28,W
03A38:  MOVWF  01
03A3A:  MOVLW  00
03A3C:  SUBFWB 29,W
03A3E:  MOVWF  02
03A40:  MOVLW  00
03A42:  SUBFWB 2A,W
03A44:  MOVWF  03
03A46:  MOVFF  03,A6
03A4A:  MOVFF  02,A5
03A4E:  MOVFF  01,A4
03A52:  MOVFF  00,A3
03A56:  MOVFF  2F,00
03A5A:  MOVFF  30,01
03A5E:  MOVFF  31,02
03A62:  MOVFF  32,03
03A66:  BTFSS  32.7
03A68:  BRA    3A84
03A6A:  MOVLW  00
03A6C:  BSF    FD8.0
03A6E:  SUBFWB 2F,W
03A70:  MOVWF  00
03A72:  MOVLW  00
03A74:  SUBFWB 30,W
03A76:  MOVWF  01
03A78:  MOVLW  00
03A7A:  SUBFWB 31,W
03A7C:  MOVWF  02
03A7E:  MOVLW  00
03A80:  SUBFWB 32,W
03A82:  MOVWF  03
03A84:  MOVFF  03,AA
03A88:  MOVFF  02,A9
03A8C:  MOVFF  01,A8
03A90:  MOVFF  00,A7
03A94:  MOVFF  A6,AE
03A98:  MOVFF  A5,AD
03A9C:  MOVFF  A4,AC
03AA0:  MOVFF  A3,AB
03AA4:  MOVFF  03,B2
03AA8:  MOVFF  02,B1
03AAC:  MOVFF  01,B0
03AB0:  MOVFF  00,AF
03AB4:  CALL   2F7E
03AB8:  MOVFF  03,A6
03ABC:  MOVFF  02,A5
03AC0:  MOVFF  01,A4
03AC4:  MOVFF  00,A3
03AC8:  MOVFF  03,AA
03ACC:  MOVFF  02,A9
03AD0:  MOVFF  01,A8
03AD4:  MOVFF  00,A7
03AD8:  MOVFF  36,AE
03ADC:  MOVFF  35,AD
03AE0:  MOVFF  34,AC
03AE4:  MOVFF  33,AB
03AE8:  CALL   304E
03AEC:  MOVFF  03,3E
03AF0:  MOVFF  02,3D
03AF4:  MOVFF  01,3C
03AF8:  MOVFF  00,3B
....................       } 
....................    } 
....................    else 
03AFC:  BRA    3F44
....................    { 
....................       if(labs(mc) > labs(ma)) 
03AFE:  MOVFF  2F,00
03B02:  MOVFF  30,01
03B06:  MOVFF  31,02
03B0A:  MOVFF  32,03
03B0E:  BTFSS  32.7
03B10:  BRA    3B2C
03B12:  MOVLW  00
03B14:  BSF    FD8.0
03B16:  SUBFWB 2F,W
03B18:  MOVWF  00
03B1A:  MOVLW  00
03B1C:  SUBFWB 30,W
03B1E:  MOVWF  01
03B20:  MOVLW  00
03B22:  SUBFWB 31,W
03B24:  MOVWF  02
03B26:  MOVLW  00
03B28:  SUBFWB 32,W
03B2A:  MOVWF  03
03B2C:  MOVFF  03,A6
03B30:  MOVFF  02,A5
03B34:  MOVFF  01,A4
03B38:  MOVFF  00,A3
03B3C:  MOVFF  27,00
03B40:  MOVFF  28,01
03B44:  MOVFF  29,02
03B48:  MOVFF  2A,03
03B4C:  BTFSS  2A.7
03B4E:  BRA    3B6A
03B50:  MOVLW  00
03B52:  BSF    FD8.0
03B54:  SUBFWB 27,W
03B56:  MOVWF  00
03B58:  MOVLW  00
03B5A:  SUBFWB 28,W
03B5C:  MOVWF  01
03B5E:  MOVLW  00
03B60:  SUBFWB 29,W
03B62:  MOVWF  02
03B64:  MOVLW  00
03B66:  SUBFWB 2A,W
03B68:  MOVWF  03
03B6A:  BTFSS  03.7
03B6C:  BRA    3B74
03B6E:  BTFSS  xA6.7
03B70:  BRA    3B9E
03B72:  BRA    3B78
03B74:  BTFSC  xA6.7
03B76:  BRA    3D72
03B78:  MOVF   03,W
03B7A:  SUBWF  xA6,W
03B7C:  BTFSS  FD8.0
03B7E:  BRA    3D72
03B80:  BNZ   3B9E
03B82:  MOVF   02,W
03B84:  SUBWF  xA5,W
03B86:  BTFSS  FD8.0
03B88:  BRA    3D72
03B8A:  BNZ   3B9E
03B8C:  MOVF   01,W
03B8E:  SUBWF  xA4,W
03B90:  BTFSS  FD8.0
03B92:  BRA    3D72
03B94:  BNZ   3B9E
03B96:  MOVF   xA3,W
03B98:  SUBWF  00,W
03B9A:  BTFSC  FD8.0
03B9C:  BRA    3D72
....................       { 
....................          // c en büyük 
....................          tc = 15;                                     // tc = 15ms 
03B9E:  CLRF   3E
03BA0:  CLRF   3D
03BA2:  CLRF   3C
03BA4:  MOVLW  0F
03BA6:  MOVWF  3B
....................          ta = (labs(mc)/labs(ma))*tc; 
03BA8:  MOVFF  2F,00
03BAC:  MOVFF  30,01
03BB0:  MOVFF  31,02
03BB4:  MOVFF  32,03
03BB8:  BTFSS  32.7
03BBA:  BRA    3BD6
03BBC:  MOVLW  00
03BBE:  BSF    FD8.0
03BC0:  SUBFWB 2F,W
03BC2:  MOVWF  00
03BC4:  MOVLW  00
03BC6:  SUBFWB 30,W
03BC8:  MOVWF  01
03BCA:  MOVLW  00
03BCC:  SUBFWB 31,W
03BCE:  MOVWF  02
03BD0:  MOVLW  00
03BD2:  SUBFWB 32,W
03BD4:  MOVWF  03
03BD6:  MOVFF  03,A6
03BDA:  MOVFF  02,A5
03BDE:  MOVFF  01,A4
03BE2:  MOVFF  00,A3
03BE6:  MOVFF  27,00
03BEA:  MOVFF  28,01
03BEE:  MOVFF  29,02
03BF2:  MOVFF  2A,03
03BF6:  BTFSS  2A.7
03BF8:  BRA    3C14
03BFA:  MOVLW  00
03BFC:  BSF    FD8.0
03BFE:  SUBFWB 27,W
03C00:  MOVWF  00
03C02:  MOVLW  00
03C04:  SUBFWB 28,W
03C06:  MOVWF  01
03C08:  MOVLW  00
03C0A:  SUBFWB 29,W
03C0C:  MOVWF  02
03C0E:  MOVLW  00
03C10:  SUBFWB 2A,W
03C12:  MOVWF  03
03C14:  MOVFF  03,AA
03C18:  MOVFF  02,A9
03C1C:  MOVFF  01,A8
03C20:  MOVFF  00,A7
03C24:  MOVFF  A6,AE
03C28:  MOVFF  A5,AD
03C2C:  MOVFF  A4,AC
03C30:  MOVFF  A3,AB
03C34:  MOVFF  03,B2
03C38:  MOVFF  02,B1
03C3C:  MOVFF  01,B0
03C40:  MOVFF  00,AF
03C44:  CALL   2F7E
03C48:  MOVFF  03,A6
03C4C:  MOVFF  02,A5
03C50:  MOVFF  01,A4
03C54:  MOVFF  00,A3
03C58:  MOVFF  03,AA
03C5C:  MOVFF  02,A9
03C60:  MOVFF  01,A8
03C64:  MOVFF  00,A7
03C68:  MOVFF  3E,AE
03C6C:  MOVFF  3D,AD
03C70:  MOVFF  3C,AC
03C74:  MOVFF  3B,AB
03C78:  CALL   304E
03C7C:  MOVFF  03,36
03C80:  MOVFF  02,35
03C84:  MOVFF  01,34
03C88:  MOVFF  00,33
....................          tb = (labs(mc)/labs(mb))*tc; 
03C8C:  MOVFF  2F,00
03C90:  MOVFF  30,01
03C94:  MOVFF  31,02
03C98:  MOVFF  32,03
03C9C:  BTFSS  32.7
03C9E:  BRA    3CBA
03CA0:  MOVLW  00
03CA2:  BSF    FD8.0
03CA4:  SUBFWB 2F,W
03CA6:  MOVWF  00
03CA8:  MOVLW  00
03CAA:  SUBFWB 30,W
03CAC:  MOVWF  01
03CAE:  MOVLW  00
03CB0:  SUBFWB 31,W
03CB2:  MOVWF  02
03CB4:  MOVLW  00
03CB6:  SUBFWB 32,W
03CB8:  MOVWF  03
03CBA:  MOVFF  03,A6
03CBE:  MOVFF  02,A5
03CC2:  MOVFF  01,A4
03CC6:  MOVFF  00,A3
03CCA:  MOVFF  2B,00
03CCE:  MOVFF  2C,01
03CD2:  MOVFF  2D,02
03CD6:  MOVFF  2E,03
03CDA:  BTFSS  2E.7
03CDC:  BRA    3CF8
03CDE:  MOVLW  00
03CE0:  BSF    FD8.0
03CE2:  SUBFWB 2B,W
03CE4:  MOVWF  00
03CE6:  MOVLW  00
03CE8:  SUBFWB 2C,W
03CEA:  MOVWF  01
03CEC:  MOVLW  00
03CEE:  SUBFWB 2D,W
03CF0:  MOVWF  02
03CF2:  MOVLW  00
03CF4:  SUBFWB 2E,W
03CF6:  MOVWF  03
03CF8:  MOVFF  03,AA
03CFC:  MOVFF  02,A9
03D00:  MOVFF  01,A8
03D04:  MOVFF  00,A7
03D08:  MOVFF  A6,AE
03D0C:  MOVFF  A5,AD
03D10:  MOVFF  A4,AC
03D14:  MOVFF  A3,AB
03D18:  MOVFF  03,B2
03D1C:  MOVFF  02,B1
03D20:  MOVFF  01,B0
03D24:  MOVFF  00,AF
03D28:  CALL   2F7E
03D2C:  MOVFF  03,A6
03D30:  MOVFF  02,A5
03D34:  MOVFF  01,A4
03D38:  MOVFF  00,A3
03D3C:  MOVFF  03,AA
03D40:  MOVFF  02,A9
03D44:  MOVFF  01,A8
03D48:  MOVFF  00,A7
03D4C:  MOVFF  3E,AE
03D50:  MOVFF  3D,AD
03D54:  MOVFF  3C,AC
03D58:  MOVFF  3B,AB
03D5C:  CALL   304E
03D60:  MOVFF  03,3A
03D64:  MOVFF  02,39
03D68:  MOVFF  01,38
03D6C:  MOVFF  00,37
....................       } 
....................       else 
03D70:  BRA    3F44
....................       { 
....................          // a en büyük 
....................          ta = 15;                                     // ta = 15ms 
03D72:  CLRF   36
03D74:  CLRF   35
03D76:  CLRF   34
03D78:  MOVLW  0F
03D7A:  MOVWF  33
....................          tb = (labs(ma)/labs(mb))*ta; 
03D7C:  MOVFF  27,00
03D80:  MOVFF  28,01
03D84:  MOVFF  29,02
03D88:  MOVFF  2A,03
03D8C:  BTFSS  2A.7
03D8E:  BRA    3DAA
03D90:  MOVLW  00
03D92:  BSF    FD8.0
03D94:  SUBFWB 27,W
03D96:  MOVWF  00
03D98:  MOVLW  00
03D9A:  SUBFWB 28,W
03D9C:  MOVWF  01
03D9E:  MOVLW  00
03DA0:  SUBFWB 29,W
03DA2:  MOVWF  02
03DA4:  MOVLW  00
03DA6:  SUBFWB 2A,W
03DA8:  MOVWF  03
03DAA:  MOVFF  03,A6
03DAE:  MOVFF  02,A5
03DB2:  MOVFF  01,A4
03DB6:  MOVFF  00,A3
03DBA:  MOVFF  2B,00
03DBE:  MOVFF  2C,01
03DC2:  MOVFF  2D,02
03DC6:  MOVFF  2E,03
03DCA:  BTFSS  2E.7
03DCC:  BRA    3DE8
03DCE:  MOVLW  00
03DD0:  BSF    FD8.0
03DD2:  SUBFWB 2B,W
03DD4:  MOVWF  00
03DD6:  MOVLW  00
03DD8:  SUBFWB 2C,W
03DDA:  MOVWF  01
03DDC:  MOVLW  00
03DDE:  SUBFWB 2D,W
03DE0:  MOVWF  02
03DE2:  MOVLW  00
03DE4:  SUBFWB 2E,W
03DE6:  MOVWF  03
03DE8:  MOVFF  03,AA
03DEC:  MOVFF  02,A9
03DF0:  MOVFF  01,A8
03DF4:  MOVFF  00,A7
03DF8:  MOVFF  A6,AE
03DFC:  MOVFF  A5,AD
03E00:  MOVFF  A4,AC
03E04:  MOVFF  A3,AB
03E08:  MOVFF  03,B2
03E0C:  MOVFF  02,B1
03E10:  MOVFF  01,B0
03E14:  MOVFF  00,AF
03E18:  CALL   2F7E
03E1C:  MOVFF  03,A6
03E20:  MOVFF  02,A5
03E24:  MOVFF  01,A4
03E28:  MOVFF  00,A3
03E2C:  MOVFF  03,AA
03E30:  MOVFF  02,A9
03E34:  MOVFF  01,A8
03E38:  MOVFF  00,A7
03E3C:  MOVFF  36,AE
03E40:  MOVFF  35,AD
03E44:  MOVFF  34,AC
03E48:  MOVFF  33,AB
03E4C:  CALL   304E
03E50:  MOVFF  03,3A
03E54:  MOVFF  02,39
03E58:  MOVFF  01,38
03E5C:  MOVFF  00,37
....................          tc = (labs(ma)/labs(mc))*ta; 
03E60:  MOVFF  27,00
03E64:  MOVFF  28,01
03E68:  MOVFF  29,02
03E6C:  MOVFF  2A,03
03E70:  BTFSS  2A.7
03E72:  BRA    3E8E
03E74:  MOVLW  00
03E76:  BSF    FD8.0
03E78:  SUBFWB 27,W
03E7A:  MOVWF  00
03E7C:  MOVLW  00
03E7E:  SUBFWB 28,W
03E80:  MOVWF  01
03E82:  MOVLW  00
03E84:  SUBFWB 29,W
03E86:  MOVWF  02
03E88:  MOVLW  00
03E8A:  SUBFWB 2A,W
03E8C:  MOVWF  03
03E8E:  MOVFF  03,A6
03E92:  MOVFF  02,A5
03E96:  MOVFF  01,A4
03E9A:  MOVFF  00,A3
03E9E:  MOVFF  2F,00
03EA2:  MOVFF  30,01
03EA6:  MOVFF  31,02
03EAA:  MOVFF  32,03
03EAE:  BTFSS  32.7
03EB0:  BRA    3ECC
03EB2:  MOVLW  00
03EB4:  BSF    FD8.0
03EB6:  SUBFWB 2F,W
03EB8:  MOVWF  00
03EBA:  MOVLW  00
03EBC:  SUBFWB 30,W
03EBE:  MOVWF  01
03EC0:  MOVLW  00
03EC2:  SUBFWB 31,W
03EC4:  MOVWF  02
03EC6:  MOVLW  00
03EC8:  SUBFWB 32,W
03ECA:  MOVWF  03
03ECC:  MOVFF  03,AA
03ED0:  MOVFF  02,A9
03ED4:  MOVFF  01,A8
03ED8:  MOVFF  00,A7
03EDC:  MOVFF  A6,AE
03EE0:  MOVFF  A5,AD
03EE4:  MOVFF  A4,AC
03EE8:  MOVFF  A3,AB
03EEC:  MOVFF  03,B2
03EF0:  MOVFF  02,B1
03EF4:  MOVFF  01,B0
03EF8:  MOVFF  00,AF
03EFC:  CALL   2F7E
03F00:  MOVFF  03,A6
03F04:  MOVFF  02,A5
03F08:  MOVFF  01,A4
03F0C:  MOVFF  00,A3
03F10:  MOVFF  03,AA
03F14:  MOVFF  02,A9
03F18:  MOVFF  01,A8
03F1C:  MOVFF  00,A7
03F20:  MOVFF  36,AE
03F24:  MOVFF  35,AD
03F28:  MOVFF  34,AC
03F2C:  MOVFF  33,AB
03F30:  CALL   304E
03F34:  MOVFF  03,3E
03F38:  MOVFF  02,3D
03F3C:  MOVFF  01,3C
03F40:  MOVFF  00,3B
....................       }            
....................    } 
....................     
....................    //****** eeroma adým bilgilerini ve açý deðerlerini kaydet *******// 
....................     
....................    ee_write_float(0x00, &x0); delay_ms(10);           // konum degerlerini eproma yaz 
03F44:  CLRF   xA3
03F46:  CLRF   xA5
03F48:  MOVLW  4F
03F4A:  MOVWF  xA4
03F4C:  CALL   032C
03F50:  MOVLW  0A
03F52:  MOVWF  xB1
03F54:  CALL   016E
....................    ee_write_float(0x04, &y0); delay_ms(10);   
03F58:  MOVLW  04
03F5A:  MOVWF  xA3
03F5C:  CLRF   xA5
03F5E:  MOVLW  53
03F60:  MOVWF  xA4
03F62:  CALL   032C
03F66:  MOVLW  0A
03F68:  MOVWF  xB1
03F6A:  CALL   016E
....................    ee_write_float(0x08, &z0); delay_ms(10); 
03F6E:  MOVLW  08
03F70:  MOVWF  xA3
03F72:  CLRF   xA5
03F74:  MOVLW  57
03F76:  MOVWF  xA4
03F78:  CALL   032C
03F7C:  MOVLW  0A
03F7E:  MOVWF  xB1
03F80:  CALL   016E
....................     
....................    //***** adým bilgileri ve zaman deðiþkenlerini sýrayla gönder ****// 
....................     
....................    // A motoruna gönder 
....................    output_low(PIN_C0);     // S0=0 
03F84:  BCF    F94.0
03F86:  BCF    F8B.0
....................    output_low(PIN_C1);     // S1=0 
03F88:  BCF    F94.1
03F8A:  BCF    F8B.1
....................    delay_us(100); 
03F8C:  MOVLW  21
03F8E:  MOVWF  00
03F90:  DECFSZ 00,F
03F92:  BRA    3F90
....................    printf("%ld\r",ma); 
03F94:  MOVLW  41
03F96:  MOVWF  FE9
03F98:  MOVFF  2A,A6
03F9C:  MOVFF  29,A5
03FA0:  MOVFF  28,A4
03FA4:  MOVFF  27,A3
03FA8:  CALL   311C
03FAC:  MOVLW  0D
03FAE:  BTFSS  F9E.4
03FB0:  BRA    3FAE
03FB2:  MOVWF  FAD
....................    printf("%ld\r",ta); 
03FB4:  MOVLW  41
03FB6:  MOVWF  FE9
03FB8:  MOVFF  36,A6
03FBC:  MOVFF  35,A5
03FC0:  MOVFF  34,A4
03FC4:  MOVFF  33,A3
03FC8:  CALL   311C
03FCC:  MOVLW  0D
03FCE:  BTFSS  F9E.4
03FD0:  BRA    3FCE
03FD2:  MOVWF  FAD
....................    delay_ms(5); 
03FD4:  MOVLW  05
03FD6:  MOVWF  xB1
03FD8:  CALL   016E
....................     
....................    // B motoruna gönder 
....................    output_low(PIN_C0);     // S0=0 
03FDC:  BCF    F94.0
03FDE:  BCF    F8B.0
....................    output_high(PIN_C1);    // S1=1 
03FE0:  BCF    F94.1
03FE2:  BSF    F8B.1
....................    delay_us(100); 
03FE4:  MOVLW  21
03FE6:  MOVWF  00
03FE8:  DECFSZ 00,F
03FEA:  BRA    3FE8
....................    printf("%ld\r",mb); 
03FEC:  MOVLW  41
03FEE:  MOVWF  FE9
03FF0:  MOVFF  2E,A6
03FF4:  MOVFF  2D,A5
03FF8:  MOVFF  2C,A4
03FFC:  MOVFF  2B,A3
04000:  CALL   311C
04004:  MOVLW  0D
04006:  BTFSS  F9E.4
04008:  BRA    4006
0400A:  MOVWF  FAD
....................    printf("%ld\r",tb); 
0400C:  MOVLW  41
0400E:  MOVWF  FE9
04010:  MOVFF  3A,A6
04014:  MOVFF  39,A5
04018:  MOVFF  38,A4
0401C:  MOVFF  37,A3
04020:  CALL   311C
04024:  MOVLW  0D
04026:  BTFSS  F9E.4
04028:  BRA    4026
0402A:  MOVWF  FAD
....................    delay_ms(5); 
0402C:  MOVLW  05
0402E:  MOVWF  xB1
04030:  CALL   016E
....................     
....................    // C motoruna gönder 
....................    output_high(PIN_C0);    // S0=1 
04034:  BCF    F94.0
04036:  BSF    F8B.0
....................    output_low(PIN_C1);     // S1=0 
04038:  BCF    F94.1
0403A:  BCF    F8B.1
....................    delay_us(100); 
0403C:  MOVLW  21
0403E:  MOVWF  00
04040:  DECFSZ 00,F
04042:  BRA    4040
....................    printf("%ld\r",mc); 
04044:  MOVLW  41
04046:  MOVWF  FE9
04048:  MOVFF  32,A6
0404C:  MOVFF  31,A5
04050:  MOVFF  30,A4
04054:  MOVFF  2F,A3
04058:  CALL   311C
0405C:  MOVLW  0D
0405E:  BTFSS  F9E.4
04060:  BRA    405E
04062:  MOVWF  FAD
....................    printf("%ld\r",tc); 
04064:  MOVLW  41
04066:  MOVWF  FE9
04068:  MOVFF  3E,A6
0406C:  MOVFF  3D,A5
04070:  MOVFF  3C,A4
04074:  MOVFF  3B,A3
04078:  CALL   311C
0407C:  MOVLW  0D
0407E:  BTFSS  F9E.4
04080:  BRA    407E
04082:  MOVWF  FAD
....................    delay_ms(5); 
04084:  MOVLW  05
04086:  MOVWF  xB1
04088:  CALL   016E
....................     
....................     
....................    // PC ye gönder 
....................    output_high(PIN_C0);    // S0=1 
0408C:  BCF    F94.0
0408E:  BSF    F8B.0
....................    output_high(PIN_C1);    // S1=0 
04090:  BCF    F94.1
04092:  BSF    F8B.1
....................    delay_us(100); 
04094:  MOVLW  21
04096:  MOVWF  00
04098:  DECFSZ 00,F
0409A:  BRA    4098
....................    printf("data gonderildi: mA:%ld, ta:%ld, mB:%ld, tb:%ld, mC:%ld, tc:%ld\n\r", ma, ta, mb, tb, mc, tc); 
0409C:  MOVLW  46
0409E:  MOVWF  FF6
040A0:  MOVLW  00
040A2:  MOVWF  FF7
040A4:  MOVLW  14
040A6:  MOVWF  xA3
040A8:  CALL   321A
040AC:  MOVLW  41
040AE:  MOVWF  FE9
040B0:  MOVFF  2A,A6
040B4:  MOVFF  29,A5
040B8:  MOVFF  28,A4
040BC:  MOVFF  27,A3
040C0:  CALL   311C
040C4:  MOVLW  5D
040C6:  MOVWF  FF6
040C8:  MOVLW  00
040CA:  MOVWF  FF7
040CC:  MOVLW  05
040CE:  MOVWF  xA3
040D0:  CALL   321A
040D4:  MOVLW  41
040D6:  MOVWF  FE9
040D8:  MOVFF  36,A6
040DC:  MOVFF  35,A5
040E0:  MOVFF  34,A4
040E4:  MOVFF  33,A3
040E8:  CALL   311C
040EC:  MOVLW  65
040EE:  MOVWF  FF6
040F0:  MOVLW  00
040F2:  MOVWF  FF7
040F4:  MOVLW  05
040F6:  MOVWF  xA3
040F8:  CALL   321A
040FC:  MOVLW  41
040FE:  MOVWF  FE9
04100:  MOVFF  2E,A6
04104:  MOVFF  2D,A5
04108:  MOVFF  2C,A4
0410C:  MOVFF  2B,A3
04110:  CALL   311C
04114:  MOVLW  6D
04116:  MOVWF  FF6
04118:  MOVLW  00
0411A:  MOVWF  FF7
0411C:  MOVLW  05
0411E:  MOVWF  xA3
04120:  CALL   321A
04124:  MOVLW  41
04126:  MOVWF  FE9
04128:  MOVFF  3A,A6
0412C:  MOVFF  39,A5
04130:  MOVFF  38,A4
04134:  MOVFF  37,A3
04138:  CALL   311C
0413C:  MOVLW  75
0413E:  MOVWF  FF6
04140:  MOVLW  00
04142:  MOVWF  FF7
04144:  MOVLW  05
04146:  MOVWF  xA3
04148:  CALL   321A
0414C:  MOVLW  41
0414E:  MOVWF  FE9
04150:  MOVFF  32,A6
04154:  MOVFF  31,A5
04158:  MOVFF  30,A4
0415C:  MOVFF  2F,A3
04160:  CALL   311C
04164:  MOVLW  7D
04166:  MOVWF  FF6
04168:  MOVLW  00
0416A:  MOVWF  FF7
0416C:  MOVLW  05
0416E:  MOVWF  xA3
04170:  CALL   321A
04174:  MOVLW  41
04176:  MOVWF  FE9
04178:  MOVFF  3E,A6
0417C:  MOVFF  3D,A5
04180:  MOVFF  3C,A4
04184:  MOVFF  3B,A3
04188:  CALL   311C
0418C:  MOVLW  0A
0418E:  BTFSS  F9E.4
04190:  BRA    418E
04192:  MOVWF  FAD
04194:  MOVLW  0D
04196:  BTFSS  F9E.4
04198:  BRA    4196
0419A:  MOVWF  FAD
....................    delay_ms(5); 
0419C:  MOVLW  05
0419E:  MOVWF  xB1
041A0:  CALL   016E
.................... } 
041A4:  GOTO   4A88 (RETURN)
....................  
....................  
.................... //************************* ANA PROGRAM **************************************// 
.................... void main() 
.................... { 
*
04458:  CLRF   FF8
0445A:  BCF    FD0.7
0445C:  CLRF   FEA
0445E:  CLRF   FE9
04460:  BCF    FB8.3
04462:  MOVLW  19
04464:  MOVWF  FAF
04466:  MOVLW  A6
04468:  MOVWF  FAC
0446A:  MOVLW  90
0446C:  MOVWF  FAB
0446E:  MOVLW  01
04470:  MOVWF  0B
04472:  CLRF   0C
04474:  MOVWF  0D
04476:  MOVWF  0E
04478:  CLRF   12
0447A:  CLRF   11
0447C:  CLRF   10
0447E:  CLRF   0F
04480:  CLRF   16
04482:  CLRF   15
04484:  CLRF   14
04486:  CLRF   13
04488:  CLRF   1A
0448A:  CLRF   19
0448C:  CLRF   18
0448E:  CLRF   17
04490:  CLRF   1E
04492:  CLRF   1D
04494:  CLRF   1C
04496:  CLRF   1B
04498:  CLRF   22
0449A:  CLRF   21
0449C:  CLRF   20
0449E:  CLRF   1F
044A0:  CLRF   26
044A2:  CLRF   25
044A4:  CLRF   24
044A6:  CLRF   23
044A8:  CLRF   2A
044AA:  CLRF   29
044AC:  CLRF   28
044AE:  CLRF   27
044B0:  CLRF   2E
044B2:  CLRF   2D
044B4:  CLRF   2C
044B6:  CLRF   2B
044B8:  CLRF   32
044BA:  CLRF   31
044BC:  CLRF   30
044BE:  CLRF   2F
044C0:  CLRF   36
044C2:  CLRF   35
044C4:  CLRF   34
044C6:  CLRF   33
044C8:  CLRF   3A
044CA:  CLRF   39
044CC:  CLRF   38
044CE:  CLRF   37
044D0:  CLRF   3E
044D2:  CLRF   3D
044D4:  CLRF   3C
044D6:  CLRF   3B
044D8:  CLRF   x9E
044DA:  CLRF   x9D
044DC:  CLRF   x9C
044DE:  MOVLW  7F
044E0:  MOVWF  x9B
044E2:  CLRF   xA2
044E4:  CLRF   xA1
044E6:  CLRF   xA0
044E8:  CLRF   x9F
044EA:  MOVF   FC1,W
044EC:  ANDLW  C0
044EE:  IORLW  0F
044F0:  MOVWF  FC1
044F2:  MOVLW  07
044F4:  MOVWF  FB4
044F6:  CLRF   04
044F8:  CLRF   05
....................    setup_PSP(PSP_DISABLED); 
044FA:  BCF    F96.4
....................    setup_spi(SPI_SS_DISABLED); 
044FC:  BCF    FC6.5
044FE:  BCF    F94.5
04500:  BSF    F94.4
04502:  BCF    F94.3
04504:  MOVLW  01
04506:  MOVWF  FC6
04508:  MOVLW  00
0450A:  MOVWF  FC7
....................    setup_timer_1(T1_DISABLED); 
0450C:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
0450E:  MOVWF  FCA
04510:  MOVLW  00
04512:  MOVWF  FCB
....................    setup_adc_ports(NO_ANALOGS); 
04514:  MOVF   FC1,W
04516:  ANDLW  C0
04518:  IORLW  0F
0451A:  MOVWF  FC1
....................    setup_adc(ADC_OFF); 
0451C:  BCF    FC2.0
....................    setup_CCP1(CCP_OFF); 
0451E:  BSF    F94.2
04520:  CLRF   FBD
04522:  CLRF   FB7
04524:  CLRF   FB6
....................    setup_CCP2(CCP_OFF); 
04526:  BSF    F94.1
04528:  CLRF   FBA
....................     
....................    set_tris_a(0b00001111);       // port a giriþ 
0452A:  MOVLW  0F
0452C:  MOVWF  F92
....................    set_tris_c(0b10000000);       // port c çýkýþ RC7-RX giriþ 
0452E:  MOVLW  80
04530:  MOVWF  F94
....................    set_tris_d(0b11111111);       // port d giriþ 
04532:  MOVLW  FF
04534:  MOVWF  F95
....................    set_tris_e(0b00001000);       // port d çýkýþ mclr giriþ 
04536:  BCF    F96.0
04538:  BCF    F96.1
0453A:  BCF    F96.2
0453C:  BSF    F96.3
....................     
....................    output_c(0); 
0453E:  CLRF   F94
04540:  CLRF   F8B
....................    output_d(0); 
04542:  CLRF   F95
04544:  CLRF   F8C
....................    output_e(0); 
04546:  BCF    F96.0
04548:  BCF    F96.1
0454A:  BCF    F96.2
0454C:  BCF    F96.3
0454E:  CLRF   F8D
....................     
....................    lcd_init();    // lcdyi hazýrla 
04550:  GOTO   021C
....................     
.................... //**************** proje bilgilerini ekranda yazdýr***************************// 
....................    lcd_gotoxy(1,1);                                      // 1.sutun 1.satýr 
04554:  MOVLW  01
04556:  MOVWF  xB1
04558:  MOVWF  xB2
0455A:  CALL   026A
....................    printf(lcd_putc, "MARMARA UNI"); 
0455E:  MOVLW  88
04560:  MOVWF  FF6
04562:  MOVLW  00
04564:  MOVWF  FF7
04566:  CALL   030C
....................    delay_ms(500); 
0456A:  MOVLW  02
0456C:  MOVWF  xA3
0456E:  MOVLW  FA
04570:  MOVWF  xB1
04572:  CALL   016E
04576:  DECFSZ xA3,F
04578:  BRA    456E
....................    lcd_gotoxy(1,2);                                      // 1.sutun 2.satýr 
0457A:  MOVLW  01
0457C:  MOVWF  xB1
0457E:  MOVLW  02
04580:  MOVWF  xB2
04582:  CALL   026A
....................    printf(lcd_putc, "MAKINE MUH");    
04586:  MOVLW  94
04588:  MOVWF  FF6
0458A:  MOVLW  00
0458C:  MOVWF  FF7
0458E:  CALL   030C
....................    delay_ms(500); 
04592:  MOVLW  02
04594:  MOVWF  xA3
04596:  MOVLW  FA
04598:  MOVWF  xB1
0459A:  CALL   016E
0459E:  DECFSZ xA3,F
045A0:  BRA    4596
....................    lcd_gotoxy(1,3);                                      // 1.sutun 3.satýr 
045A2:  MOVLW  01
045A4:  MOVWF  xB1
045A6:  MOVLW  03
045A8:  MOVWF  xB2
045AA:  CALL   026A
....................    printf(lcd_putc, "DELTA ROBOT PROJ"); 
045AE:  MOVLW  A0
045B0:  MOVWF  FF6
045B2:  MOVLW  00
045B4:  MOVWF  FF7
045B6:  CALL   030C
....................    delay_ms(500); 
045BA:  MOVLW  02
045BC:  MOVWF  xA3
045BE:  MOVLW  FA
045C0:  MOVWF  xB1
045C2:  CALL   016E
045C6:  DECFSZ xA3,F
045C8:  BRA    45BE
....................    lcd_gotoxy(1,4);                                      // 1.sutun 4.satýr 
045CA:  MOVLW  01
045CC:  MOVWF  xB1
045CE:  MOVLW  04
045D0:  MOVWF  xB2
045D2:  CALL   026A
....................    printf(lcd_putc, "04.05.2011"); 
045D6:  MOVLW  B2
045D8:  MOVWF  FF6
045DA:  MOVLW  00
045DC:  MOVWF  FF7
045DE:  CALL   030C
....................    delay_ms(1500); 
045E2:  MOVLW  06
045E4:  MOVWF  xA3
045E6:  MOVLW  FA
045E8:  MOVWF  xB1
045EA:  CALL   016E
045EE:  DECFSZ xA3,F
045F0:  BRA    45E6
....................     
....................    lcd_send_byte(0,0x01);                                // lcd ekraný temzile 
045F2:  CLRF   xB4
045F4:  MOVLW  01
045F6:  MOVWF  xB5
045F8:  CALL   01E6
....................     
.................... //************************** robot geometri **********************************// 
....................    e = 109.12;     // end effector 
045FC:  MOVLW  71
045FE:  MOVWF  42
04600:  MOVLW  3D
04602:  MOVWF  41
04604:  MOVLW  5A
04606:  MOVWF  40
04608:  MOVLW  85
0460A:  MOVWF  3F
....................    f = 346.41;     // base 
0460C:  MOVLW  7B
0460E:  MOVWF  46
04610:  MOVLW  34
04612:  MOVWF  45
04614:  MOVLW  2D
04616:  MOVWF  44
04618:  MOVLW  87
0461A:  MOVWF  43
....................    re = 323.59;    // rod 
0461C:  MOVLW  85
0461E:  MOVWF  4A
04620:  MOVLW  CB
04622:  MOVWF  49
04624:  MOVLW  21
04626:  MOVWF  48
04628:  MOVLW  87
0462A:  MOVWF  47
....................    rf = 133.09;    // arm 
0462C:  MOVLW  0A
0462E:  MOVWF  4E
04630:  MOVLW  17
04632:  MOVWF  4D
04634:  MOVLW  05
04636:  MOVWF  4C
04638:  MOVLW  86
0463A:  MOVWF  4B
....................     
....................    tahvil_orani = 0.008948849; 
0463C:  MOVLW  31
0463E:  MOVWF  xA2
04640:  MOVLW  9E
04642:  MOVWF  xA1
04644:  MOVLW  12
04646:  MOVWF  xA0
04648:  MOVLW  78
0464A:  MOVWF  x9F
....................  
.................... //***************** robotu kalibre et ****************************************// 
....................  
....................    if(input(PIN_A2)==0)                         // kalibre butonu RA2 basýlýmý 
0464C:  BSF    F92.2
0464E:  BTFSC  F80.2
04650:  BRA    47AA
....................    { 
....................       theta1=theta2=theta3=0; 
04652:  CLRF   x86
04654:  CLRF   x85
04656:  CLRF   x84
04658:  CLRF   x83
0465A:  MOVFF  86,82
0465E:  MOVFF  85,81
04662:  MOVFF  84,80
04666:  MOVFF  83,7F
0466A:  MOVFF  82,7E
0466E:  MOVFF  81,7D
04672:  MOVFF  80,7C
04676:  MOVFF  7F,7B
....................       ma=mb=mc=0; 
0467A:  CLRF   32
0467C:  CLRF   31
0467E:  CLRF   30
04680:  CLRF   2F
04682:  MOVFF  32,2E
04686:  MOVFF  31,2D
0468A:  MOVFF  30,2C
0468E:  MOVFF  2F,2B
04692:  MOVFF  2E,2A
04696:  MOVFF  2D,29
0469A:  MOVFF  2C,28
0469E:  MOVFF  2B,27
....................       ta=tb=tc=0; 
046A2:  CLRF   3E
046A4:  CLRF   3D
046A6:  CLRF   3C
046A8:  CLRF   3B
046AA:  MOVFF  3E,3A
046AE:  MOVFF  3D,39
046B2:  MOVFF  3C,38
046B6:  MOVFF  3B,37
046BA:  MOVFF  3A,36
046BE:  MOVFF  39,35
046C2:  MOVFF  38,34
046C6:  MOVFF  37,33
....................       x0=0; 
046CA:  CLRF   52
046CC:  CLRF   51
046CE:  CLRF   50
046D0:  CLRF   4F
....................       y0=0; 
046D2:  CLRF   56
046D4:  CLRF   55
046D6:  CLRF   54
046D8:  CLRF   53
....................       z0=-253.1246; 
046DA:  MOVLW  E6
046DC:  MOVWF  5A
046DE:  MOVLW  1F
046E0:  MOVWF  59
046E2:  MOVLW  FD
046E4:  MOVWF  58
046E6:  MOVLW  86
046E8:  MOVWF  57
....................        
....................       ee_write_float(0x00, &x0); delay_ms(10);           // rototun sýfýr pozisyonunda  
046EA:  CLRF   xA3
046EC:  CLRF   xA5
046EE:  MOVLW  4F
046F0:  MOVWF  xA4
046F2:  CALL   032C
046F6:  MOVLW  0A
046F8:  MOVWF  xB1
046FA:  CALL   016E
....................       ee_write_float(0x04, &y0); delay_ms(10);   
046FE:  MOVLW  04
04700:  MOVWF  xA3
04702:  CLRF   xA5
04704:  MOVLW  53
04706:  MOVWF  xA4
04708:  CALL   032C
0470C:  MOVLW  0A
0470E:  MOVWF  xB1
04710:  CALL   016E
....................       ee_write_float(0x08, &z0); delay_ms(10); 
04714:  MOVLW  08
04716:  MOVWF  xA3
04718:  CLRF   xA5
0471A:  MOVLW  57
0471C:  MOVWF  xA4
0471E:  CALL   032C
04722:  MOVLW  0A
04724:  MOVWF  xB1
04726:  CALL   016E
....................        
....................       lcd_gotoxy(1,1); 
0472A:  MOVLW  01
0472C:  MOVWF  xB1
0472E:  MOVWF  xB2
04730:  CALL   026A
....................       printf(lcd_putc, "Kalibre edildi."); 
04734:  MOVLW  BE
04736:  MOVWF  FF6
04738:  MOVLW  00
0473A:  MOVWF  FF7
0473C:  CALL   030C
....................       delay_ms(200); 
04740:  MOVLW  C8
04742:  MOVWF  xB1
04744:  CALL   016E
....................       lcd_gotoxy(1,2); 
04748:  MOVLW  01
0474A:  MOVWF  xB1
0474C:  MOVLW  02
0474E:  MOVWF  xB2
04750:  CALL   026A
....................       printf(lcd_putc, "Robot suanda"); 
04754:  MOVLW  CE
04756:  MOVWF  FF6
04758:  MOVLW  00
0475A:  MOVWF  FF7
0475C:  CALL   030C
....................       lcd_gotoxy(1,3); 
04760:  MOVLW  01
04762:  MOVWF  xB1
04764:  MOVLW  03
04766:  MOVWF  xB2
04768:  CALL   026A
....................       printf(lcd_putc, "sifir pozisyo-"); 
0476C:  MOVLW  DC
0476E:  MOVWF  FF6
04770:  MOVLW  00
04772:  MOVWF  FF7
04774:  CALL   030C
....................       lcd_gotoxy(1,4); 
04778:  MOVLW  01
0477A:  MOVWF  xB1
0477C:  MOVLW  04
0477E:  MOVWF  xB2
04780:  CALL   026A
....................       printf(lcd_putc, "nunda olmali."); 
04784:  MOVLW  EC
04786:  MOVWF  FF6
04788:  MOVLW  00
0478A:  MOVWF  FF7
0478C:  CALL   030C
....................       delay_ms(3000); 
04790:  MOVLW  0C
04792:  MOVWF  xA3
04794:  MOVLW  FA
04796:  MOVWF  xB1
04798:  CALL   016E
0479C:  DECFSZ xA3,F
0479E:  BRA    4794
....................        
....................       lcd_send_byte(0, 0x01); 
047A0:  CLRF   xB4
047A2:  MOVLW  01
047A4:  MOVWF  xB5
047A6:  CALL   01E6
....................    } 
....................  
.................... //***************** robotun konumunu eepromdan oku ***************************// 
....................     
....................    ee_read_float(0x00, &x0); 
047AA:  CLRF   xA3
047AC:  CLRF   xA5
047AE:  MOVLW  4F
047B0:  MOVWF  xA4
047B2:  CALL   0382
....................    delay_ms(5); 
047B6:  MOVLW  05
047B8:  MOVWF  xB1
047BA:  CALL   016E
....................    ee_read_float(0x04, &y0); 
047BE:  MOVLW  04
047C0:  MOVWF  xA3
047C2:  CLRF   xA5
047C4:  MOVLW  53
047C6:  MOVWF  xA4
047C8:  CALL   0382
....................    delay_ms(5); 
047CC:  MOVLW  05
047CE:  MOVWF  xB1
047D0:  CALL   016E
....................    ee_read_float(0x08, &z0); 
047D4:  MOVLW  08
047D6:  MOVWF  xA3
047D8:  CLRF   xA5
047DA:  MOVLW  57
047DC:  MOVWF  xA4
047DE:  CALL   0382
....................    delay_ms(5); 
047E2:  MOVLW  05
047E4:  MOVWF  xB1
047E6:  CALL   016E
....................     
....................    hesapla_aci(); 
047EA:  CALL   136A
....................    degisim=1; 
047EE:  MOVLW  01
047F0:  MOVWF  0B
....................  
.................... //******************************* Ana Döngü **********************************// 
....................    while(TRUE) 
....................    { 
....................    //************************* buton taramasý ********************************//      
....................       if(input(PIN_A3)==1) 
047F2:  BSF    F92.3
047F4:  BTFSS  F80.3
047F6:  BRA    49CC
....................       { 
....................        
....................          if(input(PIN_D0)==0)                         // +x doðrultusunda 1mm git 
047F8:  BSF    F95.0
047FA:  BTFSC  F83.0
047FC:  BRA    4846
....................          { 
....................             delay_ms(100);          
047FE:  MOVLW  64
04800:  MOVWF  xB1
04802:  CALL   016E
....................             x0+=hassasiyet;  
04806:  BCF    FD8.1
04808:  MOVFF  52,E4
0480C:  MOVFF  51,E3
04810:  MOVFF  50,E2
04814:  MOVFF  4F,E1
04818:  MOVFF  9E,E8
0481C:  MOVFF  9D,E7
04820:  MOVFF  9C,E6
04824:  MOVFF  9B,E5
04828:  CALL   04B6
0482C:  MOVFF  03,52
04830:  MOVFF  02,51
04834:  MOVFF  01,50
04838:  MOVFF  00,4F
....................             degisim=1; 
0483C:  MOVLW  01
0483E:  MOVWF  0B
....................             degisim_motor=1; 
04840:  MOVWF  0C
....................             hesapla_aci(); 
04842:  CALL   136A
....................          }                    
....................          if(input(PIN_D1)==0)                         // -x doðrultusunda 1mm git 
04846:  BSF    F95.1
04848:  BTFSC  F83.1
0484A:  BRA    4894
....................          { 
....................             delay_ms(100); 
0484C:  MOVLW  64
0484E:  MOVWF  xB1
04850:  CALL   016E
....................             x0-=hassasiyet; 
04854:  BSF    FD8.1
04856:  MOVFF  52,E4
0485A:  MOVFF  51,E3
0485E:  MOVFF  50,E2
04862:  MOVFF  4F,E1
04866:  MOVFF  9E,E8
0486A:  MOVFF  9D,E7
0486E:  MOVFF  9C,E6
04872:  MOVFF  9B,E5
04876:  CALL   04B6
0487A:  MOVFF  03,52
0487E:  MOVFF  02,51
04882:  MOVFF  01,50
04886:  MOVFF  00,4F
....................             degisim=1; 
0488A:  MOVLW  01
0488C:  MOVWF  0B
....................             degisim_motor=1; 
0488E:  MOVWF  0C
....................             hesapla_aci();          
04890:  CALL   136A
....................          } 
....................          if(input(PIN_D2)==0)                         // +y doðrultusunda 1mm git 
04894:  BSF    F95.2
04896:  BTFSC  F83.2
04898:  BRA    48E2
....................          { 
....................             delay_ms(100); 
0489A:  MOVLW  64
0489C:  MOVWF  xB1
0489E:  CALL   016E
....................             y0+=hassasiyet; 
048A2:  BCF    FD8.1
048A4:  MOVFF  56,E4
048A8:  MOVFF  55,E3
048AC:  MOVFF  54,E2
048B0:  MOVFF  53,E1
048B4:  MOVFF  9E,E8
048B8:  MOVFF  9D,E7
048BC:  MOVFF  9C,E6
048C0:  MOVFF  9B,E5
048C4:  CALL   04B6
048C8:  MOVFF  03,56
048CC:  MOVFF  02,55
048D0:  MOVFF  01,54
048D4:  MOVFF  00,53
....................             degisim=1; 
048D8:  MOVLW  01
048DA:  MOVWF  0B
....................             degisim_motor=1; 
048DC:  MOVWF  0C
....................             hesapla_aci(); 
048DE:  CALL   136A
....................          } 
....................          if(input(PIN_D3)==0)                         // -y doðrultusunda 1mm git 
048E2:  BSF    F95.3
048E4:  BTFSC  F83.3
048E6:  BRA    4930
....................          { 
....................             delay_ms(100); 
048E8:  MOVLW  64
048EA:  MOVWF  xB1
048EC:  CALL   016E
....................             y0-=hassasiyet; 
048F0:  BSF    FD8.1
048F2:  MOVFF  56,E4
048F6:  MOVFF  55,E3
048FA:  MOVFF  54,E2
048FE:  MOVFF  53,E1
04902:  MOVFF  9E,E8
04906:  MOVFF  9D,E7
0490A:  MOVFF  9C,E6
0490E:  MOVFF  9B,E5
04912:  CALL   04B6
04916:  MOVFF  03,56
0491A:  MOVFF  02,55
0491E:  MOVFF  01,54
04922:  MOVFF  00,53
....................             degisim=1; 
04926:  MOVLW  01
04928:  MOVWF  0B
....................             degisim_motor=1; 
0492A:  MOVWF  0C
....................             hesapla_aci();     
0492C:  CALL   136A
....................          } 
....................          if(input(PIN_D4)==0)                         // +z doðrultusunda 1mm git 
04930:  BSF    F95.4
04932:  BTFSC  F83.4
04934:  BRA    497E
....................          { 
....................             delay_ms(100); 
04936:  MOVLW  64
04938:  MOVWF  xB1
0493A:  CALL   016E
....................             z0+=hassasiyet; 
0493E:  BCF    FD8.1
04940:  MOVFF  5A,E4
04944:  MOVFF  59,E3
04948:  MOVFF  58,E2
0494C:  MOVFF  57,E1
04950:  MOVFF  9E,E8
04954:  MOVFF  9D,E7
04958:  MOVFF  9C,E6
0495C:  MOVFF  9B,E5
04960:  CALL   04B6
04964:  MOVFF  03,5A
04968:  MOVFF  02,59
0496C:  MOVFF  01,58
04970:  MOVFF  00,57
....................             degisim=1; 
04974:  MOVLW  01
04976:  MOVWF  0B
....................             degisim_motor=1; 
04978:  MOVWF  0C
....................             hesapla_aci();       
0497A:  CALL   136A
....................          } 
....................          if(input(PIN_D5)==0)                         // -z doðrultusunda 1mm git 
0497E:  BSF    F95.5
04980:  BTFSC  F83.5
04982:  BRA    49CC
....................          { 
....................             delay_ms(100); 
04984:  MOVLW  64
04986:  MOVWF  xB1
04988:  CALL   016E
....................             z0-=hassasiyet; 
0498C:  BSF    FD8.1
0498E:  MOVFF  5A,E4
04992:  MOVFF  59,E3
04996:  MOVFF  58,E2
0499A:  MOVFF  57,E1
0499E:  MOVFF  9E,E8
049A2:  MOVFF  9D,E7
049A6:  MOVFF  9C,E6
049AA:  MOVFF  9B,E5
049AE:  CALL   04B6
049B2:  MOVFF  03,5A
049B6:  MOVFF  02,59
049BA:  MOVFF  01,58
049BE:  MOVFF  00,57
....................             degisim=1; 
049C2:  MOVLW  01
049C4:  MOVWF  0B
....................             degisim_motor=1; 
049C6:  MOVWF  0C
....................             hesapla_aci();  
049C8:  CALL   136A
....................          } 
....................       } 
....................        
....................       if(input(PIN_D6)==0)                         // ekraný deðiþtir 
049CC:  BSF    F95.6
049CE:  BTFSC  F83.6
049D0:  BRA    49F2
....................       { 
....................          delay_ms(500);                            // butondaki arký söndür 
049D2:  MOVLW  02
049D4:  MOVWF  xA3
049D6:  MOVLW  FA
049D8:  MOVWF  xB1
049DA:  CALL   016E
049DE:  DECFSZ xA3,F
049E0:  BRA    49D6
....................          lcd_ekran = lcd_ekran + 1; 
049E2:  MOVLW  01
049E4:  ADDWF  0D,F
....................          degisim=1; 
049E6:  MOVWF  0B
....................          if(lcd_ekran == 5){lcd_ekran=1;}          
049E8:  MOVF   0D,W
049EA:  SUBLW  05
049EC:  BNZ   49F2
049EE:  MOVLW  01
049F0:  MOVWF  0D
....................       } 
....................        
....................       if(input(PIN_D7)==0)                         // hassasiyet arttýr butonu 
049F2:  BSF    F95.7
049F4:  BTFSC  F83.7
049F6:  BRA    4A78
....................       { 
....................          delay_ms(500);                            // butondaki arký söndür aksi halde artýs muazzam boyutta olur 
049F8:  MOVLW  02
049FA:  MOVWF  xA3
049FC:  MOVLW  FA
049FE:  MOVWF  xB1
04A00:  CALL   016E
04A04:  DECFSZ xA3,F
04A06:  BRA    49FC
....................          i+=1;                                     // 4 kademeli hassasiyet artýmý 
04A08:  MOVLW  01
04A0A:  ADDWF  0E,F
....................          if(i >= 6){i=1;}                           
04A0C:  MOVF   0E,W
04A0E:  SUBLW  05
04A10:  BC    4A16
04A12:  MOVLW  01
04A14:  MOVWF  0E
....................          switch(i) 
....................          { 
04A16:  MOVLW  01
04A18:  SUBWF  0E,W
04A1A:  ADDLW  FB
04A1C:  BC    4A70
04A1E:  ADDLW  05
04A20:  GOTO   4DD0
....................             case 1: hassasiyet = 0.01; break;   // 10 micron 
04A24:  MOVLW  0A
04A26:  MOVWF  x9E
04A28:  MOVLW  D7
04A2A:  MOVWF  x9D
04A2C:  MOVLW  23
04A2E:  MOVWF  x9C
04A30:  MOVLW  78
04A32:  MOVWF  x9B
04A34:  BRA    4A70
....................             case 2: hassasiyet = 0.1;  break; 
04A36:  MOVLW  CD
04A38:  MOVWF  x9E
04A3A:  MOVLW  CC
04A3C:  MOVWF  x9D
04A3E:  MOVLW  4C
04A40:  MOVWF  x9C
04A42:  MOVLW  7B
04A44:  MOVWF  x9B
04A46:  BRA    4A70
....................             case 3: hassasiyet = 1;    break; 
04A48:  CLRF   x9E
04A4A:  CLRF   x9D
04A4C:  CLRF   x9C
04A4E:  MOVLW  7F
04A50:  MOVWF  x9B
04A52:  BRA    4A70
....................             case 4: hassasiyet = 10;   break; 
04A54:  CLRF   x9E
04A56:  CLRF   x9D
04A58:  MOVLW  20
04A5A:  MOVWF  x9C
04A5C:  MOVLW  82
04A5E:  MOVWF  x9B
04A60:  BRA    4A70
....................             case 5: hassasiyet = 100;  break;   // 10 cm 
04A62:  CLRF   x9E
04A64:  CLRF   x9D
04A66:  MOVLW  48
04A68:  MOVWF  x9C
04A6A:  MOVLW  85
04A6C:  MOVWF  x9B
04A6E:  BRA    4A70
....................          } 
....................          degisim=1; 
04A70:  MOVLW  01
04A72:  MOVWF  0B
....................          lcd_ekran=4; 
04A74:  MOVLW  04
04A76:  MOVWF  0D
....................       } 
....................  
....................       //***** deðiþim oldugunda ekraný yenile ve bilgileri eproma kaydet *****// 
....................       if(degisim == 1) 
04A78:  DECFSZ 0B,W
04A7A:  BRA    4DCC
....................       { 
....................          degisim = 0;                                          
04A7C:  CLRF   0B
....................          //******** step motor kontrol ***************************************// 
....................          if(degisim_motor == 1)     // sadece motor verileri deðiþtiginde 
04A7E:  DECFSZ 0C,W
04A80:  BRA    4A88
....................          { 
....................             degisim_motor = 0; 
04A82:  CLRF   0C
....................             motor_hareket();        // motoru hareket ettir 
04A84:  GOTO   323A
....................          }            
....................          //******************** Ekran Görünümü *******************************//          
....................          switch(lcd_ekran)                            // istenilen ekranlarý göster  
....................          { 
04A88:  MOVLW  01
04A8A:  SUBWF  0D,W
04A8C:  ADDLW  FC
04A8E:  BTFSC  FD8.0
04A90:  BRA    4DCC
04A92:  ADDLW  04
04A94:  GOTO   4DF4
....................             case 1:  // posiyon bilgilerini göster 
....................                      degisim = 0; 
04A98:  CLRF   0B
....................                      lcd_send_byte(0,0x01);                    // ekraný temizle 
04A9A:  CLRF   xB4
04A9C:  MOVLW  01
04A9E:  MOVWF  xB5
04AA0:  CALL   01E6
....................                      lcd_gotoxy(1,1);                          // SUTUN , SATIR 
04AA4:  MOVLW  01
04AA6:  MOVWF  xB1
04AA8:  MOVWF  xB2
04AAA:  CALL   026A
....................                      printf(lcd_putc, "POSITION (mm)");      
04AAE:  MOVLW  FA
04AB0:  MOVWF  FF6
04AB2:  MOVLW  00
04AB4:  MOVWF  FF7
04AB6:  CALL   030C
....................              
....................                      lcd_gotoxy(1,2); 
04ABA:  MOVLW  01
04ABC:  MOVWF  xB1
04ABE:  MOVLW  02
04AC0:  MOVWF  xB2
04AC2:  CALL   026A
....................                      printf(lcd_putc, "X: %4.4f", x0);         // %4.4f= float türünden bir sayýyý xxxx.xxxx þeklinde ekrana yansýtýr 
04AC6:  MOVLW  58
04AC8:  MOVWF  xB0
04ACA:  CALL   02C2
04ACE:  MOVLW  3A
04AD0:  MOVWF  xB0
04AD2:  CALL   02C2
04AD6:  MOVLW  20
04AD8:  MOVWF  xB0
04ADA:  CALL   02C2
04ADE:  MOVLW  89
04AE0:  MOVWF  FE9
04AE2:  MOVFF  52,A6
04AE6:  MOVFF  51,A5
04AEA:  MOVFF  50,A4
04AEE:  MOVFF  4F,A3
04AF2:  MOVLW  04
04AF4:  MOVWF  xA7
04AF6:  CALL   41A8
....................                       
....................                      lcd_gotoxy(1,3); 
04AFA:  MOVLW  01
04AFC:  MOVWF  xB1
04AFE:  MOVLW  03
04B00:  MOVWF  xB2
04B02:  CALL   026A
....................                      printf(lcd_putc, "Y: %4.4f", y0); 
04B06:  MOVLW  59
04B08:  MOVWF  xB0
04B0A:  CALL   02C2
04B0E:  MOVLW  3A
04B10:  MOVWF  xB0
04B12:  CALL   02C2
04B16:  MOVLW  20
04B18:  MOVWF  xB0
04B1A:  CALL   02C2
04B1E:  MOVLW  89
04B20:  MOVWF  FE9
04B22:  MOVFF  56,A6
04B26:  MOVFF  55,A5
04B2A:  MOVFF  54,A4
04B2E:  MOVFF  53,A3
04B32:  MOVLW  04
04B34:  MOVWF  xA7
04B36:  CALL   41A8
....................                       
....................                      lcd_gotoxy(1,4); 
04B3A:  MOVLW  01
04B3C:  MOVWF  xB1
04B3E:  MOVLW  04
04B40:  MOVWF  xB2
04B42:  CALL   026A
....................                      printf(lcd_putc, "Z: %4.4f", z0);  break; 
04B46:  MOVLW  5A
04B48:  MOVWF  xB0
04B4A:  CALL   02C2
04B4E:  MOVLW  3A
04B50:  MOVWF  xB0
04B52:  CALL   02C2
04B56:  MOVLW  20
04B58:  MOVWF  xB0
04B5A:  CALL   02C2
04B5E:  MOVLW  89
04B60:  MOVWF  FE9
04B62:  MOVFF  5A,A6
04B66:  MOVFF  59,A5
04B6A:  MOVFF  58,A4
04B6E:  MOVFF  57,A3
04B72:  MOVLW  04
04B74:  MOVWF  xA7
04B76:  CALL   41A8
04B7A:  BRA    4DCC
....................                       
....................             case 2:  // acý bilgilerini göster 
....................                      degisim=0; 
04B7C:  CLRF   0B
....................                      lcd_send_byte(0,0x01);                    // ekraný temizle 
04B7E:  CLRF   xB4
04B80:  MOVLW  01
04B82:  MOVWF  xB5
04B84:  CALL   01E6
....................                      lcd_gotoxy(1,1);                          // SUTUN , SATIR 
04B88:  MOVLW  01
04B8A:  MOVWF  xB1
04B8C:  MOVWF  xB2
04B8E:  CALL   026A
....................                      printf(lcd_putc, "ANGLE (derece)"); 
04B92:  MOVLW  08
04B94:  MOVWF  FF6
04B96:  MOVLW  01
04B98:  MOVWF  FF7
04B9A:  CALL   030C
....................                       
....................                      lcd_gotoxy(1,2); 
04B9E:  MOVLW  01
04BA0:  MOVWF  xB1
04BA2:  MOVLW  02
04BA4:  MOVWF  xB2
04BA6:  CALL   026A
....................                      printf(lcd_putc, "A: %4.6f", theta1);        // %f : float türünden 
04BAA:  MOVLW  41
04BAC:  MOVWF  xB0
04BAE:  CALL   02C2
04BB2:  MOVLW  3A
04BB4:  MOVWF  xB0
04BB6:  CALL   02C2
04BBA:  MOVLW  20
04BBC:  MOVWF  xB0
04BBE:  CALL   02C2
04BC2:  MOVLW  89
04BC4:  MOVWF  FE9
04BC6:  MOVFF  7E,A6
04BCA:  MOVFF  7D,A5
04BCE:  MOVFF  7C,A4
04BD2:  MOVFF  7B,A3
04BD6:  MOVLW  06
04BD8:  MOVWF  xA7
04BDA:  CALL   41A8
....................                       
....................                      lcd_gotoxy(1,3); 
04BDE:  MOVLW  01
04BE0:  MOVWF  xB1
04BE2:  MOVLW  03
04BE4:  MOVWF  xB2
04BE6:  CALL   026A
....................                      printf(lcd_putc, "B: %4.6f", theta2);        // %E : virgülden sonra 6 hane ve E00 seklinde gösterimi 
04BEA:  MOVLW  42
04BEC:  MOVWF  xB0
04BEE:  CALL   02C2
04BF2:  MOVLW  3A
04BF4:  MOVWF  xB0
04BF6:  CALL   02C2
04BFA:  MOVLW  20
04BFC:  MOVWF  xB0
04BFE:  CALL   02C2
04C02:  MOVLW  89
04C04:  MOVWF  FE9
04C06:  MOVFF  82,A6
04C0A:  MOVFF  81,A5
04C0E:  MOVFF  80,A4
04C12:  MOVFF  7F,A3
04C16:  MOVLW  06
04C18:  MOVWF  xA7
04C1A:  CALL   41A8
....................                       
....................                      lcd_gotoxy(1,4); 
04C1E:  MOVLW  01
04C20:  MOVWF  xB1
04C22:  MOVLW  04
04C24:  MOVWF  xB2
04C26:  CALL   026A
....................                      printf(lcd_putc, "B: %4.6f", theta3);  break; 
04C2A:  MOVLW  42
04C2C:  MOVWF  xB0
04C2E:  CALL   02C2
04C32:  MOVLW  3A
04C34:  MOVWF  xB0
04C36:  CALL   02C2
04C3A:  MOVLW  20
04C3C:  MOVWF  xB0
04C3E:  CALL   02C2
04C42:  MOVLW  89
04C44:  MOVWF  FE9
04C46:  MOVFF  86,A6
04C4A:  MOVFF  85,A5
04C4E:  MOVFF  84,A4
04C52:  MOVFF  83,A3
04C56:  MOVLW  06
04C58:  MOVWF  xA7
04C5A:  CALL   41A8
04C5E:  BRA    4DCC
....................                       
....................             case 3:  // step motor adým bilgilerini göster 
....................                      degisim=0; 
04C60:  CLRF   0B
....................                      lcd_send_byte(0,0x01); 
04C62:  CLRF   xB4
04C64:  MOVLW  01
04C66:  MOVWF  xB5
04C68:  CALL   01E6
....................                      lcd_gotoxy(1,1); 
04C6C:  MOVLW  01
04C6E:  MOVWF  xB1
04C70:  MOVWF  xB2
04C72:  CALL   026A
....................                      printf(lcd_putc, "STEP COUNT(step)"); 
04C76:  MOVLW  18
04C78:  MOVWF  FF6
04C7A:  MOVLW  01
04C7C:  MOVWF  FF7
04C7E:  CALL   030C
....................              
....................                      lcd_gotoxy(1,2); 
04C82:  MOVLW  01
04C84:  MOVWF  xB1
04C86:  MOVLW  02
04C88:  MOVWF  xB2
04C8A:  CALL   026A
....................                      printf(lcd_putc, "MA: %ld", mA_step);      // %ld long ifade decimal türünden 
04C8E:  MOVLW  2A
04C90:  MOVWF  FF6
04C92:  MOVLW  01
04C94:  MOVWF  FF7
04C96:  MOVLW  04
04C98:  MOVWF  xA3
04C9A:  CALL   4336
04C9E:  MOVLW  41
04CA0:  MOVWF  FE9
04CA2:  MOVFF  12,A6
04CA6:  MOVFF  11,A5
04CAA:  MOVFF  10,A4
04CAE:  MOVFF  0F,A3
04CB2:  CALL   4356
....................                       
....................                      lcd_gotoxy(1,3); 
04CB6:  MOVLW  01
04CB8:  MOVWF  xB1
04CBA:  MOVLW  03
04CBC:  MOVWF  xB2
04CBE:  CALL   026A
....................                      printf(lcd_putc, "MB: %ld", mB_step); 
04CC2:  MOVLW  32
04CC4:  MOVWF  FF6
04CC6:  MOVLW  01
04CC8:  MOVWF  FF7
04CCA:  MOVLW  04
04CCC:  MOVWF  xA3
04CCE:  CALL   4336
04CD2:  MOVLW  41
04CD4:  MOVWF  FE9
04CD6:  MOVFF  16,A6
04CDA:  MOVFF  15,A5
04CDE:  MOVFF  14,A4
04CE2:  MOVFF  13,A3
04CE6:  CALL   4356
....................                       
....................                      lcd_gotoxy(1,4); 
04CEA:  MOVLW  01
04CEC:  MOVWF  xB1
04CEE:  MOVLW  04
04CF0:  MOVWF  xB2
04CF2:  CALL   026A
....................                      printf(lcd_putc, "MC: %ld", mC_step);  break; 
04CF6:  MOVLW  3A
04CF8:  MOVWF  FF6
04CFA:  MOVLW  01
04CFC:  MOVWF  FF7
04CFE:  MOVLW  04
04D00:  MOVWF  xA3
04D02:  CALL   4336
04D06:  MOVLW  41
04D08:  MOVWF  FE9
04D0A:  MOVFF  1A,A6
04D0E:  MOVFF  19,A5
04D12:  MOVFF  18,A4
04D16:  MOVFF  17,A3
04D1A:  CALL   4356
04D1E:  BRA    4DCC
....................                       
....................             case 4:  // hassasiyet bilgisini göster 
....................                      degisim=0; 
04D20:  CLRF   0B
....................                      lcd_send_byte(0,0x01); 
04D22:  CLRF   xB4
04D24:  MOVLW  01
04D26:  MOVWF  xB5
04D28:  CALL   01E6
....................                      lcd_gotoxy(1,1); 
04D2C:  MOVLW  01
04D2E:  MOVWF  xB1
04D30:  MOVWF  xB2
04D32:  CALL   026A
....................                      printf(lcd_putc, "HASSASIYET"); 
04D36:  MOVLW  42
04D38:  MOVWF  FF6
04D3A:  MOVLW  01
04D3C:  MOVWF  FF7
04D3E:  CALL   030C
....................                       
....................                      lcd_gotoxy(1,2); 
04D42:  MOVLW  01
04D44:  MOVWF  xB1
04D46:  MOVLW  02
04D48:  MOVWF  xB2
04D4A:  CALL   026A
....................                      printf(lcd_putc, "0.01 < H < 100"); 
04D4E:  MOVLW  4E
04D50:  MOVWF  FF6
04D52:  MOVLW  01
04D54:  MOVWF  FF7
04D56:  CALL   030C
....................                       
....................                      lcd_gotoxy(1,3); 
04D5A:  MOVLW  01
04D5C:  MOVWF  xB1
04D5E:  MOVLW  03
04D60:  MOVWF  xB2
04D62:  CALL   026A
....................                      printf(lcd_putc, "arasinda olmali"); 
04D66:  MOVLW  5E
04D68:  MOVWF  FF6
04D6A:  MOVLW  01
04D6C:  MOVWF  FF7
04D6E:  CALL   030C
....................                       
....................                      lcd_gotoxy(1,4); 
04D72:  MOVLW  01
04D74:  MOVWF  xB1
04D76:  MOVLW  04
04D78:  MOVWF  xB2
04D7A:  CALL   026A
....................                      printf(lcd_putc, "H: %f mm", hassasiyet); break; 
04D7E:  MOVLW  48
04D80:  MOVWF  xB0
04D82:  CALL   02C2
04D86:  MOVLW  3A
04D88:  MOVWF  xB0
04D8A:  CALL   02C2
04D8E:  MOVLW  20
04D90:  MOVWF  xB0
04D92:  CALL   02C2
04D96:  MOVLW  89
04D98:  MOVWF  FE9
04D9A:  MOVFF  9E,A6
04D9E:  MOVFF  9D,A5
04DA2:  MOVFF  9C,A4
04DA6:  MOVFF  9B,A3
04DAA:  MOVLW  02
04DAC:  MOVWF  xA7
04DAE:  CALL   41A8
04DB2:  MOVLW  20
04DB4:  MOVWF  xB0
04DB6:  CALL   02C2
04DBA:  MOVLW  6D
04DBC:  MOVWF  xB0
04DBE:  CALL   02C2
04DC2:  MOVLW  6D
04DC4:  MOVWF  xB0
04DC6:  CALL   02C2
04DCA:  BRA    4DCC
....................           
....................          } 
....................       } 
....................    } 
04DCC:  BRA    47F2
.................... } 
....................  
04DCE:  SLEEP 

Configuration Fuses:
   Word  1: C100   XT IESO FCMEN
   Word  2: 1E19   NOBROWNOUT NOWDT BORV21 NOPUT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
