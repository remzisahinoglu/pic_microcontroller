CCS PCH C Compiler, Version 3.249, 28193               29-Oct-07 22:45

               Filename: GLCD01.lst

               ROM used: 3622 bytes (11%)
                         Largest free fragment is 29146
               RAM used: 26 (2%) at main() level
                         64 (4%) worst case
               Stack:    4 locations

*
0000:  GOTO   0B02
.................... #include <18F452.h> 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=20000000) 
*
0ADA:  CLRF   FEA
0ADC:  MOVLW  19
0ADE:  MOVWF  FE9
0AE0:  MOVF   FEF,W
0AE2:  BZ    0AFE
0AE4:  MOVLW  06
0AE6:  MOVWF  01
0AE8:  CLRF   00
0AEA:  DECFSZ 00,F
0AEC:  BRA    0AEA
0AEE:  DECFSZ 01,F
0AF0:  BRA    0AE8
0AF2:  MOVLW  7B
0AF4:  MOVWF  00
0AF6:  DECFSZ 00,F
0AF8:  BRA    0AF6
0AFA:  DECFSZ FEF,F
0AFC:  BRA    0AE4
0AFE:  GOTO   0DFC (RETURN)
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7) 
.................... //#define FAST_GLCD    // Try commenting this out to see the differences 
.................... #define GLCD_WIDTH	128 
....................  
.................... #include "HDM64GS12.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_C0   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(int8 x, int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    int8 left[512]; 
....................    int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
03AC:  BCF    F94.0
03AE:  BSF    F8B.0
....................    output_low(GLCD_E); 
03B0:  BCF    F93.5
03B2:  BCF    F8A.5
....................    output_low(GLCD_CS1); 
03B4:  BCF    F93.0
03B6:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
03B8:  BCF    F93.1
03BA:  BCF    F8A.1
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
03BC:  BCF    F93.2
03BE:  BCF    F8A.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
03C0:  CLRF   3E
03C2:  MOVLW  C0
03C4:  MOVWF  3F
03C6:  RCALL  0304
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
03C8:  MOVLW  01
03CA:  MOVWF  3E
03CC:  MOVLW  C0
03CE:  MOVWF  3F
03D0:  RCALL  0304
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
03D2:  CLRF   3E
03D4:  MOVLW  40
03D6:  MOVWF  3F
03D8:  RCALL  0304
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
03DA:  MOVLW  01
03DC:  MOVWF  3E
03DE:  MOVLW  40
03E0:  MOVWF  3F
03E2:  RCALL  0304
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
03E4:  CLRF   3E
03E6:  MOVLW  B8
03E8:  MOVWF  3F
03EA:  RCALL  0304
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
03EC:  MOVLW  01
03EE:  MOVWF  3E
03F0:  MOVLW  B8
03F2:  MOVWF  3F
03F4:  RCALL  0304
....................  
....................    if(mode == ON) 
03F6:  DECFSZ 19,W
03F8:  BRA    040E
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
03FA:  CLRF   3E
03FC:  MOVLW  3F
03FE:  MOVWF  3F
0400:  RCALL  0304
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
0402:  MOVLW  01
0404:  MOVWF  3E
0406:  MOVLW  3F
0408:  MOVWF  3F
040A:  RCALL  0304
....................    } 
....................    else 
040C:  BRA    0420
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
040E:  CLRF   3E
0410:  MOVLW  3E
0412:  MOVWF  3F
0414:  RCALL  0304
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
0416:  MOVLW  01
0418:  MOVWF  3E
041A:  MOVLW  3E
041C:  MOVWF  3F
041E:  RCALL  0304
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
0420:  CLRF   1A
0422:  RCALL  033A
....................  
....................    #ifdef FAST_GLCD 
....................    glcd_update(); 
....................    #endif 
.................... } 
0424:  GOTO   0B76 (RETURN)
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    int8 i, j; 
....................    int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(int8 x, int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8* p; 
....................    int16 temp; 
....................    temp =  y/8; 
....................    temp *= 64; 
....................    temp += x; 
....................  
....................    if(x > 63) 
....................    { 
....................       p = displayData.right + temp - 64; 
....................    } 
....................    else 
....................    { 
....................       p = displayData.left + temp; 
....................    } 
....................  
....................    if(color) 
....................    { 
....................       bit_set(*p, y%8); 
....................    } 
....................    else 
....................    { 
....................       bit_clear(*p, y%8); 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
*
0466:  BCF    39.0
....................  
....................    if(x > 63)              // Check for first or second display area 
0468:  MOVF   35,W
046A:  SUBLW  3F
046C:  BC    0474
....................    { 
....................       x -= 64; 
046E:  MOVLW  40
0470:  SUBWF  35,F
....................       side = GLCD_RIGHT; 
0472:  BSF    39.0
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
0474:  BCF    F93.2
0476:  BCF    F8A.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
0478:  BCF    35.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
047A:  BSF    35.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
047C:  MOVLW  00
047E:  BTFSC  39.0
0480:  MOVLW  01
0482:  MOVWF  3A
0484:  MOVWF  3E
0486:  MOVFF  35,3F
048A:  RCALL  0304
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
048C:  MOVLW  00
048E:  BTFSC  39.0
0490:  MOVLW  01
0492:  MOVWF  3E
0494:  RRCF   36,W
0496:  MOVWF  00
0498:  RRCF   00,F
049A:  RRCF   00,F
049C:  MOVLW  1F
049E:  ANDWF  00,F
04A0:  MOVF   00,W
04A2:  ANDLW  BF
04A4:  IORLW  B8
04A6:  MOVWF  3D
04A8:  MOVWF  3F
04AA:  RCALL  0304
....................    output_high(GLCD_DI);                        // Set for data 
04AC:  BCF    F93.2
04AE:  BSF    F8A.2
....................    glcd_readByte(side);                         // Need two reads to get data 
04B0:  MOVLW  00
04B2:  BTFSC  39.0
04B4:  MOVLW  01
04B6:  MOVWF  3A
04B8:  MOVWF  3B
04BA:  RCALL  0428
....................    data = glcd_readByte(side);                  //  at new address 
04BC:  MOVLW  00
04BE:  BTFSC  39.0
04C0:  MOVLW  01
04C2:  MOVWF  3A
04C4:  MOVWF  3B
04C6:  RCALL  0428
04C8:  MOVFF  01,38
....................  
....................    if(color == ON) 
04CC:  DECFSZ 37,W
04CE:  BRA    04EE
....................       bit_set(data, y%8);        // Turn the pixel on 
04D0:  MOVF   36,W
04D2:  ANDLW  07
04D4:  MOVWF  3A
04D6:  MOVLW  01
04D8:  MOVWF  00
04DA:  MOVF   3A,W
04DC:  MOVWF  01
04DE:  BZ    04E8
04E0:  BCF    FD8.0
04E2:  RLCF   00,F
04E4:  DECFSZ 01,F
04E6:  BRA    04E0
04E8:  MOVF   00,W
04EA:  IORWF  38,F
....................    else                          // or 
04EC:  BRA    050C
....................       bit_clear(data, y%8);      // turn the pixel off 
04EE:  MOVF   36,W
04F0:  ANDLW  07
04F2:  MOVWF  3A
04F4:  MOVLW  01
04F6:  MOVWF  00
04F8:  MOVF   3A,W
04FA:  MOVWF  01
04FC:  BZ    0506
04FE:  BCF    FD8.0
0500:  RLCF   00,F
0502:  DECFSZ 01,F
0504:  BRA    04FE
0506:  MOVF   00,W
0508:  XORLW  FF
050A:  ANDWF  38,F
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
050C:  BCF    F93.2
050E:  BCF    F8A.2
....................    glcd_writeByte(side, x);      // Set the horizontal address 
0510:  MOVLW  00
0512:  BTFSC  39.0
0514:  MOVLW  01
0516:  MOVWF  3A
0518:  MOVWF  3E
051A:  MOVFF  35,3F
051E:  RCALL  0304
....................    output_high(GLCD_DI);         // Set for data 
0520:  BCF    F93.2
0522:  BSF    F8A.2
....................    glcd_writeByte(side, data);   // Write the pixel data 
0524:  MOVLW  00
0526:  BTFSC  39.0
0528:  MOVLW  01
052A:  MOVWF  3A
052C:  MOVWF  3E
052E:  MOVFF  38,3F
0532:  RCALL  0304
.................... } 
0534:  RETLW  00
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8  data; 
....................    int8  *p1, *p2; 
....................    int16 i; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................    data = 0xFF * color; 
....................  
....................    for(i=0; i<512; ++i) 
....................    { 
....................    	*p1++ = data; 
....................    	*p2++ = data; 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
033A:  CLRF   1B
033C:  MOVF   1B,W
033E:  SUBLW  07
0340:  BNC   03AA
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
0342:  BCF    F93.2
0344:  BCF    F8A.2
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
0346:  CLRF   3E
0348:  MOVLW  40
034A:  MOVWF  3F
034C:  RCALL  0304
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
034E:  MOVLW  01
0350:  MOVWF  3E
0352:  MOVLW  40
0354:  MOVWF  3F
0356:  RCALL  0304
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
0358:  MOVF   1B,W
035A:  IORLW  B8
035C:  MOVWF  1D
035E:  CLRF   3E
0360:  MOVWF  3F
0362:  RCALL  0304
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
0364:  MOVF   1B,W
0366:  IORLW  B8
0368:  MOVWF  1D
036A:  MOVLW  01
036C:  MOVWF  3E
036E:  MOVFF  1D,3F
0372:  RCALL  0304
....................       output_high(GLCD_DI);                     // Set for data 
0374:  BCF    F93.2
0376:  BSF    F8A.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
0378:  CLRF   1C
037A:  MOVF   1C,W
037C:  SUBLW  3F
037E:  BNC   03A6
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
0380:  MOVF   1A,W
0382:  MULLW  FF
0384:  MOVFF  FF3,1D
0388:  CLRF   3E
038A:  MOVFF  1D,3F
038E:  RCALL  0304
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
0390:  MOVF   1A,W
0392:  MULLW  FF
0394:  MOVFF  FF3,1D
0398:  MOVLW  01
039A:  MOVWF  3E
039C:  MOVFF  1D,3F
03A0:  RCALL  0304
....................       } 
03A2:  INCF   1C,F
03A4:  BRA    037A
....................    } 
03A6:  INCF   1B,F
03A8:  BRA    033C
.................... } 
03AA:  RETLW  00
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    if(side)                   // Choose which side to write to 
*
0304:  MOVF   3E,F
0306:  BZ    030E
....................       output_high(GLCD_CS2); 
0308:  BCF    F93.1
030A:  BSF    F8A.1
....................    else 
030C:  BRA    0312
....................       output_high(GLCD_CS1); 
030E:  BCF    F93.0
0310:  BSF    F8A.0
....................  
....................    output_low(GLCD_RW);       // Set for writing 
0312:  BCF    F93.4
0314:  BCF    F8A.4
....................    output_d(data);            // Put the data on the port 
0316:  CLRF   F95
0318:  MOVFF  3F,F8C
....................    delay_cycles(1); 
031C:  NOP   
....................    output_high(GLCD_E);       // Pulse the enable pin 
031E:  BCF    F93.5
0320:  BSF    F8A.5
....................    delay_cycles(5); 
0322:  NOP   
0324:  NOP   
0326:  NOP   
0328:  NOP   
032A:  NOP   
....................    output_low(GLCD_E); 
032C:  BCF    F93.5
032E:  BCF    F8A.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0330:  BCF    F93.0
0332:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
0334:  BCF    F93.1
0336:  BCF    F8A.1
.................... } 
0338:  RETLW  00
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
*
0428:  MOVLW  FF
042A:  MOVWF  F95
....................    output_high(GLCD_RW);      // Set for reading 
042C:  BCF    F93.4
042E:  BSF    F8A.4
....................  
....................    if(side)                   // Choose which side to write to 
0430:  MOVF   3B,F
0432:  BZ    043A
....................       output_high(GLCD_CS2); 
0434:  BCF    F93.1
0436:  BSF    F8A.1
....................    else 
0438:  BRA    043E
....................       output_high(GLCD_CS1); 
043A:  BCF    F93.0
043C:  BSF    F8A.0
....................  
....................    delay_cycles(1); 
043E:  NOP   
....................    output_high(GLCD_E);       // Pulse the enable pin 
0440:  BCF    F93.5
0442:  BSF    F8A.5
....................    delay_cycles(4); 
0444:  NOP   
0446:  NOP   
0448:  NOP   
044A:  NOP   
....................    data = input_d();          // Get the data from the display's output register 
044C:  MOVLW  FF
044E:  MOVWF  F95
0450:  MOVFF  F83,3C
....................    output_low(GLCD_E); 
0454:  BCF    F93.5
0456:  BCF    F8A.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0458:  BCF    F93.0
045A:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
045C:  BCF    F93.1
045E:  BCF    F8A.1
....................    return data;               // Return the read data 
0460:  MOVFF  3C,01
.................... } 
0464:  RETLW  00
....................  
.................... #endif 
....................  
.................... #include "graphics.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(int16 x1, int16 y1, int16 x2, int16 y2, int1 color) 
.................... #else 
.................... void glcd_line(int8 x1, int8 y1, int8 x2, int8 y2, int1 color) 
.................... #endif 
.................... { 
....................    int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
*
0536:  MOVLW  01
0538:  MOVWF  2E
053A:  MOVWF  2F
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
053C:  CLRF   34
....................    dx = abs((signed int8)(x2 - x1)); 
053E:  MOVF   25,W
0540:  SUBWF  27,W
0542:  MOVWF  35
0544:  MOVF   35,W
0546:  BTFSS  35.7
0548:  BRA    0550
054A:  MOVLW  00
054C:  BSF    FD8.0
054E:  SUBFWB 35,W
0550:  CLRF   03
0552:  MOVWF  2C
0554:  MOVFF  03,2D
....................    dy = abs((signed int8)(y2 - y1)); 
0558:  MOVF   26,W
055A:  SUBWF  28,W
055C:  MOVWF  35
055E:  MOVF   35,W
0560:  BTFSS  35.7
0562:  BRA    056A
0564:  MOVLW  00
0566:  BSF    FD8.0
0568:  SUBFWB 35,W
056A:  CLRF   03
056C:  MOVWF  2A
056E:  MOVFF  03,2B
....................    #endif 
....................  
....................    if(x1 > x2) 
0572:  MOVF   25,W
0574:  SUBWF  27,W
0576:  BC    057C
....................       addx = -1; 
0578:  MOVLW  FF
057A:  MOVWF  2E
....................    if(y1 > y2) 
057C:  MOVF   26,W
057E:  SUBWF  28,W
0580:  BC    0586
....................       addy = -1; 
0582:  MOVLW  FF
0584:  MOVWF  2F
....................  
....................    if(dx >= dy) 
0586:  MOVF   2B,W
0588:  SUBWF  2D,W
058A:  BNC   05FE
058C:  BNZ   0594
058E:  MOVF   2A,W
0590:  SUBWF  2C,W
0592:  BNC   05FE
....................    { 
....................       dy *= 2; 
0594:  BCF    FD8.0
0596:  RLCF   2A,F
0598:  RLCF   2B,F
....................       P = dy - dx; 
059A:  MOVF   2C,W
059C:  SUBWF  2A,W
059E:  MOVWF  00
05A0:  MOVF   2D,W
05A2:  SUBWFB 2B,W
05A4:  MOVFF  00,30
05A8:  MOVWF  31
....................       diff = P - dx; 
05AA:  MOVF   2C,W
05AC:  SUBWF  30,W
05AE:  MOVWF  32
05B0:  MOVF   2D,W
05B2:  SUBWFB 31,W
05B4:  MOVWF  33
....................  
....................       for(; i<=dx; ++i) 
05B6:  MOVF   2D,F
05B8:  BNZ   05C0
05BA:  MOVF   34,W
05BC:  SUBWF  2C,W
05BE:  BNC   05FC
....................       { 
....................          glcd_pixel(x1, y1, color); 
05C0:  MOVFF  25,35
05C4:  MOVFF  26,36
05C8:  MOVFF  29,37
05CC:  RCALL  0466
....................  
....................          if(P < 0) 
05CE:  BTFSC  31.7
05D0:  BRA    05D4
05D2:  BRA    05E4
....................          { 
....................             P  += dy; 
05D4:  MOVF   2A,W
05D6:  ADDWF  30,F
05D8:  MOVF   2B,W
05DA:  ADDWFC 31,F
....................             x1 += addx; 
05DC:  MOVF   2E,W
05DE:  ADDWF  25,W
05E0:  MOVWF  25
....................          } 
....................          else 
05E2:  BRA    05F8
....................          { 
....................             P  += diff; 
05E4:  MOVF   32,W
05E6:  ADDWF  30,F
05E8:  MOVF   33,W
05EA:  ADDWFC 31,F
....................             x1 += addx; 
05EC:  MOVF   2E,W
05EE:  ADDWF  25,W
05F0:  MOVWF  25
....................             y1 += addy; 
05F2:  MOVF   2F,W
05F4:  ADDWF  26,W
05F6:  MOVWF  26
....................          } 
....................       } 
05F8:  INCF   34,F
05FA:  BRA    05B6
....................    } 
....................    else 
05FC:  BRA    0666
....................    { 
....................       dx *= 2; 
05FE:  BCF    FD8.0
0600:  RLCF   2C,F
0602:  RLCF   2D,F
....................       P = dx - dy; 
0604:  MOVF   2A,W
0606:  SUBWF  2C,W
0608:  MOVWF  00
060A:  MOVF   2B,W
060C:  SUBWFB 2D,W
060E:  MOVFF  00,30
0612:  MOVWF  31
....................       diff = P - dy; 
0614:  MOVF   2A,W
0616:  SUBWF  30,W
0618:  MOVWF  32
061A:  MOVF   2B,W
061C:  SUBWFB 31,W
061E:  MOVWF  33
....................  
....................       for(; i<=dy; ++i) 
0620:  MOVF   2B,F
0622:  BNZ   062A
0624:  MOVF   34,W
0626:  SUBWF  2A,W
0628:  BNC   0666
....................       { 
....................          glcd_pixel(x1, y1, color); 
062A:  MOVFF  25,35
062E:  MOVFF  26,36
0632:  MOVFF  29,37
0636:  RCALL  0466
....................  
....................          if(P < 0) 
0638:  BTFSC  31.7
063A:  BRA    063E
063C:  BRA    064E
....................          { 
....................             P  += dx; 
063E:  MOVF   2C,W
0640:  ADDWF  30,F
0642:  MOVF   2D,W
0644:  ADDWFC 31,F
....................             y1 += addy; 
0646:  MOVF   2F,W
0648:  ADDWF  26,W
064A:  MOVWF  26
....................          } 
....................          else 
064C:  BRA    0662
....................          { 
....................             P  += diff; 
064E:  MOVF   32,W
0650:  ADDWF  30,F
0652:  MOVF   33,W
0654:  ADDWFC 31,F
....................             x1 += addx; 
0656:  MOVF   2E,W
0658:  ADDWF  25,W
065A:  MOVWF  25
....................             y1 += addy; 
065C:  MOVF   2F,W
065E:  ADDWF  26,W
0660:  MOVWF  26
....................          } 
....................       } 
0662:  INCF   34,F
0664:  BRA    0620
....................    } 
.................... } 
0666:  RETLW  00
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(int16 x1, int16 y1, int16 x2, int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(int8 x1, int8 y1, int8 x2, int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
0668:  MOVF   1D,F
066A:  BZ    06C4
....................    { 
....................       #ifdef LARGE_LCD 
....................       int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
066C:  MOVF   1B,W
066E:  SUBWF  19,W
0670:  BC    067C
....................       { 
....................          xmin = x1; 
0672:  MOVFF  19,20
....................          xmax = x2; 
0676:  MOVFF  1B,21
....................       } 
....................       else 
067A:  BRA    0684
....................       { 
....................          xmin = x2; 
067C:  MOVFF  1B,20
....................          xmax = x1; 
0680:  MOVFF  19,21
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
0684:  MOVF   1C,W
0686:  SUBWF  1A,W
0688:  BC    0694
....................       { 
....................          ymin = y1; 
068A:  MOVFF  1A,22
....................          ymax = y2; 
068E:  MOVFF  1C,23
....................       } 
....................       else 
0692:  BRA    069C
....................       { 
....................          ymin = y2; 
0694:  MOVFF  1C,22
....................          ymax = y1; 
0698:  MOVFF  1A,23
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
069C:  MOVF   20,W
069E:  SUBWF  21,W
06A0:  BNC   06C2
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
06A2:  MOVFF  22,1F
06A6:  MOVF   1F,W
06A8:  SUBWF  23,W
06AA:  BNC   06BE
....................          { 
....................             glcd_pixel(xmin, i, color); 
06AC:  MOVFF  20,35
06B0:  MOVFF  1F,36
06B4:  MOVFF  1E,37
06B8:  RCALL  0466
....................          } 
06BA:  INCF   1F,F
06BC:  BRA    06A6
....................       } 
06BE:  INCF   20,F
06C0:  BRA    069C
....................    } 
....................    else 
06C2:  BRA    071C
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
06C4:  MOVFF  19,25
06C8:  MOVFF  1A,26
06CC:  MOVFF  1B,27
06D0:  MOVFF  1A,28
06D4:  MOVFF  1E,29
06D8:  RCALL  0536
....................       glcd_line(x1, y2, x2, y2, color); 
06DA:  MOVFF  19,25
06DE:  MOVFF  1C,26
06E2:  MOVFF  1B,27
06E6:  MOVFF  1C,28
06EA:  MOVFF  1E,29
06EE:  RCALL  0536
....................       glcd_line(x1, y1, x1, y2, color); 
06F0:  MOVFF  19,25
06F4:  MOVFF  1A,26
06F8:  MOVFF  19,27
06FC:  MOVFF  1C,28
0700:  MOVFF  1E,29
0704:  RCALL  0536
....................       glcd_line(x2, y1, x2, y2, color); 
0706:  MOVFF  1B,25
070A:  MOVFF  1A,26
070E:  MOVFF  1B,27
0712:  MOVFF  1C,28
0716:  MOVFF  1E,29
071A:  RCALL  0536
....................    } 
.................... } 
071C:  GOTO   0D7A (RETURN)
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(int16 x1, int16 y1, int16 x2, int16 y2, int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(int8 x1, int8 y1, int8 x2, int8 y2, int8 width, int1 color) 
.................... #endif 
.................... { 
....................    int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    half_width = width/2; 
....................    c1 = -(dx*x1 + dy*y1); 
....................    c2 = -(dx*x2 + dy*y2); 
....................  
....................    if(x1 > x2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addx = -1; 
....................    } 
....................    if(y1 > y2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addy = -1; 
....................    } 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
....................                glcd_pixel(x1, y1+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
....................                glcd_pixel(x1+j, y1, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(int16 x, int16 y, int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(int8 x, int8 y, int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
*
076A:  CLRF   1E
....................    b = radius; 
076C:  MOVFF  1B,1F
....................    P = 1 - radius; 
0770:  MOVLW  01
0772:  BSF    FD8.0
0774:  SUBFWB 1B,W
0776:  MOVWF  20
....................  
....................    do 
....................    { 
....................       if(fill) 
0778:  MOVF   1C,F
077A:  BZ    082E
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
077C:  MOVF   1E,W
077E:  SUBWF  19,W
0780:  MOVWF  21
0782:  MOVF   1F,W
0784:  ADDWF  1A,W
0786:  MOVWF  22
0788:  MOVF   1E,W
078A:  ADDWF  19,W
078C:  MOVWF  23
078E:  MOVF   1F,W
0790:  ADDWF  1A,W
0792:  MOVWF  24
0794:  MOVFF  21,25
0798:  MOVFF  22,26
079C:  MOVFF  23,27
07A0:  MOVWF  28
07A2:  MOVFF  1D,29
07A6:  RCALL  0536
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
07A8:  MOVF   1E,W
07AA:  SUBWF  19,W
07AC:  MOVWF  21
07AE:  MOVF   1F,W
07B0:  SUBWF  1A,W
07B2:  MOVWF  22
07B4:  MOVF   1E,W
07B6:  ADDWF  19,W
07B8:  MOVWF  23
07BA:  MOVF   1F,W
07BC:  SUBWF  1A,W
07BE:  MOVWF  24
07C0:  MOVFF  21,25
07C4:  MOVFF  22,26
07C8:  MOVFF  23,27
07CC:  MOVWF  28
07CE:  MOVFF  1D,29
07D2:  RCALL  0536
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
07D4:  MOVF   1F,W
07D6:  SUBWF  19,W
07D8:  MOVWF  21
07DA:  MOVF   1E,W
07DC:  ADDWF  1A,W
07DE:  MOVWF  22
07E0:  MOVF   1F,W
07E2:  ADDWF  19,W
07E4:  MOVWF  23
07E6:  MOVF   1E,W
07E8:  ADDWF  1A,W
07EA:  MOVWF  24
07EC:  MOVFF  21,25
07F0:  MOVFF  22,26
07F4:  MOVFF  23,27
07F8:  MOVWF  28
07FA:  MOVFF  1D,29
07FE:  RCALL  0536
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
0800:  MOVF   1F,W
0802:  SUBWF  19,W
0804:  MOVWF  21
0806:  MOVF   1E,W
0808:  SUBWF  1A,W
080A:  MOVWF  22
080C:  MOVF   1F,W
080E:  ADDWF  19,W
0810:  MOVWF  23
0812:  MOVF   1E,W
0814:  SUBWF  1A,W
0816:  MOVWF  24
0818:  MOVFF  21,25
081C:  MOVFF  22,26
0820:  MOVFF  23,27
0824:  MOVWF  28
0826:  MOVFF  1D,29
082A:  RCALL  0536
....................       } 
....................       else 
082C:  BRA    08EE
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
082E:  MOVF   19,W
0830:  ADDWF  1E,W
0832:  MOVWF  21
0834:  MOVF   1A,W
0836:  ADDWF  1F,W
0838:  MOVWF  22
083A:  MOVFF  21,35
083E:  MOVWF  36
0840:  MOVFF  1D,37
0844:  RCALL  0466
....................          glcd_pixel(b+x, a+y, color); 
0846:  MOVF   19,W
0848:  ADDWF  1F,W
084A:  MOVWF  21
084C:  MOVF   1A,W
084E:  ADDWF  1E,W
0850:  MOVWF  22
0852:  MOVFF  21,35
0856:  MOVWF  36
0858:  MOVFF  1D,37
085C:  RCALL  0466
....................          glcd_pixel(x-a, b+y, color); 
085E:  MOVF   1E,W
0860:  SUBWF  19,W
0862:  MOVWF  21
0864:  MOVF   1A,W
0866:  ADDWF  1F,W
0868:  MOVWF  22
086A:  MOVFF  21,35
086E:  MOVWF  36
0870:  MOVFF  1D,37
0874:  RCALL  0466
....................          glcd_pixel(x-b, a+y, color); 
0876:  MOVF   1F,W
0878:  SUBWF  19,W
087A:  MOVWF  21
087C:  MOVF   1A,W
087E:  ADDWF  1E,W
0880:  MOVWF  22
0882:  MOVFF  21,35
0886:  MOVWF  36
0888:  MOVFF  1D,37
088C:  RCALL  0466
....................          glcd_pixel(b+x, y-a, color); 
088E:  MOVF   19,W
0890:  ADDWF  1F,W
0892:  MOVWF  21
0894:  MOVF   1E,W
0896:  SUBWF  1A,W
0898:  MOVWF  22
089A:  MOVFF  21,35
089E:  MOVWF  36
08A0:  MOVFF  1D,37
08A4:  RCALL  0466
....................          glcd_pixel(a+x, y-b, color); 
08A6:  MOVF   19,W
08A8:  ADDWF  1E,W
08AA:  MOVWF  21
08AC:  MOVF   1F,W
08AE:  SUBWF  1A,W
08B0:  MOVWF  22
08B2:  MOVFF  21,35
08B6:  MOVWF  36
08B8:  MOVFF  1D,37
08BC:  RCALL  0466
....................          glcd_pixel(x-a, y-b, color); 
08BE:  MOVF   1E,W
08C0:  SUBWF  19,W
08C2:  MOVWF  21
08C4:  MOVF   1F,W
08C6:  SUBWF  1A,W
08C8:  MOVWF  22
08CA:  MOVFF  21,35
08CE:  MOVWF  36
08D0:  MOVFF  1D,37
08D4:  RCALL  0466
....................          glcd_pixel(x-b, y-a, color); 
08D6:  MOVF   1F,W
08D8:  SUBWF  19,W
08DA:  MOVWF  21
08DC:  MOVF   1E,W
08DE:  SUBWF  1A,W
08E0:  MOVWF  22
08E2:  MOVFF  21,35
08E6:  MOVWF  36
08E8:  MOVFF  1D,37
08EC:  RCALL  0466
....................       } 
....................  
....................       if(P < 0) 
08EE:  BTFSC  20.7
08F0:  BRA    08F4
08F2:  BRA    090C
....................          P += 3 + 2 * a++; 
08F4:  MOVF   1E,W
08F6:  INCF   1E,F
08F8:  MOVWF  21
08FA:  MOVLW  02
08FC:  MOVWF  23
08FE:  MOVFF  21,24
0902:  RCALL  0720
0904:  MOVF   01,W
0906:  ADDLW  03
0908:  ADDWF  20,F
....................       else 
090A:  BRA    092A
....................          P += 5 + 2 * (a++ - b--); 
090C:  MOVF   1E,W
090E:  INCF   1E,F
0910:  MOVWF  21
0912:  MOVF   1F,W
0914:  DECF   1F,F
0916:  SUBWF  21,W
0918:  MOVWF  22
091A:  MOVLW  02
091C:  MOVWF  23
091E:  MOVFF  22,24
0922:  RCALL  0720
0924:  MOVF   01,W
0926:  ADDLW  05
0928:  ADDWF  20,F
....................     } while(a <= b); 
092A:  MOVF   1E,W
092C:  XORLW  80
092E:  MOVWF  00
0930:  MOVF   1F,W
0932:  XORLW  80
0934:  SUBWF  00,W
0936:  BTFSC  FD8.2
0938:  BRA    0778
093A:  BTFSS  FD8.0
093C:  BRA    0778
.................... } 
093E:  GOTO   0D8E (RETURN)
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(int16 x, int16 y, char* textptr, int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(int8 x, int8 y, char* textptr, int8 size, int1 color) 
.................... #endif 
.................... { 
....................    int8 j, k, l, m;                       // Loop counters 
....................    int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
0942:  MOVFF  1C,03
0946:  MOVFF  1B,FE9
094A:  MOVFF  1C,FEA
094E:  MOVF   FEF,F
0950:  BTFSC  FD8.2
0952:  BRA    0AD6
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
0954:  MOVFF  1C,03
0958:  MOVFF  1B,FE9
095C:  MOVFF  1C,FEA
0960:  MOVF   FEF,W
0962:  SUBLW  52
0964:  BNC   09AE
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
0966:  MOVFF  1C,03
096A:  MOVFF  1B,FE9
096E:  MOVFF  1C,FEA
0972:  MOVLW  20
0974:  SUBWF  FEF,W
0976:  MULLW  05
0978:  MOVF   FF3,W
097A:  CLRF   03
097C:  MOVWF  2A
097E:  CLRF   FEA
0980:  MOVLW  23
0982:  MOVWF  FE9
0984:  CLRF   2E
0986:  MOVFF  2A,2D
098A:  MOVFF  FF2,2B
098E:  BCF    FF2.7
0990:  MOVLW  05
0992:  MOVWF  01
0994:  CLRF   FF7
0996:  MOVF   2A,W
0998:  CALL   0004
099C:  TBLRD*-
099E:  TBLRD*+
09A0:  MOVFF  FF5,FEE
09A4:  DECFSZ 01,F
09A6:  BRA    099E
09A8:  BTFSC  2B.7
09AA:  BSF    FF2.7
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
09AC:  BRA    0A12
09AE:  MOVFF  1C,03
09B2:  MOVFF  1B,FE9
09B6:  MOVFF  1C,FEA
09BA:  MOVF   FEF,W
09BC:  SUBLW  7E
09BE:  BNC   0A08
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
09C0:  MOVFF  1C,03
09C4:  MOVFF  1B,FE9
09C8:  MOVFF  1C,FEA
09CC:  MOVLW  53
09CE:  SUBWF  FEF,W
09D0:  MULLW  05
09D2:  MOVF   FF3,W
09D4:  CLRF   03
09D6:  MOVWF  2A
09D8:  CLRF   FEA
09DA:  MOVLW  23
09DC:  MOVWF  FE9
09DE:  CLRF   2E
09E0:  MOVFF  2A,2D
09E4:  MOVFF  FF2,2B
09E8:  BCF    FF2.7
09EA:  MOVLW  05
09EC:  MOVWF  01
09EE:  CLRF   FF7
09F0:  MOVF   2A,W
09F2:  CALL   0114
09F6:  TBLRD*-
09F8:  TBLRD*+
09FA:  MOVFF  FF5,FEE
09FE:  DECFSZ 01,F
0A00:  BRA    09F8
0A02:  BTFSC  2B.7
0A04:  BSF    FF2.7
....................       else 
0A06:  BRA    0A12
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
0A08:  CLRF   23
0A0A:  CLRF   24
0A0C:  CLRF   25
0A0E:  CLRF   26
0A10:  CLRF   27
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
....................       { 
0A12:  MOVFF  1C,03
0A16:  MOVFF  1B,FE9
0A1A:  MOVFF  1C,FEA
0A1E:  MOVF   FEF,W
0A20:  XORLW  0A
0A22:  BZ    0A2A
0A24:  XORLW  07
0A26:  BZ    0A36
0A28:  BRA    0A3A
....................          case '\n': 
....................             y += 7*size + 1; 
0A2A:  MOVF   1D,W
0A2C:  MULLW  07
0A2E:  MOVF   FF3,W
0A30:  ADDLW  01
0A32:  ADDWF  1A,F
....................             continue; 
0A34:  BRA    0ACC
....................          case '\r': 
....................             x = 0; 
0A36:  CLRF   19
....................             continue; 
0A38:  BRA    0ACC
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
0A3A:  MOVF   1D,W
0A3C:  MULLW  05
0A3E:  MOVF   FF3,W
0A40:  ADDWF  19,W
0A42:  SUBLW  7F
0A44:  BC    0A52
....................       { 
....................          x = 0;                           // Set x at far left position 
0A46:  CLRF   19
....................          y += 7*size + 1;                 // Set y at next position down 
0A48:  MOVF   1D,W
0A4A:  MULLW  07
0A4C:  MOVF   FF3,W
0A4E:  ADDLW  01
0A50:  ADDWF  1A,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0A52:  CLRF   1F
0A54:  MOVF   1F,W
0A56:  SUBLW  04
0A58:  BNC   0ACC
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
0A5A:  CLRF   20
0A5C:  MOVF   20,W
0A5E:  SUBLW  06
0A60:  BNC   0AC4
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
0A62:  CLRF   03
0A64:  MOVF   1F,W
0A66:  ADDLW  23
0A68:  MOVWF  FE9
0A6A:  MOVLW  00
0A6C:  ADDWFC 03,W
0A6E:  MOVWF  FEA
0A70:  MOVFF  FEF,28
0A74:  MOVFF  28,00
0A78:  MOVF   20,W
0A7A:  MOVWF  01
0A7C:  BZ    0A86
0A7E:  BCF    FD8.0
0A80:  RRCF   00,F
0A82:  DECFSZ 01,F
0A84:  BRA    0A7E
0A86:  BTFSS  00.0
0A88:  BRA    0AC0
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
0A8A:  CLRF   21
0A8C:  MOVF   1D,W
0A8E:  SUBWF  21,W
0A90:  BC    0AC0
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
0A92:  CLRF   22
0A94:  MOVF   1D,W
0A96:  SUBWF  22,W
0A98:  BC    0ABC
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
0A9A:  MOVF   22,W
0A9C:  ADDWF  19,W
0A9E:  MOVWF  28
0AA0:  MOVF   20,W
0AA2:  MULWF  1D
0AA4:  MOVF   FF3,W
0AA6:  ADDWF  1A,W
0AA8:  ADDWF  21,W
0AAA:  MOVWF  2A
0AAC:  MOVFF  28,35
0AB0:  MOVWF  36
0AB2:  MOVFF  1E,37
0AB6:  RCALL  0466
....................                   } 
0AB8:  INCF   22,F
0ABA:  BRA    0A94
....................                } 
0ABC:  INCF   21,F
0ABE:  BRA    0A8C
....................             } 
....................          } 
0AC0:  INCF   20,F
0AC2:  BRA    0A5C
....................       } 
0AC4:  INCF   1F,F
0AC6:  MOVF   1D,W
0AC8:  ADDWF  19,F
0ACA:  BRA    0A54
....................    } 
0ACC:  INCF   1B,F
0ACE:  BTFSC  FD8.2
0AD0:  INCF   1C,F
0AD2:  INCF   19,F
0AD4:  BRA    0942
.................... } 
0AD6:  GOTO   0DF6 (RETURN)
....................  
.................... #endif 
....................  
.................... #include "math.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.141592654 
....................  
....................  
.................... #define SQRT2  1.41421356 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float CEIL_FLOOR(float x, int n) 
.................... { 
....................    float y, res; 
....................    long l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float)(long)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (long)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float)l); 
....................   res = 32768.0*(float)l; 
....................   res += (float)(long)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float)(long)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float floor(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float ceil(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //	float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float x,float y) 
.................... { 
....................    float i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
....................  
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
....................  
.................... #define LN2 0.6931471806 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... float exp(float x) 
.................... { 
....................    float y, res, r; 
....................    signed int n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed long)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................    *(&res) = n + 0x7F; 
....................  
....................    y = y/LN2 - (float)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... /************************************************************/ 
....................  
.................... float const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float log(float x) 
.................... { 
....................    float y, res, r, y2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................       *(&y) = 0x7E; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................       n = *(&x) - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float)-n; 
....................       else 
....................          r = (float)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... #define LN10 2.30258509 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float log10(float x) 
.................... { 
....................    float r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float modf(float value,float *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pwr(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pow(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float sqrt(float x) 
.................... { 
....................    float y, res; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p=&y; 
....................    (*p)=(BYTE)((((int16)(*p)) + 127) >> 1); 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................       (*p)--; 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
....................  
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO	1.570796326794896 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI 			0.6366197724 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float cos(float x) 
.................... { 
.................... 	float y, t, t2 = 1.0; 
.................... 	int quad, i; 
.................... 	float frac; 
.................... 	float p[4] = { 
.................... 		-0.499999993585, 
.................... 		 0.041666636258, 
.................... 		-0.0013888361399, 
.................... 		 0.00002476016134 
.................... 	}; 
....................  
.................... 	if (x < 0) x = -x;                  // absolute value of input 
....................  
.................... 	quad = (int)(x / PI_DIV_BY_TWO);    // quadrant 
.................... 	frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
.................... 	quad = quad % 4;                    // quadrant (0 to 3) 
....................  
.................... 	if (quad == 0 || quad == 2) 
.................... 		t = frac * PI_DIV_BY_TWO; 
.................... 	else if (quad == 1) 
.................... 		t = (1-frac) * PI_DIV_BY_TWO; 
.................... 	else // should be 3 
.................... 		t = (frac-1) * PI_DIV_BY_TWO; 
....................  
.................... 	y = 0.999999999781; 
.................... 	t = t * t; 
.................... 	for (i = 0; i <= 3; i++) 
.................... 	{ 
.................... 		t2 = t2 * t; 
.................... 		y = y + p[i] * t2; 
.................... 	} 
....................  
.................... 	if (quad == 2 || quad == 1) 
.................... 		y = -y;  // correct sign 
....................  
.................... 	return (y); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float sin(float x) 
.................... { 
.................... 	return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float tan(float x) 
.................... { 
....................    float c, s; 
....................  
....................    c = cos(x); 
.................... 	if (c == 0.0) 
.................... 	   return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
....................  
....................  
.................... float const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float ASIN_COS(float x, int n) 
.................... { 
....................    float y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float asin(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float acos(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... float const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float atan(float x) 
.................... { 
....................    float y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //	float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
....................  
.................... float atan2(float y,float x) 
.................... { 
....................    float z; 
....................    int1 sign; 
....................    int quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float cosh(float x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float sinh(float x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float tanh(float x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
....................  
....................  
.................... #define LOG2 .30102999566398119521 
.................... float frexp(float x, signed int *exp) 
.................... { 
....................    float res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //	float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float ldexp(float value, signed int exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... char str[20]="GLCD Example"; 
.................... void main() { 
*
0B02:  CLRF   FF8
0B04:  BCF    FD0.7
0B06:  CLRF   FEA
0B08:  CLRF   FE9
0B0A:  MOVLW  81
0B0C:  MOVWF  FAF
0B0E:  MOVLW  26
0B10:  MOVWF  FAC
0B12:  MOVLW  90
0B14:  MOVWF  FAB
0B16:  BSF    FC1.0
0B18:  BSF    FC1.1
0B1A:  BSF    FC1.2
0B1C:  BCF    FC1.3
0B1E:  MOVLW  47
0B20:  MOVWF  05
0B22:  MOVLW  4C
0B24:  MOVWF  06
0B26:  MOVLW  43
0B28:  MOVWF  07
0B2A:  MOVLW  44
0B2C:  MOVWF  08
0B2E:  MOVLW  20
0B30:  MOVWF  09
0B32:  MOVLW  45
0B34:  MOVWF  0A
0B36:  MOVLW  78
0B38:  MOVWF  0B
0B3A:  MOVLW  61
0B3C:  MOVWF  0C
0B3E:  MOVLW  6D
0B40:  MOVWF  0D
0B42:  MOVLW  70
0B44:  MOVWF  0E
0B46:  MOVLW  6C
0B48:  MOVWF  0F
0B4A:  MOVLW  65
0B4C:  MOVWF  10
0B4E:  CLRF   11
0B50:  CLRF   12
0B52:  CLRF   13
0B54:  CLRF   14
0B56:  CLRF   15
0B58:  CLRF   16
0B5A:  CLRF   17
0B5C:  CLRF   18
....................     
....................    setup_adc_ports(RA0_ANALOG); 
0B5E:  BCF    FC1.0
0B60:  BSF    FC1.1
0B62:  BSF    FC1.2
0B64:  BSF    FC1.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0B66:  BCF    FC1.6
0B68:  BSF    FC2.6
0B6A:  BSF    FC2.7
0B6C:  BCF    FC1.7
0B6E:  BSF    FC2.0
....................    glcd_init(ON); 
0B70:  MOVLW  01
0B72:  MOVWF  19
0B74:  BRA    03AC
....................     
....................    puts("glcd_pixel()  \n\r"); 
0B76:  CLRF   19
0B78:  MOVF   19,W
0B7A:  CALL   0200
0B7E:  IORLW  00
0B80:  BZ    0B8C
0B82:  INCF   19,F
0B84:  BTFSS  F9E.4
0B86:  BRA    0B84
0B88:  MOVWF  FAD
0B8A:  BRA    0B78
0B8C:  MOVLW  0D
0B8E:  BTFSS  F9E.4
0B90:  BRA    0B8E
0B92:  MOVWF  FAD
0B94:  MOVLW  0A
0B96:  BTFSS  F9E.4
0B98:  BRA    0B96
0B9A:  MOVWF  FAD
....................    puts("Press any Key\n\r"); 
0B9C:  CLRF   19
0B9E:  MOVF   19,W
0BA0:  CALL   0222
0BA4:  IORLW  00
0BA6:  BZ    0BB2
0BA8:  INCF   19,F
0BAA:  BTFSS  F9E.4
0BAC:  BRA    0BAA
0BAE:  MOVWF  FAD
0BB0:  BRA    0B9E
0BB2:  MOVLW  0D
0BB4:  BTFSS  F9E.4
0BB6:  BRA    0BB4
0BB8:  MOVWF  FAD
0BBA:  MOVLW  0A
0BBC:  BTFSS  F9E.4
0BBE:  BRA    0BBC
0BC0:  MOVWF  FAD
....................    getc(); 
0BC2:  BTFSS  F9E.5
0BC4:  BRA    0BC2
0BC6:  MOVF   FAE,W
....................    
....................    glcd_pixel(1,1,1); 
0BC8:  MOVLW  01
0BCA:  MOVWF  35
0BCC:  MOVWF  36
0BCE:  MOVWF  37
0BD0:  RCALL  0466
....................    glcd_pixel(1,2,1);	 
0BD2:  MOVLW  01
0BD4:  MOVWF  35
0BD6:  MOVLW  02
0BD8:  MOVWF  36
0BDA:  MOVLW  01
0BDC:  MOVWF  37
0BDE:  RCALL  0466
....................    glcd_pixel(1,3,1); 
0BE0:  MOVLW  01
0BE2:  MOVWF  35
0BE4:  MOVLW  03
0BE6:  MOVWF  36
0BE8:  MOVLW  01
0BEA:  MOVWF  37
0BEC:  RCALL  0466
....................    glcd_pixel(1,4,1);	 
0BEE:  MOVLW  01
0BF0:  MOVWF  35
0BF2:  MOVLW  04
0BF4:  MOVWF  36
0BF6:  MOVLW  01
0BF8:  MOVWF  37
0BFA:  RCALL  0466
....................    glcd_pixel(1,5,1); 
0BFC:  MOVLW  01
0BFE:  MOVWF  35
0C00:  MOVLW  05
0C02:  MOVWF  36
0C04:  MOVLW  01
0C06:  MOVWF  37
0C08:  RCALL  0466
....................    glcd_pixel(1,6,1);	 
0C0A:  MOVLW  01
0C0C:  MOVWF  35
0C0E:  MOVLW  06
0C10:  MOVWF  36
0C12:  MOVLW  01
0C14:  MOVWF  37
0C16:  RCALL  0466
....................     
....................    glcd_pixel(1,1,1); 
0C18:  MOVLW  01
0C1A:  MOVWF  35
0C1C:  MOVWF  36
0C1E:  MOVWF  37
0C20:  RCALL  0466
....................    glcd_pixel(2,1,1);	 
0C22:  MOVLW  02
0C24:  MOVWF  35
0C26:  MOVLW  01
0C28:  MOVWF  36
0C2A:  MOVWF  37
0C2C:  RCALL  0466
....................    glcd_pixel(3,1,1); 
0C2E:  MOVLW  03
0C30:  MOVWF  35
0C32:  MOVLW  01
0C34:  MOVWF  36
0C36:  MOVWF  37
0C38:  RCALL  0466
....................    glcd_pixel(4,1,1);	 
0C3A:  MOVLW  04
0C3C:  MOVWF  35
0C3E:  MOVLW  01
0C40:  MOVWF  36
0C42:  MOVWF  37
0C44:  RCALL  0466
....................    glcd_pixel(5,1,1); 
0C46:  MOVLW  05
0C48:  MOVWF  35
0C4A:  MOVLW  01
0C4C:  MOVWF  36
0C4E:  MOVWF  37
0C50:  RCALL  0466
....................    glcd_pixel(6,1,1);	 
0C52:  MOVLW  06
0C54:  MOVWF  35
0C56:  MOVLW  01
0C58:  MOVWF  36
0C5A:  MOVWF  37
0C5C:  RCALL  0466
....................    puts("glcd_fillScreen() Black color  \n\r"); 
0C5E:  CLRF   19
0C60:  MOVF   19,W
0C62:  CALL   0242
0C66:  IORLW  00
0C68:  BZ    0C74
0C6A:  INCF   19,F
0C6C:  BTFSS  F9E.4
0C6E:  BRA    0C6C
0C70:  MOVWF  FAD
0C72:  BRA    0C60
0C74:  MOVLW  0D
0C76:  BTFSS  F9E.4
0C78:  BRA    0C76
0C7A:  MOVWF  FAD
0C7C:  MOVLW  0A
0C7E:  BTFSS  F9E.4
0C80:  BRA    0C7E
0C82:  MOVWF  FAD
....................    puts("Press any Key\n\r"); 
0C84:  CLRF   19
0C86:  MOVF   19,W
0C88:  CALL   0222
0C8C:  IORLW  00
0C8E:  BZ    0C9A
0C90:  INCF   19,F
0C92:  BTFSS  F9E.4
0C94:  BRA    0C92
0C96:  MOVWF  FAD
0C98:  BRA    0C86
0C9A:  MOVLW  0D
0C9C:  BTFSS  F9E.4
0C9E:  BRA    0C9C
0CA0:  MOVWF  FAD
0CA2:  MOVLW  0A
0CA4:  BTFSS  F9E.4
0CA6:  BRA    0CA4
0CA8:  MOVWF  FAD
....................    getc(); 
0CAA:  BTFSS  F9E.5
0CAC:  BRA    0CAA
0CAE:  MOVF   FAE,W
....................    glcd_fillScreen(1); 
0CB0:  MOVLW  01
0CB2:  MOVWF  1A
0CB4:  CALL   033A
....................    puts("glcd_fillScreen() White Color \n\r"); 
0CB8:  CLRF   19
0CBA:  MOVF   19,W
0CBC:  CALL   0274
0CC0:  IORLW  00
0CC2:  BZ    0CCE
0CC4:  INCF   19,F
0CC6:  BTFSS  F9E.4
0CC8:  BRA    0CC6
0CCA:  MOVWF  FAD
0CCC:  BRA    0CBA
0CCE:  MOVLW  0D
0CD0:  BTFSS  F9E.4
0CD2:  BRA    0CD0
0CD4:  MOVWF  FAD
0CD6:  MOVLW  0A
0CD8:  BTFSS  F9E.4
0CDA:  BRA    0CD8
0CDC:  MOVWF  FAD
....................    puts("Press any Key\n\r"); 
0CDE:  CLRF   19
0CE0:  MOVF   19,W
0CE2:  CALL   0222
0CE6:  IORLW  00
0CE8:  BZ    0CF4
0CEA:  INCF   19,F
0CEC:  BTFSS  F9E.4
0CEE:  BRA    0CEC
0CF0:  MOVWF  FAD
0CF2:  BRA    0CE0
0CF4:  MOVLW  0D
0CF6:  BTFSS  F9E.4
0CF8:  BRA    0CF6
0CFA:  MOVWF  FAD
0CFC:  MOVLW  0A
0CFE:  BTFSS  F9E.4
0D00:  BRA    0CFE
0D02:  MOVWF  FAD
....................    getc(); 
0D04:  BTFSS  F9E.5
0D06:  BRA    0D04
0D08:  MOVF   FAE,W
....................    glcd_fillScreen(0); 
0D0A:  CLRF   1A
0D0C:  CALL   033A
....................                                             
....................    puts("glcd_rect(),glcd_circle()\n\r"); 
0D10:  CLRF   19
0D12:  MOVF   19,W
0D14:  CALL   02A6
0D18:  IORLW  00
0D1A:  BZ    0D26
0D1C:  INCF   19,F
0D1E:  BTFSS  F9E.4
0D20:  BRA    0D1E
0D22:  MOVWF  FAD
0D24:  BRA    0D12
0D26:  MOVLW  0D
0D28:  BTFSS  F9E.4
0D2A:  BRA    0D28
0D2C:  MOVWF  FAD
0D2E:  MOVLW  0A
0D30:  BTFSS  F9E.4
0D32:  BRA    0D30
0D34:  MOVWF  FAD
....................    puts("Press any Key\n\r"); 
0D36:  CLRF   19
0D38:  MOVF   19,W
0D3A:  CALL   0222
0D3E:  IORLW  00
0D40:  BZ    0D4C
0D42:  INCF   19,F
0D44:  BTFSS  F9E.4
0D46:  BRA    0D44
0D48:  MOVWF  FAD
0D4A:  BRA    0D38
0D4C:  MOVLW  0D
0D4E:  BTFSS  F9E.4
0D50:  BRA    0D4E
0D52:  MOVWF  FAD
0D54:  MOVLW  0A
0D56:  BTFSS  F9E.4
0D58:  BRA    0D56
0D5A:  MOVWF  FAD
....................    getc(); 
0D5C:  BTFSS  F9E.5
0D5E:  BRA    0D5C
0D60:  MOVF   FAE,W
....................                                
....................    glcd_rect(28,30 , 115, 50, NO, ON);             
0D62:  MOVLW  1C
0D64:  MOVWF  19
0D66:  MOVLW  1E
0D68:  MOVWF  1A
0D6A:  MOVLW  73
0D6C:  MOVWF  1B
0D6E:  MOVLW  32
0D70:  MOVWF  1C
0D72:  CLRF   1D
0D74:  MOVLW  01
0D76:  MOVWF  1E
0D78:  BRA    0668
....................    glcd_circle(64, 13, 10, YES, ON);              
0D7A:  MOVLW  40
0D7C:  MOVWF  19
0D7E:  MOVLW  0D
0D80:  MOVWF  1A
0D82:  MOVLW  0A
0D84:  MOVWF  1B
0D86:  MOVLW  01
0D88:  MOVWF  1C
0D8A:  MOVWF  1D
0D8C:  BRA    076A
....................    puts("glcd_text57\n\r"); 
0D8E:  CLRF   19
0D90:  MOVF   19,W
0D92:  CALL   02D2
0D96:  IORLW  00
0D98:  BZ    0DA4
0D9A:  INCF   19,F
0D9C:  BTFSS  F9E.4
0D9E:  BRA    0D9C
0DA0:  MOVWF  FAD
0DA2:  BRA    0D90
0DA4:  MOVLW  0D
0DA6:  BTFSS  F9E.4
0DA8:  BRA    0DA6
0DAA:  MOVWF  FAD
0DAC:  MOVLW  0A
0DAE:  BTFSS  F9E.4
0DB0:  BRA    0DAE
0DB2:  MOVWF  FAD
....................    puts("Press any Key\n\r"); 
0DB4:  CLRF   19
0DB6:  MOVF   19,W
0DB8:  CALL   0222
0DBC:  IORLW  00
0DBE:  BZ    0DCA
0DC0:  INCF   19,F
0DC2:  BTFSS  F9E.4
0DC4:  BRA    0DC2
0DC6:  MOVWF  FAD
0DC8:  BRA    0DB6
0DCA:  MOVLW  0D
0DCC:  BTFSS  F9E.4
0DCE:  BRA    0DCC
0DD0:  MOVWF  FAD
0DD2:  MOVLW  0A
0DD4:  BTFSS  F9E.4
0DD6:  BRA    0DD4
0DD8:  MOVWF  FAD
....................    getc(); 
0DDA:  BTFSS  F9E.5
0DDC:  BRA    0DDA
0DDE:  MOVF   FAE,W
....................    glcd_text57(40, 35,str,1, ON);         
0DE0:  MOVLW  28
0DE2:  MOVWF  19
0DE4:  MOVLW  23
0DE6:  MOVWF  1A
0DE8:  CLRF   1C
0DEA:  MOVLW  05
0DEC:  MOVWF  1B
0DEE:  MOVLW  01
0DF0:  MOVWF  1D
0DF2:  MOVWF  1E
0DF4:  BRA    0942
....................    
....................       #ifdef FAST_GLCD 
....................       glcd_update(); 
....................       #else 
....................       delay_ms(100);    // Reduces flicker by allowing pixels to be on 
0DF6:  MOVLW  64
0DF8:  MOVWF  19
0DFA:  BRA    0ADA
....................                         // much longer than off 
....................       #endif 
....................    puts("End"); 
0DFC:  CLRF   19
0DFE:  MOVF   19,W
0E00:  CALL   02F0
0E04:  IORLW  00
0E06:  BZ    0E12
0E08:  INCF   19,F
0E0A:  BTFSS  F9E.4
0E0C:  BRA    0E0A
0E0E:  MOVWF  FAD
0E10:  BRA    0DFE
0E12:  MOVLW  0D
0E14:  BTFSS  F9E.4
0E16:  BRA    0E14
0E18:  MOVWF  FAD
0E1A:  MOVLW  0A
0E1C:  BTFSS  F9E.4
0E1E:  BRA    0E1C
0E20:  MOVWF  FAD
....................     
....................    while(1); 
0E22:  BRA    0E22
....................     
.................... } 
0E24:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0F   BROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
