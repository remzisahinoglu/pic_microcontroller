CCS PCH C Compiler, Version 3.249, 28193               29-Oct-07 22:45

               Filename: GLCD02.lst

               ROM used: 6820 bytes (21%)
                         Largest free fragment is 25948
               RAM used: 42 (3%) at main() level
                         96 (6%) worst case
               Stack:    5 locations

*
0000:  GOTO   1620
.................... #include <18F452.h> 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=20000000) 
*
15F8:  CLRF   FEA
15FA:  MOVLW  1C
15FC:  MOVWF  FE9
15FE:  MOVF   FEF,W
1600:  BZ    161C
1602:  MOVLW  06
1604:  MOVWF  01
1606:  CLRF   00
1608:  DECFSZ 00,F
160A:  BRA    1608
160C:  DECFSZ 01,F
160E:  BRA    1606
1610:  MOVLW  7B
1612:  MOVWF  00
1614:  DECFSZ 00,F
1616:  BRA    1614
1618:  DECFSZ FEF,F
161A:  BRA    1602
161C:  GOTO   1AA0 (RETURN)
.................... //#define FAST_GLCD    // Try commenting this out to see the differences 
.................... #define GLCD_WIDTH	128 
....................  
.................... #include "HDM64GS12.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_C0   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(int8 x, int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    int8 left[512]; 
....................    int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
02AA:  BCF    F94.0
02AC:  BSF    F8B.0
....................    output_low(GLCD_E); 
02AE:  BCF    F93.5
02B0:  BCF    F8A.5
....................    output_low(GLCD_CS1); 
02B2:  BCF    F93.0
02B4:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
02B6:  BCF    F93.1
02B8:  BCF    F8A.1
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
02BA:  BCF    F93.2
02BC:  BCF    F8A.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
02BE:  CLRF   4A
02C0:  MOVLW  C0
02C2:  MOVWF  4B
02C4:  RCALL  0200
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
02C6:  MOVLW  01
02C8:  MOVWF  4A
02CA:  MOVLW  C0
02CC:  MOVWF  4B
02CE:  RCALL  0200
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
02D0:  CLRF   4A
02D2:  MOVLW  40
02D4:  MOVWF  4B
02D6:  RCALL  0200
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
02D8:  MOVLW  01
02DA:  MOVWF  4A
02DC:  MOVLW  40
02DE:  MOVWF  4B
02E0:  RCALL  0200
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
02E2:  CLRF   4A
02E4:  MOVLW  B8
02E6:  MOVWF  4B
02E8:  RCALL  0200
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
02EA:  MOVLW  01
02EC:  MOVWF  4A
02EE:  MOVLW  B8
02F0:  MOVWF  4B
02F2:  RCALL  0200
....................  
....................    if(mode == ON) 
02F4:  DECFSZ 1C,W
02F6:  BRA    030C
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
02F8:  CLRF   4A
02FA:  MOVLW  3F
02FC:  MOVWF  4B
02FE:  RCALL  0200
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
0300:  MOVLW  01
0302:  MOVWF  4A
0304:  MOVLW  3F
0306:  MOVWF  4B
0308:  RCALL  0200
....................    } 
....................    else 
030A:  BRA    031E
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
030C:  CLRF   4A
030E:  MOVLW  3E
0310:  MOVWF  4B
0312:  RCALL  0200
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
0314:  MOVLW  01
0316:  MOVWF  4A
0318:  MOVLW  3E
031A:  MOVWF  4B
031C:  RCALL  0200
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
031E:  CLRF   1D
0320:  BRA    0236
....................  
....................    #ifdef FAST_GLCD 
....................    glcd_update(); 
....................    #endif 
.................... } 
0322:  GOTO   169C (RETURN)
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    int8 i, j; 
....................    int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(int8 x, int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8* p; 
....................    int16 temp; 
....................    temp =  y/8; 
....................    temp *= 64; 
....................    temp += x; 
....................  
....................    if(x > 63) 
....................    { 
....................       p = displayData.right + temp - 64; 
....................    } 
....................    else 
....................    { 
....................       p = displayData.left + temp; 
....................    } 
....................  
....................    if(color) 
....................    { 
....................       bit_set(*p, y%8); 
....................    } 
....................    else 
....................    { 
....................       bit_clear(*p, y%8); 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
*
0364:  BCF    45.0
....................  
....................    if(x > 63)              // Check for first or second display area 
0366:  MOVF   41,W
0368:  SUBLW  3F
036A:  BC    0372
....................    { 
....................       x -= 64; 
036C:  MOVLW  40
036E:  SUBWF  41,F
....................       side = GLCD_RIGHT; 
0370:  BSF    45.0
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
0372:  BCF    F93.2
0374:  BCF    F8A.2
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
0376:  BCF    41.7
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
0378:  BSF    41.6
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
037A:  MOVLW  00
037C:  BTFSC  45.0
037E:  MOVLW  01
0380:  MOVWF  46
0382:  MOVWF  4A
0384:  MOVFF  41,4B
0388:  RCALL  0200
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
038A:  MOVLW  00
038C:  BTFSC  45.0
038E:  MOVLW  01
0390:  MOVWF  4A
0392:  RRCF   42,W
0394:  MOVWF  00
0396:  RRCF   00,F
0398:  RRCF   00,F
039A:  MOVLW  1F
039C:  ANDWF  00,F
039E:  MOVF   00,W
03A0:  ANDLW  BF
03A2:  IORLW  B8
03A4:  MOVWF  49
03A6:  MOVWF  4B
03A8:  RCALL  0200
....................    output_high(GLCD_DI);                        // Set for data 
03AA:  BCF    F93.2
03AC:  BSF    F8A.2
....................    glcd_readByte(side);                         // Need two reads to get data 
03AE:  MOVLW  00
03B0:  BTFSC  45.0
03B2:  MOVLW  01
03B4:  MOVWF  46
03B6:  MOVWF  47
03B8:  RCALL  0326
....................    data = glcd_readByte(side);                  //  at new address 
03BA:  MOVLW  00
03BC:  BTFSC  45.0
03BE:  MOVLW  01
03C0:  MOVWF  46
03C2:  MOVWF  47
03C4:  RCALL  0326
03C6:  MOVFF  01,44
....................  
....................    if(color == ON) 
03CA:  DECFSZ 43,W
03CC:  BRA    03EC
....................       bit_set(data, y%8);        // Turn the pixel on 
03CE:  MOVF   42,W
03D0:  ANDLW  07
03D2:  MOVWF  46
03D4:  MOVLW  01
03D6:  MOVWF  00
03D8:  MOVF   46,W
03DA:  MOVWF  01
03DC:  BZ    03E6
03DE:  BCF    FD8.0
03E0:  RLCF   00,F
03E2:  DECFSZ 01,F
03E4:  BRA    03DE
03E6:  MOVF   00,W
03E8:  IORWF  44,F
....................    else                          // or 
03EA:  BRA    040A
....................       bit_clear(data, y%8);      // turn the pixel off 
03EC:  MOVF   42,W
03EE:  ANDLW  07
03F0:  MOVWF  46
03F2:  MOVLW  01
03F4:  MOVWF  00
03F6:  MOVF   46,W
03F8:  MOVWF  01
03FA:  BZ    0404
03FC:  BCF    FD8.0
03FE:  RLCF   00,F
0400:  DECFSZ 01,F
0402:  BRA    03FC
0404:  MOVF   00,W
0406:  XORLW  FF
0408:  ANDWF  44,F
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
040A:  BCF    F93.2
040C:  BCF    F8A.2
....................    glcd_writeByte(side, x);      // Set the horizontal address 
040E:  MOVLW  00
0410:  BTFSC  45.0
0412:  MOVLW  01
0414:  MOVWF  46
0416:  MOVWF  4A
0418:  MOVFF  41,4B
041C:  RCALL  0200
....................    output_high(GLCD_DI);         // Set for data 
041E:  BCF    F93.2
0420:  BSF    F8A.2
....................    glcd_writeByte(side, data);   // Write the pixel data 
0422:  MOVLW  00
0424:  BTFSC  45.0
0426:  MOVLW  01
0428:  MOVWF  46
042A:  MOVWF  4A
042C:  MOVFF  44,4B
0430:  RCALL  0200
.................... } 
0432:  RETLW  00
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8  data; 
....................    int8  *p1, *p2; 
....................    int16 i; 
....................  
....................    p1 = displayData.left; 
....................    p2 = displayData.right; 
....................    data = 0xFF * color; 
....................  
....................    for(i=0; i<512; ++i) 
....................    { 
....................    	*p1++ = data; 
....................    	*p2++ = data; 
....................    } 
.................... } 
.................... #else 
.................... { 
....................    int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0236:  CLRF   1E
0238:  MOVF   1E,W
023A:  SUBLW  07
023C:  BNC   02A6
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
023E:  BCF    F93.2
0240:  BCF    F8A.2
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
0242:  CLRF   4A
0244:  MOVLW  40
0246:  MOVWF  4B
0248:  RCALL  0200
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
024A:  MOVLW  01
024C:  MOVWF  4A
024E:  MOVLW  40
0250:  MOVWF  4B
0252:  RCALL  0200
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
0254:  MOVF   1E,W
0256:  IORLW  B8
0258:  MOVWF  20
025A:  CLRF   4A
025C:  MOVWF  4B
025E:  RCALL  0200
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
0260:  MOVF   1E,W
0262:  IORLW  B8
0264:  MOVWF  20
0266:  MOVLW  01
0268:  MOVWF  4A
026A:  MOVFF  20,4B
026E:  RCALL  0200
....................       output_high(GLCD_DI);                     // Set for data 
0270:  BCF    F93.2
0272:  BSF    F8A.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
0274:  CLRF   1F
0276:  MOVF   1F,W
0278:  SUBLW  3F
027A:  BNC   02A2
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
027C:  MOVF   1D,W
027E:  MULLW  FF
0280:  MOVFF  FF3,20
0284:  CLRF   4A
0286:  MOVFF  20,4B
028A:  RCALL  0200
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
028C:  MOVF   1D,W
028E:  MULLW  FF
0290:  MOVFF  FF3,20
0294:  MOVLW  01
0296:  MOVWF  4A
0298:  MOVFF  20,4B
029C:  RCALL  0200
....................       } 
029E:  INCF   1F,F
02A0:  BRA    0276
....................    } 
02A2:  INCF   1E,F
02A4:  BRA    0238
.................... } 
02A6:  GOTO   0322 (RETURN)
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    if(side)                   // Choose which side to write to 
*
0200:  MOVF   4A,F
0202:  BZ    020A
....................       output_high(GLCD_CS2); 
0204:  BCF    F93.1
0206:  BSF    F8A.1
....................    else 
0208:  BRA    020E
....................       output_high(GLCD_CS1); 
020A:  BCF    F93.0
020C:  BSF    F8A.0
....................  
....................    output_low(GLCD_RW);       // Set for writing 
020E:  BCF    F93.4
0210:  BCF    F8A.4
....................    output_d(data);            // Put the data on the port 
0212:  CLRF   F95
0214:  MOVFF  4B,F8C
....................    delay_cycles(1); 
0218:  NOP   
....................    output_high(GLCD_E);       // Pulse the enable pin 
021A:  BCF    F93.5
021C:  BSF    F8A.5
....................    delay_cycles(5); 
021E:  NOP   
0220:  NOP   
0222:  NOP   
0224:  NOP   
0226:  NOP   
....................    output_low(GLCD_E); 
0228:  BCF    F93.5
022A:  BCF    F8A.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
022C:  BCF    F93.0
022E:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
0230:  BCF    F93.1
0232:  BCF    F8A.1
.................... } 
0234:  RETLW  00
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
*
0326:  MOVLW  FF
0328:  MOVWF  F95
....................    output_high(GLCD_RW);      // Set for reading 
032A:  BCF    F93.4
032C:  BSF    F8A.4
....................  
....................    if(side)                   // Choose which side to write to 
032E:  MOVF   47,F
0330:  BZ    0338
....................       output_high(GLCD_CS2); 
0332:  BCF    F93.1
0334:  BSF    F8A.1
....................    else 
0336:  BRA    033C
....................       output_high(GLCD_CS1); 
0338:  BCF    F93.0
033A:  BSF    F8A.0
....................  
....................    delay_cycles(1); 
033C:  NOP   
....................    output_high(GLCD_E);       // Pulse the enable pin 
033E:  BCF    F93.5
0340:  BSF    F8A.5
....................    delay_cycles(4); 
0342:  NOP   
0344:  NOP   
0346:  NOP   
0348:  NOP   
....................    data = input_d();          // Get the data from the display's output register 
034A:  MOVLW  FF
034C:  MOVWF  F95
034E:  MOVFF  F83,48
....................    output_low(GLCD_E); 
0352:  BCF    F93.5
0354:  BCF    F8A.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0356:  BCF    F93.0
0358:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
035A:  BCF    F93.1
035C:  BCF    F8A.1
....................    return data;               // Return the read data 
035E:  MOVFF  48,01
.................... } 
0362:  RETLW  00
....................  
.................... #endif 
....................  
.................... #include "graphics.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(int16 x1, int16 y1, int16 x2, int16 y2, int1 color) 
.................... #else 
.................... void glcd_line(int8 x1, int8 y1, int8 x2, int8 y2, int1 color) 
.................... #endif 
.................... { 
....................    int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
*
0434:  MOVLW  01
0436:  MOVWF  3A
0438:  MOVWF  3B
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
043A:  CLRF   40
....................    dx = abs((signed int8)(x2 - x1)); 
043C:  MOVF   31,W
043E:  SUBWF  33,W
0440:  MOVWF  41
0442:  MOVF   41,W
0444:  BTFSS  41.7
0446:  BRA    044E
0448:  MOVLW  00
044A:  BSF    FD8.0
044C:  SUBFWB 41,W
044E:  CLRF   03
0450:  MOVWF  38
0452:  MOVFF  03,39
....................    dy = abs((signed int8)(y2 - y1)); 
0456:  MOVF   32,W
0458:  SUBWF  34,W
045A:  MOVWF  41
045C:  MOVF   41,W
045E:  BTFSS  41.7
0460:  BRA    0468
0462:  MOVLW  00
0464:  BSF    FD8.0
0466:  SUBFWB 41,W
0468:  CLRF   03
046A:  MOVWF  36
046C:  MOVFF  03,37
....................    #endif 
....................  
....................    if(x1 > x2) 
0470:  MOVF   31,W
0472:  SUBWF  33,W
0474:  BC    047A
....................       addx = -1; 
0476:  MOVLW  FF
0478:  MOVWF  3A
....................    if(y1 > y2) 
047A:  MOVF   32,W
047C:  SUBWF  34,W
047E:  BC    0484
....................       addy = -1; 
0480:  MOVLW  FF
0482:  MOVWF  3B
....................  
....................    if(dx >= dy) 
0484:  MOVF   37,W
0486:  SUBWF  39,W
0488:  BNC   04FC
048A:  BNZ   0492
048C:  MOVF   36,W
048E:  SUBWF  38,W
0490:  BNC   04FC
....................    { 
....................       dy *= 2; 
0492:  BCF    FD8.0
0494:  RLCF   36,F
0496:  RLCF   37,F
....................       P = dy - dx; 
0498:  MOVF   38,W
049A:  SUBWF  36,W
049C:  MOVWF  00
049E:  MOVF   39,W
04A0:  SUBWFB 37,W
04A2:  MOVFF  00,3C
04A6:  MOVWF  3D
....................       diff = P - dx; 
04A8:  MOVF   38,W
04AA:  SUBWF  3C,W
04AC:  MOVWF  3E
04AE:  MOVF   39,W
04B0:  SUBWFB 3D,W
04B2:  MOVWF  3F
....................  
....................       for(; i<=dx; ++i) 
04B4:  MOVF   39,F
04B6:  BNZ   04BE
04B8:  MOVF   40,W
04BA:  SUBWF  38,W
04BC:  BNC   04FA
....................       { 
....................          glcd_pixel(x1, y1, color); 
04BE:  MOVFF  31,41
04C2:  MOVFF  32,42
04C6:  MOVFF  35,43
04CA:  RCALL  0364
....................  
....................          if(P < 0) 
04CC:  BTFSC  3D.7
04CE:  BRA    04D2
04D0:  BRA    04E2
....................          { 
....................             P  += dy; 
04D2:  MOVF   36,W
04D4:  ADDWF  3C,F
04D6:  MOVF   37,W
04D8:  ADDWFC 3D,F
....................             x1 += addx; 
04DA:  MOVF   3A,W
04DC:  ADDWF  31,W
04DE:  MOVWF  31
....................          } 
....................          else 
04E0:  BRA    04F6
....................          { 
....................             P  += diff; 
04E2:  MOVF   3E,W
04E4:  ADDWF  3C,F
04E6:  MOVF   3F,W
04E8:  ADDWFC 3D,F
....................             x1 += addx; 
04EA:  MOVF   3A,W
04EC:  ADDWF  31,W
04EE:  MOVWF  31
....................             y1 += addy; 
04F0:  MOVF   3B,W
04F2:  ADDWF  32,W
04F4:  MOVWF  32
....................          } 
....................       } 
04F6:  INCF   40,F
04F8:  BRA    04B4
....................    } 
....................    else 
04FA:  BRA    0564
....................    { 
....................       dx *= 2; 
04FC:  BCF    FD8.0
04FE:  RLCF   38,F
0500:  RLCF   39,F
....................       P = dx - dy; 
0502:  MOVF   36,W
0504:  SUBWF  38,W
0506:  MOVWF  00
0508:  MOVF   37,W
050A:  SUBWFB 39,W
050C:  MOVFF  00,3C
0510:  MOVWF  3D
....................       diff = P - dy; 
0512:  MOVF   36,W
0514:  SUBWF  3C,W
0516:  MOVWF  3E
0518:  MOVF   37,W
051A:  SUBWFB 3D,W
051C:  MOVWF  3F
....................  
....................       for(; i<=dy; ++i) 
051E:  MOVF   37,F
0520:  BNZ   0528
0522:  MOVF   40,W
0524:  SUBWF  36,W
0526:  BNC   0564
....................       { 
....................          glcd_pixel(x1, y1, color); 
0528:  MOVFF  31,41
052C:  MOVFF  32,42
0530:  MOVFF  35,43
0534:  RCALL  0364
....................  
....................          if(P < 0) 
0536:  BTFSC  3D.7
0538:  BRA    053C
053A:  BRA    054C
....................          { 
....................             P  += dx; 
053C:  MOVF   38,W
053E:  ADDWF  3C,F
0540:  MOVF   39,W
0542:  ADDWFC 3D,F
....................             y1 += addy; 
0544:  MOVF   3B,W
0546:  ADDWF  32,W
0548:  MOVWF  32
....................          } 
....................          else 
054A:  BRA    0560
....................          { 
....................             P  += diff; 
054C:  MOVF   3E,W
054E:  ADDWF  3C,F
0550:  MOVF   3F,W
0552:  ADDWFC 3D,F
....................             x1 += addx; 
0554:  MOVF   3A,W
0556:  ADDWF  31,W
0558:  MOVWF  31
....................             y1 += addy; 
055A:  MOVF   3B,W
055C:  ADDWF  32,W
055E:  MOVWF  32
....................          } 
....................       } 
0560:  INCF   40,F
0562:  BRA    051E
....................    } 
.................... } 
0564:  RETLW  00
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(int16 x1, int16 y1, int16 x2, int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(int8 x1, int8 y1, int8 x2, int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
0566:  MOVF   2A,F
0568:  BZ    05C2
....................    { 
....................       #ifdef LARGE_LCD 
....................       int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
056A:  MOVF   28,W
056C:  SUBWF  26,W
056E:  BC    057A
....................       { 
....................          xmin = x1; 
0570:  MOVFF  26,2D
....................          xmax = x2; 
0574:  MOVFF  28,2E
....................       } 
....................       else 
0578:  BRA    0582
....................       { 
....................          xmin = x2; 
057A:  MOVFF  28,2D
....................          xmax = x1; 
057E:  MOVFF  26,2E
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
0582:  MOVF   29,W
0584:  SUBWF  27,W
0586:  BC    0592
....................       { 
....................          ymin = y1; 
0588:  MOVFF  27,2F
....................          ymax = y2; 
058C:  MOVFF  29,30
....................       } 
....................       else 
0590:  BRA    059A
....................       { 
....................          ymin = y2; 
0592:  MOVFF  29,2F
....................          ymax = y1; 
0596:  MOVFF  27,30
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
059A:  MOVF   2D,W
059C:  SUBWF  2E,W
059E:  BNC   05C0
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
05A0:  MOVFF  2F,2C
05A4:  MOVF   2C,W
05A6:  SUBWF  30,W
05A8:  BNC   05BC
....................          { 
....................             glcd_pixel(xmin, i, color); 
05AA:  MOVFF  2D,41
05AE:  MOVFF  2C,42
05B2:  MOVFF  2B,43
05B6:  RCALL  0364
....................          } 
05B8:  INCF   2C,F
05BA:  BRA    05A4
....................       } 
05BC:  INCF   2D,F
05BE:  BRA    059A
....................    } 
....................    else 
05C0:  BRA    061A
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
05C2:  MOVFF  26,31
05C6:  MOVFF  27,32
05CA:  MOVFF  28,33
05CE:  MOVFF  27,34
05D2:  MOVFF  2B,35
05D6:  RCALL  0434
....................       glcd_line(x1, y2, x2, y2, color); 
05D8:  MOVFF  26,31
05DC:  MOVFF  29,32
05E0:  MOVFF  28,33
05E4:  MOVFF  29,34
05E8:  MOVFF  2B,35
05EC:  RCALL  0434
....................       glcd_line(x1, y1, x1, y2, color); 
05EE:  MOVFF  26,31
05F2:  MOVFF  27,32
05F6:  MOVFF  26,33
05FA:  MOVFF  29,34
05FE:  MOVFF  2B,35
0602:  RCALL  0434
....................       glcd_line(x2, y1, x2, y2, color); 
0604:  MOVFF  28,31
0608:  MOVFF  27,32
060C:  MOVFF  28,33
0610:  MOVFF  29,34
0614:  MOVFF  2B,35
0618:  RCALL  0434
....................    } 
.................... } 
061A:  RETLW  00
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(int16 x1, int16 y1, int16 x2, int16 y2, int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(int8 x1, int8 y1, int8 x2, int8 y2, int8 width, int1 color) 
.................... #endif 
.................... { 
....................    int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    half_width = width/2; 
....................    c1 = -(dx*x1 + dy*y1); 
....................    c2 = -(dx*x2 + dy*y2); 
....................  
....................    if(x1 > x2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addx = -1; 
....................    } 
....................    if(y1 > y2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addy = -1; 
....................    } 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
....................                glcd_pixel(x1, y1+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
....................                glcd_pixel(x1+j, y1, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(int16 x, int16 y, int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(int8 x, int8 y, int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
*
07F8:  CLRF   21
....................    b = radius; 
07FA:  MOVFF  1E,22
....................    P = 1 - radius; 
07FE:  MOVLW  01
0800:  BSF    FD8.0
0802:  SUBFWB 1E,W
0804:  MOVWF  23
....................  
....................    do 
....................    { 
....................       if(fill) 
0806:  MOVF   1F,F
0808:  BZ    08BC
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
080A:  MOVF   21,W
080C:  SUBWF  1C,W
080E:  MOVWF  24
0810:  MOVF   22,W
0812:  ADDWF  1D,W
0814:  MOVWF  25
0816:  MOVF   21,W
0818:  ADDWF  1C,W
081A:  MOVWF  26
081C:  MOVF   22,W
081E:  ADDWF  1D,W
0820:  MOVWF  27
0822:  MOVFF  24,31
0826:  MOVFF  25,32
082A:  MOVFF  26,33
082E:  MOVWF  34
0830:  MOVFF  20,35
0834:  RCALL  0434
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
0836:  MOVF   21,W
0838:  SUBWF  1C,W
083A:  MOVWF  24
083C:  MOVF   22,W
083E:  SUBWF  1D,W
0840:  MOVWF  25
0842:  MOVF   21,W
0844:  ADDWF  1C,W
0846:  MOVWF  26
0848:  MOVF   22,W
084A:  SUBWF  1D,W
084C:  MOVWF  27
084E:  MOVFF  24,31
0852:  MOVFF  25,32
0856:  MOVFF  26,33
085A:  MOVWF  34
085C:  MOVFF  20,35
0860:  RCALL  0434
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
0862:  MOVF   22,W
0864:  SUBWF  1C,W
0866:  MOVWF  24
0868:  MOVF   21,W
086A:  ADDWF  1D,W
086C:  MOVWF  25
086E:  MOVF   22,W
0870:  ADDWF  1C,W
0872:  MOVWF  26
0874:  MOVF   21,W
0876:  ADDWF  1D,W
0878:  MOVWF  27
087A:  MOVFF  24,31
087E:  MOVFF  25,32
0882:  MOVFF  26,33
0886:  MOVWF  34
0888:  MOVFF  20,35
088C:  RCALL  0434
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
088E:  MOVF   22,W
0890:  SUBWF  1C,W
0892:  MOVWF  24
0894:  MOVF   21,W
0896:  SUBWF  1D,W
0898:  MOVWF  25
089A:  MOVF   22,W
089C:  ADDWF  1C,W
089E:  MOVWF  26
08A0:  MOVF   21,W
08A2:  SUBWF  1D,W
08A4:  MOVWF  27
08A6:  MOVFF  24,31
08AA:  MOVFF  25,32
08AE:  MOVFF  26,33
08B2:  MOVWF  34
08B4:  MOVFF  20,35
08B8:  RCALL  0434
....................       } 
....................       else 
08BA:  BRA    097C
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
08BC:  MOVF   1C,W
08BE:  ADDWF  21,W
08C0:  MOVWF  24
08C2:  MOVF   1D,W
08C4:  ADDWF  22,W
08C6:  MOVWF  25
08C8:  MOVFF  24,41
08CC:  MOVWF  42
08CE:  MOVFF  20,43
08D2:  RCALL  0364
....................          glcd_pixel(b+x, a+y, color); 
08D4:  MOVF   1C,W
08D6:  ADDWF  22,W
08D8:  MOVWF  24
08DA:  MOVF   1D,W
08DC:  ADDWF  21,W
08DE:  MOVWF  25
08E0:  MOVFF  24,41
08E4:  MOVWF  42
08E6:  MOVFF  20,43
08EA:  RCALL  0364
....................          glcd_pixel(x-a, b+y, color); 
08EC:  MOVF   21,W
08EE:  SUBWF  1C,W
08F0:  MOVWF  24
08F2:  MOVF   1D,W
08F4:  ADDWF  22,W
08F6:  MOVWF  25
08F8:  MOVFF  24,41
08FC:  MOVWF  42
08FE:  MOVFF  20,43
0902:  RCALL  0364
....................          glcd_pixel(x-b, a+y, color); 
0904:  MOVF   22,W
0906:  SUBWF  1C,W
0908:  MOVWF  24
090A:  MOVF   1D,W
090C:  ADDWF  21,W
090E:  MOVWF  25
0910:  MOVFF  24,41
0914:  MOVWF  42
0916:  MOVFF  20,43
091A:  RCALL  0364
....................          glcd_pixel(b+x, y-a, color); 
091C:  MOVF   1C,W
091E:  ADDWF  22,W
0920:  MOVWF  24
0922:  MOVF   21,W
0924:  SUBWF  1D,W
0926:  MOVWF  25
0928:  MOVFF  24,41
092C:  MOVWF  42
092E:  MOVFF  20,43
0932:  RCALL  0364
....................          glcd_pixel(a+x, y-b, color); 
0934:  MOVF   1C,W
0936:  ADDWF  21,W
0938:  MOVWF  24
093A:  MOVF   22,W
093C:  SUBWF  1D,W
093E:  MOVWF  25
0940:  MOVFF  24,41
0944:  MOVWF  42
0946:  MOVFF  20,43
094A:  RCALL  0364
....................          glcd_pixel(x-a, y-b, color); 
094C:  MOVF   21,W
094E:  SUBWF  1C,W
0950:  MOVWF  24
0952:  MOVF   22,W
0954:  SUBWF  1D,W
0956:  MOVWF  25
0958:  MOVFF  24,41
095C:  MOVWF  42
095E:  MOVFF  20,43
0962:  RCALL  0364
....................          glcd_pixel(x-b, y-a, color); 
0964:  MOVF   22,W
0966:  SUBWF  1C,W
0968:  MOVWF  24
096A:  MOVF   21,W
096C:  SUBWF  1D,W
096E:  MOVWF  25
0970:  MOVFF  24,41
0974:  MOVWF  42
0976:  MOVFF  20,43
097A:  RCALL  0364
....................       } 
....................  
....................       if(P < 0) 
097C:  BTFSC  23.7
097E:  BRA    0982
0980:  BRA    099A
....................          P += 3 + 2 * a++; 
0982:  MOVF   21,W
0984:  INCF   21,F
0986:  MOVWF  24
0988:  MOVLW  02
098A:  MOVWF  26
098C:  MOVFF  24,27
0990:  RCALL  07AE
0992:  MOVF   01,W
0994:  ADDLW  03
0996:  ADDWF  23,F
....................       else 
0998:  BRA    09B8
....................          P += 5 + 2 * (a++ - b--); 
099A:  MOVF   21,W
099C:  INCF   21,F
099E:  MOVWF  24
09A0:  MOVF   22,W
09A2:  DECF   22,F
09A4:  SUBWF  24,W
09A6:  MOVWF  25
09A8:  MOVLW  02
09AA:  MOVWF  26
09AC:  MOVFF  25,27
09B0:  RCALL  07AE
09B2:  MOVF   01,W
09B4:  ADDLW  05
09B6:  ADDWF  23,F
....................     } while(a <= b); 
09B8:  MOVF   21,W
09BA:  XORLW  80
09BC:  MOVWF  00
09BE:  MOVF   22,W
09C0:  XORLW  80
09C2:  SUBWF  00,W
09C4:  BTFSC  FD8.2
09C6:  BRA    0806
09C8:  BTFSS  FD8.0
09CA:  BRA    0806
.................... } 
09CC:  GOTO   16E4 (RETURN)
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(int16 x, int16 y, char* textptr, int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(int8 x, int8 y, char* textptr, int8 size, int1 color) 
.................... #endif 
.................... { 
....................    int8 j, k, l, m;                       // Loop counters 
....................    int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
*
061C:  MOVFF  29,03
0620:  MOVFF  28,FE9
0624:  MOVFF  29,FEA
0628:  MOVF   FEF,F
062A:  BTFSC  FD8.2
062C:  BRA    07AC
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
062E:  MOVFF  29,03
0632:  MOVFF  28,FE9
0636:  MOVFF  29,FEA
063A:  MOVF   FEF,W
063C:  SUBLW  52
063E:  BNC   0686
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
0640:  MOVFF  29,03
0644:  MOVFF  28,FE9
0648:  MOVFF  29,FEA
064C:  MOVLW  20
064E:  SUBWF  FEF,W
0650:  MULLW  05
0652:  MOVF   FF3,W
0654:  CLRF   03
0656:  MOVWF  37
0658:  CLRF   FEA
065A:  MOVLW  30
065C:  MOVWF  FE9
065E:  CLRF   3B
0660:  MOVFF  37,3A
0664:  MOVFF  FF2,38
0668:  BCF    FF2.7
066A:  MOVLW  05
066C:  MOVWF  01
066E:  CLRF   FF7
0670:  MOVF   37,W
0672:  RCALL  0004
0674:  TBLRD*-
0676:  TBLRD*+
0678:  MOVFF  FF5,FEE
067C:  DECFSZ 01,F
067E:  BRA    0676
0680:  BTFSC  38.7
0682:  BSF    FF2.7
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
0684:  BRA    06E8
0686:  MOVFF  29,03
068A:  MOVFF  28,FE9
068E:  MOVFF  29,FEA
0692:  MOVF   FEF,W
0694:  SUBLW  7E
0696:  BNC   06DE
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
0698:  MOVFF  29,03
069C:  MOVFF  28,FE9
06A0:  MOVFF  29,FEA
06A4:  MOVLW  53
06A6:  SUBWF  FEF,W
06A8:  MULLW  05
06AA:  MOVF   FF3,W
06AC:  CLRF   03
06AE:  MOVWF  37
06B0:  CLRF   FEA
06B2:  MOVLW  30
06B4:  MOVWF  FE9
06B6:  CLRF   3B
06B8:  MOVFF  37,3A
06BC:  MOVFF  FF2,38
06C0:  BCF    FF2.7
06C2:  MOVLW  05
06C4:  MOVWF  01
06C6:  CLRF   FF7
06C8:  MOVF   37,W
06CA:  RCALL  0114
06CC:  TBLRD*-
06CE:  TBLRD*+
06D0:  MOVFF  FF5,FEE
06D4:  DECFSZ 01,F
06D6:  BRA    06CE
06D8:  BTFSC  38.7
06DA:  BSF    FF2.7
....................       else 
06DC:  BRA    06E8
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
06DE:  CLRF   30
06E0:  CLRF   31
06E2:  CLRF   32
06E4:  CLRF   33
06E6:  CLRF   34
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
....................       { 
06E8:  MOVFF  29,03
06EC:  MOVFF  28,FE9
06F0:  MOVFF  29,FEA
06F4:  MOVF   FEF,W
06F6:  XORLW  0A
06F8:  BZ    0700
06FA:  XORLW  07
06FC:  BZ    070C
06FE:  BRA    0710
....................          case '\n': 
....................             y += 7*size + 1; 
0700:  MOVF   2A,W
0702:  MULLW  07
0704:  MOVF   FF3,W
0706:  ADDLW  01
0708:  ADDWF  27,F
....................             continue; 
070A:  BRA    07A2
....................          case '\r': 
....................             x = 0; 
070C:  CLRF   26
....................             continue; 
070E:  BRA    07A2
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
0710:  MOVF   2A,W
0712:  MULLW  05
0714:  MOVF   FF3,W
0716:  ADDWF  26,W
0718:  SUBLW  7F
071A:  BC    0728
....................       { 
....................          x = 0;                           // Set x at far left position 
071C:  CLRF   26
....................          y += 7*size + 1;                 // Set y at next position down 
071E:  MOVF   2A,W
0720:  MULLW  07
0722:  MOVF   FF3,W
0724:  ADDLW  01
0726:  ADDWF  27,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0728:  CLRF   2C
072A:  MOVF   2C,W
072C:  SUBLW  04
072E:  BNC   07A2
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
0730:  CLRF   2D
0732:  MOVF   2D,W
0734:  SUBLW  06
0736:  BNC   079A
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
0738:  CLRF   03
073A:  MOVF   2C,W
073C:  ADDLW  30
073E:  MOVWF  FE9
0740:  MOVLW  00
0742:  ADDWFC 03,W
0744:  MOVWF  FEA
0746:  MOVFF  FEF,35
074A:  MOVFF  35,00
074E:  MOVF   2D,W
0750:  MOVWF  01
0752:  BZ    075C
0754:  BCF    FD8.0
0756:  RRCF   00,F
0758:  DECFSZ 01,F
075A:  BRA    0754
075C:  BTFSS  00.0
075E:  BRA    0796
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
0760:  CLRF   2E
0762:  MOVF   2A,W
0764:  SUBWF  2E,W
0766:  BC    0796
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
0768:  CLRF   2F
076A:  MOVF   2A,W
076C:  SUBWF  2F,W
076E:  BC    0792
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
0770:  MOVF   2F,W
0772:  ADDWF  26,W
0774:  MOVWF  35
0776:  MOVF   2D,W
0778:  MULWF  2A
077A:  MOVF   FF3,W
077C:  ADDWF  27,W
077E:  ADDWF  2E,W
0780:  MOVWF  37
0782:  MOVFF  35,41
0786:  MOVWF  42
0788:  MOVFF  2B,43
078C:  RCALL  0364
....................                   } 
078E:  INCF   2F,F
0790:  BRA    076A
....................                } 
0792:  INCF   2E,F
0794:  BRA    0762
....................             } 
....................          } 
0796:  INCF   2D,F
0798:  BRA    0732
....................       } 
079A:  INCF   2C,F
079C:  MOVF   2A,W
079E:  ADDWF  26,F
07A0:  BRA    072A
....................    } 
07A2:  INCF   28,F
07A4:  BTFSC  FD8.2
07A6:  INCF   29,F
07A8:  INCF   26,F
07AA:  BRA    061C
.................... } 
07AC:  RETLW  00
....................  
.................... #endif 
....................  
.................... #include "math.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.141592654 
....................  
....................  
.................... #define SQRT2  1.41421356 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float CEIL_FLOOR(float x, int n) 
.................... { 
....................    float y, res; 
....................    long l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float)(long)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (long)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float)l); 
....................   res = 32768.0*(float)l; 
....................   res += (float)(long)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float)(long)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float floor(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float ceil(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //	float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float x,float y) 
.................... { 
....................    float i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
....................  
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
....................  
.................... #define LN2 0.6931471806 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... float exp(float x) 
.................... { 
....................    float y, res, r; 
....................    signed int n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed long)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................    *(&res) = n + 0x7F; 
....................  
....................    y = y/LN2 - (float)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... /************************************************************/ 
....................  
.................... float const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float log(float x) 
.................... { 
....................    float y, res, r, y2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................       *(&y) = 0x7E; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................       n = *(&x) - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float)-n; 
....................       else 
....................          r = (float)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... #define LN10 2.30258509 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float log10(float x) 
.................... { 
....................    float r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float modf(float value,float *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pwr(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pow(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float sqrt(float x) 
.................... { 
....................    float y, res; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p=&y; 
....................    (*p)=(BYTE)((((int16)(*p)) + 127) >> 1); 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................       (*p)--; 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
....................  
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO	1.570796326794896 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI 			0.6366197724 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float cos(float x) 
.................... { 
.................... 	float y, t, t2 = 1.0; 
*
126C:  MOVLW  7F
126E:  MOVWF  30
1270:  CLRF   31
1272:  CLRF   32
1274:  CLRF   33
.................... 	int quad, i; 
.................... 	float frac; 
.................... 	float p[4] = { 
.................... 		-0.499999993585, 
.................... 		 0.041666636258, 
.................... 		-0.0013888361399, 
.................... 		 0.00002476016134 
.................... 	}; 
1276:  MOVLW  7E
1278:  MOVWF  3A
127A:  MOVLW  80
127C:  MOVWF  3B
127E:  CLRF   3C
1280:  CLRF   3D
1282:  MOVLW  7A
1284:  MOVWF  3E
1286:  MOVLW  2A
1288:  MOVWF  3F
128A:  MOVLW  AA
128C:  MOVWF  40
128E:  MOVLW  A3
1290:  MOVWF  41
1292:  MOVLW  75
1294:  MOVWF  42
1296:  MOVLW  B6
1298:  MOVWF  43
129A:  MOVLW  09
129C:  MOVWF  44
129E:  MOVLW  9C
12A0:  MOVWF  45
12A2:  MOVLW  6F
12A4:  MOVWF  46
12A6:  MOVLW  4F
12A8:  MOVWF  47
12AA:  MOVLW  B4
12AC:  MOVWF  48
12AE:  MOVLW  0B
12B0:  MOVWF  49
....................  
.................... 	if (x < 0) x = -x;                  // absolute value of input 
12B2:  MOVFF  27,4D
12B6:  MOVFF  26,4C
12BA:  MOVFF  25,4B
12BE:  MOVFF  24,4A
12C2:  CLRF   51
12C4:  CLRF   50
12C6:  CLRF   4F
12C8:  CLRF   4E
12CA:  RCALL  1060
12CC:  BNC   12D2
12CE:  MOVLW  80
12D0:  XORWF  25,F
....................  
.................... 	quad = (int)(x / PI_DIV_BY_TWO);    // quadrant 
12D2:  MOVFF  27,4D
12D6:  MOVFF  26,4C
12DA:  MOVFF  25,4B
12DE:  MOVFF  24,4A
12E2:  MOVLW  DB
12E4:  MOVWF  51
12E6:  MOVLW  0F
12E8:  MOVWF  50
12EA:  MOVLW  49
12EC:  MOVWF  4F
12EE:  MOVLW  7F
12F0:  MOVWF  4E
12F2:  RCALL  10D6
12F4:  MOVFF  03,4D
12F8:  MOVFF  02,4C
12FC:  MOVFF  01,4B
1300:  MOVFF  00,4A
1304:  RCALL  1232
1306:  MOVFF  01,34
.................... 	frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
130A:  MOVFF  27,4D
130E:  MOVFF  26,4C
1312:  MOVFF  25,4B
1316:  MOVFF  24,4A
131A:  MOVLW  DB
131C:  MOVWF  51
131E:  MOVLW  0F
1320:  MOVWF  50
1322:  MOVLW  49
1324:  MOVWF  4F
1326:  MOVLW  7F
1328:  MOVWF  4E
132A:  RCALL  10D6
132C:  MOVFF  00,4A
1330:  MOVFF  01,4B
1334:  MOVFF  02,4C
1338:  MOVFF  03,4D
133C:  CLRF   4F
133E:  MOVFF  34,4E
1342:  CALL   09D0
1346:  BSF    FD8.1
1348:  MOVFF  4D,53
134C:  MOVFF  4C,52
1350:  MOVFF  4B,51
1354:  MOVFF  4A,50
1358:  MOVFF  03,57
135C:  MOVFF  02,56
1360:  MOVFF  01,55
1364:  MOVFF  00,54
1368:  RCALL  0DF4
136A:  MOVFF  03,39
136E:  MOVFF  02,38
1372:  MOVFF  01,37
1376:  MOVFF  00,36
.................... 	quad = quad % 4;                    // quadrant (0 to 3) 
137A:  MOVLW  03
137C:  ANDWF  34,F
....................  
.................... 	if (quad == 0 || quad == 2) 
137E:  MOVF   34,F
1380:  BZ    1388
1382:  MOVF   34,W
1384:  SUBLW  02
1386:  BNZ   13BE
.................... 		t = frac * PI_DIV_BY_TWO; 
1388:  MOVFF  39,51
138C:  MOVFF  38,50
1390:  MOVFF  37,4F
1394:  MOVFF  36,4E
1398:  MOVLW  DB
139A:  MOVWF  55
139C:  MOVLW  0F
139E:  MOVWF  54
13A0:  MOVLW  49
13A2:  MOVWF  53
13A4:  MOVLW  7F
13A6:  MOVWF  52
13A8:  CALL   0A08
13AC:  MOVFF  03,2F
13B0:  MOVFF  02,2E
13B4:  MOVFF  01,2D
13B8:  MOVFF  00,2C
.................... 	else if (quad == 1) 
13BC:  BRA    1488
13BE:  DECFSZ 34,W
13C0:  BRA    1426
.................... 		t = (1-frac) * PI_DIV_BY_TWO; 
13C2:  BSF    FD8.1
13C4:  CLRF   53
13C6:  CLRF   52
13C8:  CLRF   51
13CA:  MOVLW  7F
13CC:  MOVWF  50
13CE:  MOVFF  39,57
13D2:  MOVFF  38,56
13D6:  MOVFF  37,55
13DA:  MOVFF  36,54
13DE:  RCALL  0DF4
13E0:  MOVFF  00,4A
13E4:  MOVFF  01,4B
13E8:  MOVFF  02,4C
13EC:  MOVFF  03,4D
13F0:  MOVFF  03,51
13F4:  MOVFF  02,50
13F8:  MOVFF  01,4F
13FC:  MOVFF  00,4E
1400:  MOVLW  DB
1402:  MOVWF  55
1404:  MOVLW  0F
1406:  MOVWF  54
1408:  MOVLW  49
140A:  MOVWF  53
140C:  MOVLW  7F
140E:  MOVWF  52
1410:  CALL   0A08
1414:  MOVFF  03,2F
1418:  MOVFF  02,2E
141C:  MOVFF  01,2D
1420:  MOVFF  00,2C
.................... 	else // should be 3 
1424:  BRA    1488
.................... 		t = (frac-1) * PI_DIV_BY_TWO; 
1426:  BSF    FD8.1
1428:  MOVFF  39,53
142C:  MOVFF  38,52
1430:  MOVFF  37,51
1434:  MOVFF  36,50
1438:  CLRF   57
143A:  CLRF   56
143C:  CLRF   55
143E:  MOVLW  7F
1440:  MOVWF  54
1442:  RCALL  0DF4
1444:  MOVFF  00,4A
1448:  MOVFF  01,4B
144C:  MOVFF  02,4C
1450:  MOVFF  03,4D
1454:  MOVFF  03,51
1458:  MOVFF  02,50
145C:  MOVFF  01,4F
1460:  MOVFF  00,4E
1464:  MOVLW  DB
1466:  MOVWF  55
1468:  MOVLW  0F
146A:  MOVWF  54
146C:  MOVLW  49
146E:  MOVWF  53
1470:  MOVLW  7F
1472:  MOVWF  52
1474:  CALL   0A08
1478:  MOVFF  03,2F
147C:  MOVFF  02,2E
1480:  MOVFF  01,2D
1484:  MOVFF  00,2C
....................  
.................... 	y = 0.999999999781; 
1488:  CLRF   2B
148A:  CLRF   2A
148C:  CLRF   29
148E:  MOVLW  7F
1490:  MOVWF  28
.................... 	t = t * t; 
1492:  MOVFF  2F,51
1496:  MOVFF  2E,50
149A:  MOVFF  2D,4F
149E:  MOVFF  2C,4E
14A2:  MOVFF  2F,55
14A6:  MOVFF  2E,54
14AA:  MOVFF  2D,53
14AE:  MOVFF  2C,52
14B2:  CALL   0A08
14B6:  MOVFF  03,2F
14BA:  MOVFF  02,2E
14BE:  MOVFF  01,2D
14C2:  MOVFF  00,2C
.................... 	for (i = 0; i <= 3; i++) 
14C6:  CLRF   35
14C8:  MOVF   35,W
14CA:  SUBLW  03
14CC:  BNC   1590
.................... 	{ 
.................... 		t2 = t2 * t; 
14CE:  MOVFF  33,51
14D2:  MOVFF  32,50
14D6:  MOVFF  31,4F
14DA:  MOVFF  30,4E
14DE:  MOVFF  2F,55
14E2:  MOVFF  2E,54
14E6:  MOVFF  2D,53
14EA:  MOVFF  2C,52
14EE:  CALL   0A08
14F2:  MOVFF  03,33
14F6:  MOVFF  02,32
14FA:  MOVFF  01,31
14FE:  MOVFF  00,30
.................... 		y = y + p[i] * t2; 
1502:  MOVF   35,W
1504:  MULLW  04
1506:  MOVF   FF3,W
1508:  CLRF   03
150A:  ADDLW  3A
150C:  MOVWF  FE9
150E:  MOVLW  00
1510:  ADDWFC 03,W
1512:  MOVWF  FEA
1514:  MOVFF  FEF,4A
1518:  MOVFF  FEC,4B
151C:  MOVFF  FEC,4C
1520:  MOVFF  FEC,4D
1524:  MOVFF  4D,51
1528:  MOVFF  4C,50
152C:  MOVFF  4B,4F
1530:  MOVFF  4A,4E
1534:  MOVFF  33,55
1538:  MOVFF  32,54
153C:  MOVFF  31,53
1540:  MOVFF  30,52
1544:  CALL   0A08
1548:  MOVFF  FEA,4F
154C:  MOVFF  FE9,4E
1550:  BCF    FD8.1
1552:  MOVFF  2B,53
1556:  MOVFF  2A,52
155A:  MOVFF  29,51
155E:  MOVFF  28,50
1562:  MOVFF  03,57
1566:  MOVFF  02,56
156A:  MOVFF  01,55
156E:  MOVFF  00,54
1572:  RCALL  0DF4
1574:  MOVFF  4F,FEA
1578:  MOVFF  4E,FE9
157C:  MOVFF  03,2B
1580:  MOVFF  02,2A
1584:  MOVFF  01,29
1588:  MOVFF  00,28
.................... 	} 
158C:  INCF   35,F
158E:  BRA    14C8
....................  
.................... 	if (quad == 2 || quad == 1) 
1590:  MOVF   34,W
1592:  SUBLW  02
1594:  BZ    159A
1596:  DECFSZ 34,W
1598:  BRA    159E
.................... 		y = -y;  // correct sign 
159A:  MOVLW  80
159C:  XORWF  29,F
....................  
.................... 	return (y); 
159E:  MOVFF  28,00
15A2:  MOVFF  29,01
15A6:  MOVFF  2A,02
15AA:  MOVFF  2B,03
.................... } 
15AE:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float sin(float x) 
.................... { 
.................... 	return cos(x - PI_DIV_BY_TWO); 
15B0:  BSF    FD8.1
15B2:  MOVFF  1F,53
15B6:  MOVFF  1E,52
15BA:  MOVFF  1D,51
15BE:  MOVFF  1C,50
15C2:  MOVLW  DB
15C4:  MOVWF  57
15C6:  MOVLW  0F
15C8:  MOVWF  56
15CA:  MOVLW  49
15CC:  MOVWF  55
15CE:  MOVLW  7F
15D0:  MOVWF  54
15D2:  RCALL  0DF4
15D4:  MOVFF  00,20
15D8:  MOVFF  01,21
15DC:  MOVFF  02,22
15E0:  MOVFF  03,23
15E4:  MOVFF  03,27
15E8:  MOVFF  02,26
15EC:  MOVFF  01,25
15F0:  MOVFF  00,24
15F4:  RCALL  126C
.................... } 
15F6:  RETLW  00
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float tan(float x) 
.................... { 
....................    float c, s; 
....................  
....................    c = cos(x); 
.................... 	if (c == 0.0) 
.................... 	   return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
....................  
....................  
.................... float const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float ASIN_COS(float x, int n) 
.................... { 
....................    float y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float asin(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float acos(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... float const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float atan(float x) 
.................... { 
....................    float y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //	float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
....................  
.................... float atan2(float y,float x) 
.................... { 
....................    float z; 
....................    int1 sign; 
....................    int quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float cosh(float x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float sinh(float x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float tanh(float x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
....................  
....................  
.................... #define LOG2 .30102999566398119521 
.................... float frexp(float x, signed int *exp) 
.................... { 
....................    float res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //	float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float ldexp(float value, signed int exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
....................  
.................... void displayVoltage(int adc) { 
....................    char voltage[9]; 
....................    sprintf(voltage, "%f", (float)adc * .01960784); // Converts adc to text 
*
0D54:  CLRF   4F
0D56:  MOVFF  1C,4E
0D5A:  RCALL  09D0
0D5C:  MOVFF  00,26
0D60:  MOVFF  01,27
0D64:  MOVFF  02,28
0D68:  MOVFF  03,29
0D6C:  MOVFF  03,51
0D70:  MOVFF  02,50
0D74:  MOVFF  01,4F
0D78:  MOVFF  00,4E
0D7C:  MOVLW  9F
0D7E:  MOVWF  55
0D80:  MOVLW  A0
0D82:  MOVWF  54
0D84:  MOVLW  20
0D86:  MOVWF  53
0D88:  MOVLW  79
0D8A:  MOVWF  52
0D8C:  RCALL  0A08
0D8E:  MOVFF  00,2A
0D92:  MOVFF  01,2B
0D96:  MOVFF  02,2C
0D9A:  MOVFF  03,2D
0D9E:  CLRF   06
0DA0:  MOVLW  1D
0DA2:  MOVWF  05
0DA4:  MOVLW  89
0DA6:  MOVWF  FE9
0DA8:  MOVFF  03,31
0DAC:  MOVFF  02,30
0DB0:  MOVFF  01,2F
0DB4:  MOVFF  00,2E
0DB8:  MOVLW  06
0DBA:  MOVWF  32
0DBC:  BRA    0BD4
....................    voltage[4] = '\0';                              // Limit shown digits to 3 
0DBE:  CLRF   21
....................    glcd_rect(45, 18, 69, 25, YES, OFF);            // Clear the old voltage 
0DC0:  MOVLW  2D
0DC2:  MOVWF  26
0DC4:  MOVLW  12
0DC6:  MOVWF  27
0DC8:  MOVLW  45
0DCA:  MOVWF  28
0DCC:  MOVLW  19
0DCE:  MOVWF  29
0DD0:  MOVLW  01
0DD2:  MOVWF  2A
0DD4:  CLRF   2B
0DD6:  CALL   0566
....................    glcd_text57(45, 18, voltage, 1, ON);            // Write the new voltage 
0DDA:  MOVLW  2D
0DDC:  MOVWF  26
0DDE:  MOVLW  12
0DE0:  MOVWF  27
0DE2:  CLRF   29
0DE4:  MOVLW  1D
0DE6:  MOVWF  28
0DE8:  MOVLW  01
0DEA:  MOVWF  2A
0DEC:  MOVWF  2B
0DEE:  RCALL  061C
.................... } 
0DF0:  GOTO   16F6 (RETURN)
....................  
.................... void main() { 
*
1620:  CLRF   FF8
1622:  BCF    FD0.7
1624:  CLRF   FEA
1626:  CLRF   FE9
1628:  BSF    FC1.0
162A:  BSF    FC1.1
162C:  BSF    FC1.2
162E:  BCF    FC1.3
1630:  CLRF   05
1632:  CLRF   06
....................    int1  warn = FALSE; 
1634:  BCF    07.0
....................    int8  adc = 0, adc_old = 0; 
1636:  CLRF   08
1638:  CLRF   09
....................    char  voltText[] = "Volts", warning[] = "Warning"; 
163A:  MOVLW  56
163C:  MOVWF  0A
163E:  MOVLW  6F
1640:  MOVWF  0B
1642:  MOVLW  6C
1644:  MOVWF  0C
1646:  MOVLW  74
1648:  MOVWF  0D
164A:  MOVLW  73
164C:  MOVWF  0E
164E:  CLRF   0F
1650:  MOVLW  57
1652:  MOVWF  10
1654:  MOVLW  61
1656:  MOVWF  11
1658:  MOVLW  72
165A:  MOVWF  12
165C:  MOVLW  6E
165E:  MOVWF  13
1660:  MOVLW  69
1662:  MOVWF  14
1664:  MOVLW  6E
1666:  MOVWF  15
1668:  MOVLW  67
166A:  MOVWF  16
166C:  CLRF   17
....................    float theta = 0; 
166E:  CLRF   18
1670:  CLRF   19
1672:  CLRF   1A
1674:  CLRF   1B
....................  
....................    setup_adc_ports(RA0_ANALOG); 
1676:  BCF    FC1.0
1678:  BSF    FC1.1
167A:  BSF    FC1.2
167C:  BSF    FC1.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
167E:  BCF    FC1.6
1680:  BSF    FC2.6
1682:  BSF    FC2.7
1684:  BCF    FC1.7
1686:  BSF    FC2.0
....................    set_adc_channel(0); 
1688:  MOVLW  00
168A:  MOVWF  01
168C:  MOVF   FC2,W
168E:  ANDLW  C7
1690:  IORWF  01,W
1692:  MOVWF  FC2
....................  
....................    glcd_init(ON);                               // Must initialize the LCD 
1694:  MOVLW  01
1696:  MOVWF  1C
1698:  GOTO   02AA
....................    glcd_rect(1, 5, 126, 15, NO, ON);            // Outline the bar 
169C:  MOVLW  01
169E:  MOVWF  26
16A0:  MOVLW  05
16A2:  MOVWF  27
16A4:  MOVLW  7E
16A6:  MOVWF  28
16A8:  MOVLW  0F
16AA:  MOVWF  29
16AC:  CLRF   2A
16AE:  MOVLW  01
16B0:  MOVWF  2B
16B2:  CALL   0566
....................    glcd_text57(70, 18, voltText, 1, ON);        // Display "Volts" 
16B6:  MOVLW  46
16B8:  MOVWF  26
16BA:  MOVLW  12
16BC:  MOVWF  27
16BE:  CLRF   29
16C0:  MOVLW  0A
16C2:  MOVWF  28
16C4:  MOVLW  01
16C6:  MOVWF  2A
16C8:  MOVWF  2B
16CA:  CALL   061C
....................    glcd_circle(30, 47, 10, NO, ON);             // Draw the clock circle 
16CE:  MOVLW  1E
16D0:  MOVWF  1C
16D2:  MOVLW  2F
16D4:  MOVWF  1D
16D6:  MOVLW  0A
16D8:  MOVWF  1E
16DA:  CLRF   1F
16DC:  MOVLW  01
16DE:  MOVWF  20
16E0:  GOTO   07F8
....................  
....................    for(;;) { 
....................       adc = read_adc();                         // Read a value from the ADC 
16E4:  BSF    FC2.2
16E6:  BTFSC  FC2.2
16E8:  BRA    16E6
16EA:  MOVFF  FC4,08
....................       displayVoltage(adc);                      // Display the reading 
16EE:  MOVFF  08,1C
16F2:  GOTO   0D54
....................       adc = (adc > 249) ? 249 : adc;            // Keep the value 249 or less 
16F6:  MOVF   08,W
16F8:  SUBLW  F9
16FA:  BC    1700
16FC:  MOVLW  F9
16FE:  BRA    1702
1700:  MOVF   08,W
1702:  MOVWF  08
....................  
....................       if(adc != adc_old) { 
1704:  MOVF   09,W
1706:  SUBWF  08,W
1708:  BZ    17C0
....................          glcd_rect(adc/2+1, 6, adc_old/2+1, 14, YES, OFF);  // Clears the old bar 
170A:  BCF    FD8.0
170C:  RRCF   08,W
170E:  ADDLW  01
1710:  MOVWF  1D
1712:  BCF    FD8.0
1714:  RRCF   09,W
1716:  ADDLW  01
1718:  MOVWF  1F
171A:  MOVFF  1D,26
171E:  MOVLW  06
1720:  MOVWF  27
1722:  MOVFF  1F,28
1726:  MOVLW  0E
1728:  MOVWF  29
172A:  MOVLW  01
172C:  MOVWF  2A
172E:  CLRF   2B
1730:  CALL   0566
....................          glcd_rect(1, 6, adc/2+1, 14, YES, ON);             // Draws a new bar 
1734:  BCF    FD8.0
1736:  RRCF   08,W
1738:  ADDLW  01
173A:  MOVWF  1D
173C:  MOVLW  01
173E:  MOVWF  26
1740:  MOVLW  06
1742:  MOVWF  27
1744:  MOVFF  1D,28
1748:  MOVLW  0E
174A:  MOVWF  29
174C:  MOVLW  01
174E:  MOVWF  2A
1750:  MOVWF  2B
1752:  CALL   0566
....................          adc_old = adc;                                     // Set old value to new 
1756:  MOVFF  08,09
....................  
....................          if(adc > 200 && !warn) {                  // Check if over 4 volts 
175A:  MOVF   08,W
175C:  SUBLW  C8
175E:  BC    179A
1760:  BTFSC  07.0
1762:  BRA    179A
....................             glcd_rect(45, 38, 124, 55, YES, ON);   // Draw a filled black rectangle 
1764:  MOVLW  2D
1766:  MOVWF  26
1768:  MOVLW  26
176A:  MOVWF  27
176C:  MOVLW  7C
176E:  MOVWF  28
1770:  MOVLW  37
1772:  MOVWF  29
1774:  MOVLW  01
1776:  MOVWF  2A
1778:  MOVWF  2B
177A:  CALL   0566
....................             glcd_text57(47, 40, warning, 2, OFF);  // Write "Warning" on the LCD 
177E:  MOVLW  2F
1780:  MOVWF  26
1782:  MOVLW  28
1784:  MOVWF  27
1786:  CLRF   29
1788:  MOVLW  10
178A:  MOVWF  28
178C:  MOVLW  02
178E:  MOVWF  2A
1790:  CLRF   2B
1792:  CALL   061C
....................             warn = TRUE; } 
1796:  BSF    07.0
....................          else if(adc <=200 && warn) { 
1798:  BRA    17C0
179A:  MOVF   08,W
179C:  SUBLW  C8
179E:  BNC   17C0
17A0:  BTFSS  07.0
17A2:  BRA    17C0
....................             glcd_rect(45, 37, 125, 55, YES, OFF);  // Draw a filled white rectangle 
17A4:  MOVLW  2D
17A6:  MOVWF  26
17A8:  MOVLW  25
17AA:  MOVWF  27
17AC:  MOVLW  7D
17AE:  MOVWF  28
17B0:  MOVLW  37
17B2:  MOVWF  29
17B4:  MOVLW  01
17B6:  MOVWF  2A
17B8:  CLRF   2B
17BA:  CALL   0566
....................             warn = FALSE; } 
17BE:  BCF    07.0
....................       } 
....................  
....................       // The following 3 lines make the clock hand spin around 
....................       glcd_line(30, 47, 30+(int)(8*sin(theta)+.5), 47-(int)(8*cos(theta)+.5), OFF); 
17C0:  MOVFF  1B,1F
17C4:  MOVFF  1A,1E
17C8:  MOVFF  19,1D
17CC:  MOVFF  18,1C
17D0:  RCALL  15B0
17D2:  CLRF   51
17D4:  CLRF   50
17D6:  CLRF   4F
17D8:  MOVLW  82
17DA:  MOVWF  4E
17DC:  MOVFF  03,55
17E0:  MOVFF  02,54
17E4:  MOVFF  01,53
17E8:  MOVFF  00,52
17EC:  CALL   0A08
17F0:  MOVFF  00,1C
17F4:  MOVFF  01,1D
17F8:  MOVFF  02,1E
17FC:  MOVFF  03,1F
1800:  MOVFF  FEA,21
1804:  MOVFF  FE9,20
1808:  BCF    FD8.1
180A:  MOVFF  03,53
180E:  MOVFF  02,52
1812:  MOVFF  01,51
1816:  MOVFF  00,50
181A:  CLRF   57
181C:  CLRF   56
181E:  CLRF   55
1820:  MOVLW  7E
1822:  MOVWF  54
1824:  CALL   0DF4
1828:  MOVFF  21,FEA
182C:  MOVFF  20,FE9
1830:  MOVFF  03,4D
1834:  MOVFF  02,4C
1838:  MOVFF  01,4B
183C:  MOVFF  00,4A
1840:  RCALL  1232
1842:  MOVLW  1E
1844:  ADDWF  01,W
1846:  MOVWF  22
1848:  MOVFF  1B,27
184C:  MOVFF  1A,26
1850:  MOVFF  19,25
1854:  MOVFF  18,24
1858:  RCALL  126C
185A:  CLRF   51
185C:  CLRF   50
185E:  CLRF   4F
1860:  MOVLW  82
1862:  MOVWF  4E
1864:  MOVFF  03,55
1868:  MOVFF  02,54
186C:  MOVFF  01,53
1870:  MOVFF  00,52
1874:  CALL   0A08
1878:  MOVFF  00,23
187C:  MOVFF  01,24
1880:  MOVFF  02,25
1884:  MOVFF  03,26
1888:  MOVFF  FEA,28
188C:  MOVFF  FE9,27
1890:  BCF    FD8.1
1892:  MOVFF  03,53
1896:  MOVFF  02,52
189A:  MOVFF  01,51
189E:  MOVFF  00,50
18A2:  CLRF   57
18A4:  CLRF   56
18A6:  CLRF   55
18A8:  MOVLW  7E
18AA:  MOVWF  54
18AC:  CALL   0DF4
18B0:  MOVFF  28,FEA
18B4:  MOVFF  27,FE9
18B8:  MOVFF  03,4D
18BC:  MOVFF  02,4C
18C0:  MOVFF  01,4B
18C4:  MOVFF  00,4A
18C8:  RCALL  1232
18CA:  MOVLW  2F
18CC:  BSF    FD8.0
18CE:  SUBFWB 01,W
18D0:  MOVWF  29
18D2:  MOVLW  1E
18D4:  MOVWF  31
18D6:  MOVLW  2F
18D8:  MOVWF  32
18DA:  MOVFF  22,33
18DE:  MOVFF  29,34
18E2:  CLRF   35
18E4:  CALL   0434
....................       theta = (theta > 5.9) ? 0 : (theta += .3); 
18E8:  MOVLW  CD
18EA:  MOVWF  4D
18EC:  MOVLW  CC
18EE:  MOVWF  4C
18F0:  MOVLW  3C
18F2:  MOVWF  4B
18F4:  MOVLW  81
18F6:  MOVWF  4A
18F8:  MOVFF  1B,51
18FC:  MOVFF  1A,50
1900:  MOVFF  19,4F
1904:  MOVFF  18,4E
1908:  CALL   1060
190C:  BNC   1918
190E:  CLRF   00
1910:  CLRF   01
1912:  CLRF   02
1914:  CLRF   03
1916:  BRA    195E
1918:  BCF    FD8.1
191A:  MOVFF  1B,53
191E:  MOVFF  1A,52
1922:  MOVFF  19,51
1926:  MOVFF  18,50
192A:  MOVLW  9A
192C:  MOVWF  57
192E:  MOVLW  99
1930:  MOVWF  56
1932:  MOVLW  19
1934:  MOVWF  55
1936:  MOVLW  7D
1938:  MOVWF  54
193A:  CALL   0DF4
193E:  MOVFF  03,1B
1942:  MOVFF  02,1A
1946:  MOVFF  01,19
194A:  MOVFF  00,18
194E:  MOVFF  18,00
1952:  MOVFF  19,01
1956:  MOVFF  1A,02
195A:  MOVFF  1B,03
195E:  MOVFF  03,1B
1962:  MOVFF  02,1A
1966:  MOVFF  01,19
196A:  MOVFF  00,18
....................       glcd_line(30, 47, 30+(int)(8*sin(theta)+.5), 47-(int)(8*cos(theta)+.5), ON); 
196E:  MOVFF  1B,1F
1972:  MOVFF  1A,1E
1976:  MOVFF  19,1D
197A:  MOVFF  18,1C
197E:  RCALL  15B0
1980:  CLRF   51
1982:  CLRF   50
1984:  CLRF   4F
1986:  MOVLW  82
1988:  MOVWF  4E
198A:  MOVFF  03,55
198E:  MOVFF  02,54
1992:  MOVFF  01,53
1996:  MOVFF  00,52
199A:  CALL   0A08
199E:  MOVFF  00,1C
19A2:  MOVFF  01,1D
19A6:  MOVFF  02,1E
19AA:  MOVFF  03,1F
19AE:  MOVFF  FEA,21
19B2:  MOVFF  FE9,20
19B6:  BCF    FD8.1
19B8:  MOVFF  03,53
19BC:  MOVFF  02,52
19C0:  MOVFF  01,51
19C4:  MOVFF  00,50
19C8:  CLRF   57
19CA:  CLRF   56
19CC:  CLRF   55
19CE:  MOVLW  7E
19D0:  MOVWF  54
19D2:  CALL   0DF4
19D6:  MOVFF  21,FEA
19DA:  MOVFF  20,FE9
19DE:  MOVFF  03,4D
19E2:  MOVFF  02,4C
19E6:  MOVFF  01,4B
19EA:  MOVFF  00,4A
19EE:  RCALL  1232
19F0:  MOVLW  1E
19F2:  ADDWF  01,W
19F4:  MOVWF  22
19F6:  MOVFF  1B,27
19FA:  MOVFF  1A,26
19FE:  MOVFF  19,25
1A02:  MOVFF  18,24
1A06:  RCALL  126C
1A08:  CLRF   51
1A0A:  CLRF   50
1A0C:  CLRF   4F
1A0E:  MOVLW  82
1A10:  MOVWF  4E
1A12:  MOVFF  03,55
1A16:  MOVFF  02,54
1A1A:  MOVFF  01,53
1A1E:  MOVFF  00,52
1A22:  CALL   0A08
1A26:  MOVFF  00,23
1A2A:  MOVFF  01,24
1A2E:  MOVFF  02,25
1A32:  MOVFF  03,26
1A36:  MOVFF  FEA,28
1A3A:  MOVFF  FE9,27
1A3E:  BCF    FD8.1
1A40:  MOVFF  03,53
1A44:  MOVFF  02,52
1A48:  MOVFF  01,51
1A4C:  MOVFF  00,50
1A50:  CLRF   57
1A52:  CLRF   56
1A54:  CLRF   55
1A56:  MOVLW  7E
1A58:  MOVWF  54
1A5A:  CALL   0DF4
1A5E:  MOVFF  28,FEA
1A62:  MOVFF  27,FE9
1A66:  MOVFF  03,4D
1A6A:  MOVFF  02,4C
1A6E:  MOVFF  01,4B
1A72:  MOVFF  00,4A
1A76:  CALL   1232
1A7A:  MOVLW  2F
1A7C:  BSF    FD8.0
1A7E:  SUBFWB 01,W
1A80:  MOVWF  29
1A82:  MOVLW  1E
1A84:  MOVWF  31
1A86:  MOVLW  2F
1A88:  MOVWF  32
1A8A:  MOVFF  22,33
1A8E:  MOVFF  29,34
1A92:  MOVLW  01
1A94:  MOVWF  35
1A96:  CALL   0434
....................  
....................       #ifdef FAST_GLCD 
....................       glcd_update(); 
....................       #else 
....................       delay_ms(100);    // Reduces flicker by allowing pixels to be on 
1A9A:  MOVLW  64
1A9C:  MOVWF  1C
1A9E:  BRA    15F8
....................                         // much longer than off 
....................       #endif 
....................    } 
1AA0:  BRA    16E4
.................... } 
1AA2:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0F   BROWNOUT WDT128 NOWDT BORV20 NOPUT
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB
